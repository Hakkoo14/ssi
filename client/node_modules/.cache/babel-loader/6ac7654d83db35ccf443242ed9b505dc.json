{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar tryEach = require('async/tryEach');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:dialer');\n\nvar DialQueue = require('./queue');\n/**\n * Track dials per peer and limited them.\n */\n\n\nvar LimitDialer = /*#__PURE__*/function () {\n  /**\n   * Create a new dialer.\n   *\n   * @param {number} perPeerLimit\n   * @param {number} dialTimeout\n   */\n  function LimitDialer(perPeerLimit, dialTimeout) {\n    _classCallCheck(this, LimitDialer);\n\n    log('create: %s peer limit, %s dial timeout', perPeerLimit, dialTimeout);\n    this.perPeerLimit = perPeerLimit;\n    this.dialTimeout = dialTimeout;\n    this.queues = new Map();\n  }\n  /**\n   * Dial a list of multiaddrs on the given transport.\n   *\n   * @param {PeerId} peer\n   * @param {SwarmTransport} transport\n   * @param {Array<Multiaddr>} addrs\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(LimitDialer, [{\n    key: \"dialMany\",\n    value: function dialMany(peer, transport, addrs, callback) {\n      var _this = this;\n\n      log('dialMany:start'); // we use a token to track if we want to cancel following dials\n\n      var token = {\n        cancel: false\n      };\n      var errors = [];\n      var tasks = addrs.map(function (m) {\n        return function (cb) {\n          return _this.dialSingle(peer, transport, m, token, function (err, result) {\n            if (err) {\n              errors.push(err);\n              return cb(err);\n            }\n\n            return cb(null, result);\n          });\n        };\n      });\n      tryEach(tasks, function (_, result) {\n        if (result && result.conn) {\n          log('dialMany:success');\n          return callback(null, result);\n        }\n\n        log('dialMany:error');\n        callback(errors);\n      });\n    }\n    /**\n     * Dial a single multiaddr on the given transport.\n     *\n     * @param {PeerId} peer\n     * @param {SwarmTransport} transport\n     * @param {Multiaddr} addr\n     * @param {CancelToken} token\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dialSingle\",\n    value: function dialSingle(peer, transport, addr, token, callback) {\n      var ps = peer.toB58String();\n      log('dialSingle: %s:%s', ps, addr.toString());\n      var q;\n\n      if (this.queues.has(ps)) {\n        q = this.queues.get(ps);\n      } else {\n        q = new DialQueue(this.perPeerLimit, this.dialTimeout);\n        this.queues.set(ps, q);\n      }\n\n      q.push(transport, addr, token, callback);\n    }\n  }]);\n\n  return LimitDialer;\n}();\n\nmodule.exports = LimitDialer;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/libp2p-switch/src/limit-dialer/index.js"],"names":["tryEach","require","debug","log","DialQueue","LimitDialer","perPeerLimit","dialTimeout","queues","Map","peer","transport","addrs","callback","token","cancel","errors","tasks","map","m","cb","dialSingle","err","result","push","_","conn","addr","ps","toB58String","toString","q","has","get","set","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst tryEach = require('async/tryEach')\nconst debug = require('debug')\n\nconst log = debug('libp2p:switch:dialer')\n\nconst DialQueue = require('./queue')\n\n/**\n * Track dials per peer and limited them.\n */\nclass LimitDialer {\n  /**\n   * Create a new dialer.\n   *\n   * @param {number} perPeerLimit\n   * @param {number} dialTimeout\n   */\n  constructor (perPeerLimit, dialTimeout) {\n    log('create: %s peer limit, %s dial timeout', perPeerLimit, dialTimeout)\n    this.perPeerLimit = perPeerLimit\n    this.dialTimeout = dialTimeout\n    this.queues = new Map()\n  }\n\n  /**\n   * Dial a list of multiaddrs on the given transport.\n   *\n   * @param {PeerId} peer\n   * @param {SwarmTransport} transport\n   * @param {Array<Multiaddr>} addrs\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  dialMany (peer, transport, addrs, callback) {\n    log('dialMany:start')\n    // we use a token to track if we want to cancel following dials\n    const token = { cancel: false }\n\n    let errors = []\n    const tasks = addrs.map((m) => {\n      return (cb) => this.dialSingle(peer, transport, m, token, (err, result) => {\n        if (err) {\n          errors.push(err)\n          return cb(err)\n        }\n        return cb(null, result)\n      })\n    })\n\n    tryEach(tasks, (_, result) => {\n      if (result && result.conn) {\n        log('dialMany:success')\n        return callback(null, result)\n      }\n\n      log('dialMany:error')\n      callback(errors)\n    })\n  }\n\n  /**\n   * Dial a single multiaddr on the given transport.\n   *\n   * @param {PeerId} peer\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {CancelToken} token\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  dialSingle (peer, transport, addr, token, callback) {\n    const ps = peer.toB58String()\n    log('dialSingle: %s:%s', ps, addr.toString())\n    let q\n    if (this.queues.has(ps)) {\n      q = this.queues.get(ps)\n    } else {\n      q = new DialQueue(this.perPeerLimit, this.dialTimeout)\n      this.queues.set(ps, q)\n    }\n\n    q.push(transport, addr, token, callback)\n  }\n}\n\nmodule.exports = LimitDialer\n"]},"metadata":{},"sourceType":"script"}