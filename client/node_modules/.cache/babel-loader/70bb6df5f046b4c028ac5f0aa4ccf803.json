{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar FSM = require('fsm-event');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar each = require('async/each');\n\nvar eachSeries = require('async/eachSeries');\n\nvar series = require('async/series');\n\nvar Circuit = require('libp2p-circuit');\n\nvar TransportManager = require('./transport');\n\nvar ConnectionManager = require('./connection/manager');\n\nvar getPeerInfo = require('./get-peer-info');\n\nvar getDialer = require('./dialer');\n\nvar connectionHandler = require('./connection/handler');\n\nvar ProtocolMuxer = require('./protocol-muxer');\n\nvar plaintext = require('./plaintext');\n\nvar Observer = require('./observer');\n\nvar Stats = require('./stats');\n\nvar assert = require('assert');\n\nvar Errors = require('./errors');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch');\nlog.error = debug('libp2p:switch:error');\n/**\n * @fires Switch#stop Triggered when the switch has stopped\n * @fires Switch#start Triggered when the switch has started\n * @fires Switch#error Triggered whenever an error occurs\n */\n\nvar Switch = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Switch, _EventEmitter);\n\n  var _super = _createSuper(Switch);\n\n  function Switch(peerInfo, peerBook, options) {\n    var _this;\n\n    _classCallCheck(this, Switch);\n\n    _this = _super.call(this);\n    assert(peerInfo, 'You must provide a `peerInfo`');\n    assert(peerBook, 'You must provide a `peerBook`');\n    _this._peerInfo = peerInfo;\n    _this._peerBook = peerBook;\n    _this._options = options || {};\n\n    _this.setMaxListeners(Infinity); // transports --\n    // { key: transport }; e.g { tcp: <tcp> }\n\n\n    _this.transports = {}; // connections --\n    // { peerIdB58: { conn: <conn> }}\n\n    _this.conns = {}; // { protocol: handler }\n\n    _this.protocols = {}; // { muxerCodec: <muxer> } e.g { '/spdy/0.3.1': spdy }\n\n    _this.muxers = {}; // is the Identify protocol enabled?\n\n    _this.identify = false; // Crypto details\n\n    _this.crypto = plaintext;\n    _this.protector = _this._options.protector || null;\n    _this.transport = new TransportManager(_assertThisInitialized(_this));\n    _this.connection = new ConnectionManager(_assertThisInitialized(_this));\n    _this.observer = Observer(_assertThisInitialized(_this));\n    _this.stats = Stats(_this.observer, _this._options.stats);\n    _this.protocolMuxer = ProtocolMuxer(_this.protocols, _this.observer); // All purpose connection handler for managing incoming connections\n\n    _this._connectionHandler = connectionHandler(_assertThisInitialized(_this)); // Setup the internal state\n\n    _this.state = new FSM('STOPPED', {\n      STOPPED: {\n        start: 'STARTING',\n        stop: 'STOPPING' // ensures that any transports that were manually started are stopped\n\n      },\n      STARTING: {\n        done: 'STARTED',\n        stop: 'STOPPING'\n      },\n      STARTED: {\n        stop: 'STOPPING',\n        start: 'STARTED'\n      },\n      STOPPING: {\n        stop: 'STOPPING',\n        done: 'STOPPED'\n      }\n    });\n\n    _this.state.on('STARTING', function () {\n      log('The switch is starting');\n\n      _this._onStarting();\n    });\n\n    _this.state.on('STOPPING', function () {\n      log('The switch is stopping');\n\n      _this._onStopping();\n    });\n\n    _this.state.on('STARTED', function () {\n      log('The switch has started');\n\n      _this.emit('start');\n    });\n\n    _this.state.on('STOPPED', function () {\n      log('The switch has stopped');\n\n      _this.emit('stop');\n    });\n\n    _this.state.on('error', function (err) {\n      log.error(err);\n\n      _this.emit('error', err);\n    }); // higher level (public) API\n\n\n    _this.dialer = getDialer(_assertThisInitialized(_this));\n    _this.dial = _this.dialer.dial;\n    _this.dialFSM = _this.dialer.dialFSM;\n    return _this;\n  }\n  /**\n   * Returns a list of the transports peerInfo has addresses for\n   *\n   * @param {PeerInfo} peerInfo\n   * @returns {Array<Transport>}\n   */\n\n\n  _createClass(Switch, [{\n    key: \"availableTransports\",\n    value: function availableTransports(peerInfo) {\n      var _this2 = this;\n\n      var myAddrs = peerInfo.multiaddrs.toArray();\n      var myTransports = Object.keys(this.transports); // Only listen on transports we actually have addresses for\n\n      return myTransports.filter(function (ts) {\n        return _this2.transports[ts].filter(myAddrs).length > 0;\n      }) // push Circuit to be the last proto to be dialed, and alphabetize the others\n      .sort(function (a, b) {\n        if (a === Circuit.tag) return 1;\n        if (b === Circuit.tag) return -1;\n        return a < b ? -1 : 1;\n      });\n    }\n    /**\n     * Adds the `handlerFunc` and `matchFunc` to the Switch's protocol\n     * handler list for the given `protocol`. If the `matchFunc` returns\n     * true for a protocol check, the `handlerFunc` will be called.\n     *\n     * @param {string} protocol\n     * @param {function(string, Connection)} handlerFunc\n     * @param {function(string, string, function(Error, boolean))} matchFunc\n     * @returns {void}\n     */\n\n  }, {\n    key: \"handle\",\n    value: function handle(protocol, handlerFunc, matchFunc) {\n      this.protocols[protocol] = {\n        handlerFunc: handlerFunc,\n        matchFunc: matchFunc\n      };\n\n      this._peerInfo.protocols.add(protocol);\n    }\n    /**\n     * Removes the given protocol from the Switch's protocol list\n     *\n     * @param {string} protocol\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unhandle\",\n    value: function unhandle(protocol) {\n      if (this.protocols[protocol]) {\n        delete this.protocols[protocol];\n      }\n\n      this._peerInfo.protocols.delete(protocol);\n    }\n    /**\n     * If a muxed Connection exists for the given peer, it will be closed\n     * and its reference on the Switch will be removed.\n     *\n     * @param {PeerInfo|Multiaddr|PeerId} peer\n     * @param {function()} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"hangUp\",\n    value: function hangUp(peer, callback) {\n      var peerInfo = getPeerInfo(peer, this._peerBook);\n      var key = peerInfo.id.toB58String();\n\n      var conns = _toConsumableArray(this.connection.getAllById(key));\n\n      each(conns, function (conn, cb) {\n        conn.once('close', cb);\n        conn.close();\n      }, callback);\n    }\n    /**\n     * Returns whether or not the switch has any transports\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasTransports\",\n    value: function hasTransports() {\n      var transports = Object.keys(this.transports).filter(function (t) {\n        return t !== Circuit.tag;\n      });\n      return transports && transports.length > 0;\n    }\n    /**\n     * Issues a start on the Switch state.\n     *\n     * @param {function} callback deprecated: Listening for the `error` and `start` events are recommended\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      // Add once listener for deprecated callback support\n      this.once('start', callback);\n      this.state('start');\n    }\n    /**\n     * Issues a stop on the Switch state.\n     *\n     * @param {function} callback deprecated: Listening for the `error` and `stop` events are recommended\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      // Add once listener for deprecated callback support\n      this.once('stop', callback);\n      this.state('stop');\n    }\n    /**\n     * A listener that will start any necessary services and listeners\n     *\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onStarting\",\n    value: function _onStarting() {\n      var _this3 = this;\n\n      this.stats.start();\n      eachSeries(this.availableTransports(this._peerInfo), function (ts, cb) {\n        // Listen on the given transport\n        _this3.transport.listen(ts, {}, null, cb);\n      }, function (err) {\n        if (err) {\n          log.error(err);\n\n          _this3.emit('error', err);\n\n          return _this3.state('stop');\n        }\n\n        _this3.state('done');\n      });\n    }\n    /**\n     * A listener that will turn off all running services and listeners\n     *\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onStopping\",\n    value: function _onStopping() {\n      var _this4 = this;\n\n      this.stats.stop();\n      series([function (cb) {\n        each(_this4.transports, function (transport, cb) {\n          each(transport.listeners, function (listener, cb) {\n            listener.close(function (err) {\n              if (err) log.error(err);\n              cb();\n            });\n          }, cb);\n        }, cb);\n      }, function (cb) {\n        return each(_this4.connection.getAll(), function (conn, cb) {\n          conn.once('close', cb);\n          conn.close();\n        }, cb);\n      }], function (_) {\n        _this4.state('done');\n      });\n    }\n  }]);\n\n  return Switch;\n}(EventEmitter);\n\nmodule.exports = Switch;\nmodule.exports.errors = Errors;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/libp2p-switch/src/index.js"],"names":["FSM","require","EventEmitter","each","eachSeries","series","Circuit","TransportManager","ConnectionManager","getPeerInfo","getDialer","connectionHandler","ProtocolMuxer","plaintext","Observer","Stats","assert","Errors","debug","log","error","Switch","peerInfo","peerBook","options","_peerInfo","_peerBook","_options","setMaxListeners","Infinity","transports","conns","protocols","muxers","identify","crypto","protector","transport","connection","observer","stats","protocolMuxer","_connectionHandler","state","STOPPED","start","stop","STARTING","done","STARTED","STOPPING","on","_onStarting","_onStopping","emit","err","dialer","dial","dialFSM","myAddrs","multiaddrs","toArray","myTransports","Object","keys","filter","ts","length","sort","a","b","tag","protocol","handlerFunc","matchFunc","add","delete","peer","callback","key","id","toB58String","getAllById","conn","cb","once","close","t","availableTransports","listen","listeners","listener","getAll","_","module","exports","errors"],"mappings":"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","sourcesContent":["'use strict'\n\nconst FSM = require('fsm-event')\nconst EventEmitter = require('events').EventEmitter\nconst each = require('async/each')\nconst eachSeries = require('async/eachSeries')\nconst series = require('async/series')\nconst Circuit = require('libp2p-circuit')\nconst TransportManager = require('./transport')\nconst ConnectionManager = require('./connection/manager')\nconst getPeerInfo = require('./get-peer-info')\nconst getDialer = require('./dialer')\nconst connectionHandler = require('./connection/handler')\nconst ProtocolMuxer = require('./protocol-muxer')\nconst plaintext = require('./plaintext')\nconst Observer = require('./observer')\nconst Stats = require('./stats')\nconst assert = require('assert')\nconst Errors = require('./errors')\nconst debug = require('debug')\nconst log = debug('libp2p:switch')\nlog.error = debug('libp2p:switch:error')\n\n/**\n * @fires Switch#stop Triggered when the switch has stopped\n * @fires Switch#start Triggered when the switch has started\n * @fires Switch#error Triggered whenever an error occurs\n */\nclass Switch extends EventEmitter {\n  constructor (peerInfo, peerBook, options) {\n    super()\n    assert(peerInfo, 'You must provide a `peerInfo`')\n    assert(peerBook, 'You must provide a `peerBook`')\n\n    this._peerInfo = peerInfo\n    this._peerBook = peerBook\n    this._options = options || {}\n\n    this.setMaxListeners(Infinity)\n    // transports --\n    // { key: transport }; e.g { tcp: <tcp> }\n    this.transports = {}\n\n    // connections --\n    // { peerIdB58: { conn: <conn> }}\n    this.conns = {}\n\n    // { protocol: handler }\n    this.protocols = {}\n\n    // { muxerCodec: <muxer> } e.g { '/spdy/0.3.1': spdy }\n    this.muxers = {}\n\n    // is the Identify protocol enabled?\n    this.identify = false\n\n    // Crypto details\n    this.crypto = plaintext\n\n    this.protector = this._options.protector || null\n\n    this.transport = new TransportManager(this)\n    this.connection = new ConnectionManager(this)\n\n    this.observer = Observer(this)\n    this.stats = Stats(this.observer, this._options.stats)\n    this.protocolMuxer = ProtocolMuxer(this.protocols, this.observer)\n\n    // All purpose connection handler for managing incoming connections\n    this._connectionHandler = connectionHandler(this)\n\n    // Setup the internal state\n    this.state = new FSM('STOPPED', {\n      STOPPED: {\n        start: 'STARTING',\n        stop: 'STOPPING' // ensures that any transports that were manually started are stopped\n      },\n      STARTING: {\n        done: 'STARTED',\n        stop: 'STOPPING'\n      },\n      STARTED: {\n        stop: 'STOPPING',\n        start: 'STARTED'\n      },\n      STOPPING: {\n        stop: 'STOPPING',\n        done: 'STOPPED'\n      }\n    })\n    this.state.on('STARTING', () => {\n      log('The switch is starting')\n      this._onStarting()\n    })\n    this.state.on('STOPPING', () => {\n      log('The switch is stopping')\n      this._onStopping()\n    })\n    this.state.on('STARTED', () => {\n      log('The switch has started')\n      this.emit('start')\n    })\n    this.state.on('STOPPED', () => {\n      log('The switch has stopped')\n      this.emit('stop')\n    })\n    this.state.on('error', (err) => {\n      log.error(err)\n      this.emit('error', err)\n    })\n\n    // higher level (public) API\n    this.dialer = getDialer(this)\n    this.dial = this.dialer.dial\n    this.dialFSM = this.dialer.dialFSM\n  }\n\n  /**\n   * Returns a list of the transports peerInfo has addresses for\n   *\n   * @param {PeerInfo} peerInfo\n   * @returns {Array<Transport>}\n   */\n  availableTransports (peerInfo) {\n    const myAddrs = peerInfo.multiaddrs.toArray()\n    const myTransports = Object.keys(this.transports)\n\n    // Only listen on transports we actually have addresses for\n    return myTransports.filter((ts) => this.transports[ts].filter(myAddrs).length > 0)\n      // push Circuit to be the last proto to be dialed, and alphabetize the others\n      .sort((a, b) => {\n        if (a === Circuit.tag) return 1\n        if (b === Circuit.tag) return -1\n        return a < b ? -1 : 1\n      })\n  }\n\n  /**\n   * Adds the `handlerFunc` and `matchFunc` to the Switch's protocol\n   * handler list for the given `protocol`. If the `matchFunc` returns\n   * true for a protocol check, the `handlerFunc` will be called.\n   *\n   * @param {string} protocol\n   * @param {function(string, Connection)} handlerFunc\n   * @param {function(string, string, function(Error, boolean))} matchFunc\n   * @returns {void}\n   */\n  handle (protocol, handlerFunc, matchFunc) {\n    this.protocols[protocol] = {\n      handlerFunc: handlerFunc,\n      matchFunc: matchFunc\n    }\n    this._peerInfo.protocols.add(protocol)\n  }\n\n  /**\n   * Removes the given protocol from the Switch's protocol list\n   *\n   * @param {string} protocol\n   * @returns {void}\n   */\n  unhandle (protocol) {\n    if (this.protocols[protocol]) {\n      delete this.protocols[protocol]\n    }\n    this._peerInfo.protocols.delete(protocol)\n  }\n\n  /**\n   * If a muxed Connection exists for the given peer, it will be closed\n   * and its reference on the Switch will be removed.\n   *\n   * @param {PeerInfo|Multiaddr|PeerId} peer\n   * @param {function()} callback\n   * @returns {void}\n   */\n  hangUp (peer, callback) {\n    const peerInfo = getPeerInfo(peer, this._peerBook)\n    const key = peerInfo.id.toB58String()\n    const conns = [...this.connection.getAllById(key)]\n    each(conns, (conn, cb) => {\n      conn.once('close', cb)\n      conn.close()\n    }, callback)\n  }\n\n  /**\n   * Returns whether or not the switch has any transports\n   *\n   * @returns {boolean}\n   */\n  hasTransports () {\n    const transports = Object.keys(this.transports).filter((t) => t !== Circuit.tag)\n    return transports && transports.length > 0\n  }\n\n  /**\n   * Issues a start on the Switch state.\n   *\n   * @param {function} callback deprecated: Listening for the `error` and `start` events are recommended\n   * @returns {void}\n   */\n  start (callback = () => {}) {\n    // Add once listener for deprecated callback support\n    this.once('start', callback)\n\n    this.state('start')\n  }\n\n  /**\n   * Issues a stop on the Switch state.\n   *\n   * @param {function} callback deprecated: Listening for the `error` and `stop` events are recommended\n   * @returns {void}\n   */\n  stop (callback = () => {}) {\n    // Add once listener for deprecated callback support\n    this.once('stop', callback)\n\n    this.state('stop')\n  }\n\n  /**\n   * A listener that will start any necessary services and listeners\n   *\n   * @private\n   * @returns {void}\n   */\n  _onStarting () {\n    this.stats.start()\n    eachSeries(this.availableTransports(this._peerInfo), (ts, cb) => {\n      // Listen on the given transport\n      this.transport.listen(ts, {}, null, cb)\n    }, (err) => {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n        return this.state('stop')\n      }\n      this.state('done')\n    })\n  }\n\n  /**\n   * A listener that will turn off all running services and listeners\n   *\n   * @private\n   * @returns {void}\n   */\n  _onStopping () {\n    this.stats.stop()\n    series([\n      (cb) => {\n        each(this.transports, (transport, cb) => {\n          each(transport.listeners, (listener, cb) => {\n            listener.close((err) => {\n              if (err) log.error(err)\n              cb()\n            })\n          }, cb)\n        }, cb)\n      },\n      (cb) => each(this.connection.getAll(), (conn, cb) => {\n        conn.once('close', cb)\n        conn.close()\n      }, cb)\n    ], (_) => {\n      this.state('done')\n    })\n  }\n}\n\nmodule.exports = Switch\nmodule.exports.errors = Errors\n"]},"metadata":{},"sourceType":"script"}