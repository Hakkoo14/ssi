{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar values = require('pull-stream/sources/values');\n\nvar collect = require('pull-stream/sinks/collect');\n\nvar empty = require('pull-stream/sources/empty');\n\nvar pull = require('pull-stream/pull');\n\nvar lp = require('pull-length-prefixed');\n\nvar handshake = require('pull-handshake');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:circuit:stream-handler');\nlog.err = debug('libp2p:circuit:error:stream-handler');\n\nvar StreamHandler = /*#__PURE__*/function () {\n  /**\n   * Create a stream handler for connection\n   *\n   * @param {Connection} conn - connection to read/write\n   * @param {Function|undefined} cb - handshake callback called on error\n   * @param {Number} timeout - handshake timeout\n   * @param {Number} maxLength - max bytes length of message\n   */\n  function StreamHandler(conn, cb, timeout, maxLength) {\n    _classCallCheck(this, StreamHandler);\n\n    this.conn = conn;\n    this.stream = null;\n    this.shake = null;\n    this.timeout = cb || 1000 * 60;\n    this.maxLength = maxLength || 4096;\n\n    if (typeof cb === 'function') {\n      this.timeout = timeout || 1000 * 60;\n    }\n\n    this.stream = handshake({\n      timeout: this.timeout\n    }, cb);\n    this.shake = this.stream.handshake;\n    pull(this.stream, conn, this.stream);\n  }\n\n  _createClass(StreamHandler, [{\n    key: \"isValid\",\n    value: function isValid() {\n      return this.conn && this.shake && this.stream;\n    }\n    /**\n     * Read and decode message\n     *\n     * @param {Function} cb\n     * @returns {void|Function}\n     */\n\n  }, {\n    key: \"read\",\n    value: function read(cb) {\n      if (!this.isValid()) {\n        return cb(new Error(\"handler is not in a valid state\"));\n      }\n\n      lp.decodeFromReader(this.shake, {\n        maxLength: this.maxLength\n      }, function (err, msg) {\n        if (err) {\n          log.err(err); // this.shake.abort(err)\n\n          return cb(err);\n        }\n\n        return cb(null, msg);\n      });\n    }\n    /**\n     * Encode and write array of buffers\n     *\n     * @param {Buffer[]} msg\n     * @param {Function} [cb]\n     * @returns {Function}\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(msg, cb) {\n      var _this = this;\n\n      cb = cb || function () {};\n\n      if (!this.isValid()) {\n        return cb(new Error(\"handler is not in a valid state\"));\n      }\n\n      pull(values([msg]), lp.encode(), collect(function (err, encoded) {\n        if (err) {\n          log.err(err);\n\n          _this.shake.abort(err);\n\n          return cb(err);\n        }\n\n        encoded.forEach(function (e) {\n          return _this.shake.write(e);\n        });\n        cb();\n      }));\n    }\n    /**\n     * Get the raw Connection\n     *\n     * @returns {null|Connection|*}\n     */\n\n  }, {\n    key: \"getRawConn\",\n    value: function getRawConn() {\n      return this.conn;\n    }\n    /**\n     * Return the handshake rest stream and invalidate handler\n     *\n     * @return {*|{source, sink}}\n     */\n\n  }, {\n    key: \"rest\",\n    value: function rest() {\n      var rest = this.shake.rest();\n      this.conn = null;\n      this.stream = null;\n      this.shake = null;\n      return rest;\n    }\n    /**\n     * Close the stream\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (!this.isValid()) {\n        return;\n      } // close stream\n\n\n      pull(empty(), this.rest());\n    }\n  }]);\n\n  return StreamHandler;\n}();\n\nmodule.exports = StreamHandler;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-circuit/src/circuit/stream-handler.js"],"names":["values","require","collect","empty","pull","lp","handshake","debug","log","err","StreamHandler","conn","cb","timeout","maxLength","stream","shake","isValid","Error","decodeFromReader","msg","encode","encoded","abort","forEach","e","write","rest","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst values = require('pull-stream/sources/values')\nconst collect = require('pull-stream/sinks/collect')\nconst empty = require('pull-stream/sources/empty')\nconst pull = require('pull-stream/pull')\nconst lp = require('pull-length-prefixed')\nconst handshake = require('pull-handshake')\n\nconst debug = require('debug')\nconst log = debug('libp2p:circuit:stream-handler')\nlog.err = debug('libp2p:circuit:error:stream-handler')\n\nclass StreamHandler {\n  /**\n   * Create a stream handler for connection\n   *\n   * @param {Connection} conn - connection to read/write\n   * @param {Function|undefined} cb - handshake callback called on error\n   * @param {Number} timeout - handshake timeout\n   * @param {Number} maxLength - max bytes length of message\n   */\n  constructor (conn, cb, timeout, maxLength) {\n    this.conn = conn\n    this.stream = null\n    this.shake = null\n    this.timeout = cb || 1000 * 60\n    this.maxLength = maxLength || 4096\n\n    if (typeof cb === 'function') {\n      this.timeout = timeout || 1000 * 60\n    }\n\n    this.stream = handshake({ timeout: this.timeout }, cb)\n    this.shake = this.stream.handshake\n\n    pull(this.stream, conn, this.stream)\n  }\n\n  isValid () {\n    return this.conn && this.shake && this.stream\n  }\n\n  /**\n   * Read and decode message\n   *\n   * @param {Function} cb\n   * @returns {void|Function}\n   */\n  read (cb) {\n    if (!this.isValid()) {\n      return cb(new Error(`handler is not in a valid state`))\n    }\n\n    lp.decodeFromReader(\n      this.shake,\n      { maxLength: this.maxLength },\n      (err, msg) => {\n        if (err) {\n          log.err(err)\n          // this.shake.abort(err)\n          return cb(err)\n        }\n\n        return cb(null, msg)\n      })\n  }\n\n  /**\n   * Encode and write array of buffers\n   *\n   * @param {Buffer[]} msg\n   * @param {Function} [cb]\n   * @returns {Function}\n   */\n  write (msg, cb) {\n    cb = cb || (() => {})\n\n    if (!this.isValid()) {\n      return cb(new Error(`handler is not in a valid state`))\n    }\n\n    pull(\n      values([msg]),\n      lp.encode(),\n      collect((err, encoded) => {\n        if (err) {\n          log.err(err)\n          this.shake.abort(err)\n          return cb(err)\n        }\n\n        encoded.forEach((e) => this.shake.write(e))\n        cb()\n      })\n    )\n  }\n\n  /**\n   * Get the raw Connection\n   *\n   * @returns {null|Connection|*}\n   */\n  getRawConn () {\n    return this.conn\n  }\n\n  /**\n   * Return the handshake rest stream and invalidate handler\n   *\n   * @return {*|{source, sink}}\n   */\n  rest () {\n    const rest = this.shake.rest()\n\n    this.conn = null\n    this.stream = null\n    this.shake = null\n    return rest\n  }\n\n  /**\n   * Close the stream\n   *\n   * @returns {undefined}\n   */\n  close () {\n    if (!this.isValid()) {\n      return\n    }\n\n    // close stream\n    pull(\n      empty(),\n      this.rest()\n    )\n  }\n}\n\nmodule.exports = StreamHandler\n"]},"metadata":{},"sourceType":"script"}