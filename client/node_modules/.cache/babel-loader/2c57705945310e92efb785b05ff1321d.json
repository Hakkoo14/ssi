{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Key = require('interface-datastore').Key;\n\nvar KeytransformDatastore = require('./keytransform');\n/* ::\nimport type {Callback, Datastore, Query, QueryResult} from 'interface-datastore'\n*/\n\n/**\n * Wraps a given datastore into a keytransform which\n * makes a given prefix transparent.\n *\n * For example, if the prefix is `new Key(/hello)` a call\n * to `store.put(new Key('/world'), mydata)` would store the data under\n * `/hello/world`.\n *\n */\n\n\nvar NamespaceDatastore\n/* :: <Value> */\n= /*#__PURE__*/function (_KeytransformDatastor) {\n  _inherits(NamespaceDatastore, _KeytransformDatastor);\n\n  var _super = _createSuper(NamespaceDatastore);\n\n  /* :: prefix: Key */\n  function NamespaceDatastore(child\n  /* : Datastore<Value> */\n  , prefix\n  /* : Key */\n  ) {\n    var _this;\n\n    _classCallCheck(this, NamespaceDatastore);\n\n    _this = _super.call(this, child, {\n      convert: function convert(key\n      /* : Key */\n      )\n      /* : Key */\n      {\n        return prefix.child(key);\n      },\n      invert: function invert(key\n      /* : Key */\n      )\n      /* : Key */\n      {\n        if (prefix.toString() === '/') {\n          return key;\n        }\n\n        if (!prefix.isAncestorOf(key)) {\n          throw new Error(\"Expected prefix: (\".concat(prefix.toString(), \") in key: \").concat(key.toString()));\n        }\n\n        return new Key(key.toString().slice(prefix.toString().length), false);\n      }\n    });\n    _this.prefix = prefix;\n    return _this;\n  }\n\n  _createClass(NamespaceDatastore, [{\n    key: \"query\",\n    value: function query(q\n    /* : Query<Value> */\n    )\n    /* : QueryResult<Value> */\n    {\n      if (q.prefix && this.prefix.toString() !== '/') {\n        return _get(_getPrototypeOf(NamespaceDatastore.prototype), \"query\", this).call(this, Object.assign({}, q, {\n          prefix: this.prefix.child(new Key(q.prefix)).toString()\n        }));\n      }\n\n      return _get(_getPrototypeOf(NamespaceDatastore.prototype), \"query\", this).call(this, q);\n    }\n  }]);\n\n  return NamespaceDatastore;\n}(\n/* ::\nimport type {Callback, Datastore, Query, QueryResult} from 'interface-datastore'\n*/\n\n/**\n * Wraps a given datastore into a keytransform which\n * makes a given prefix transparent.\n *\n * For example, if the prefix is `new Key(/hello)` a call\n * to `store.put(new Key('/world'), mydata)` would store the data under\n * `/hello/world`.\n *\n */\n\n/* :: <Value> */\nKeytransformDatastore\n/* :: <Value> */\n);\n\nmodule.exports = NamespaceDatastore;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/datastore-core/src/namespace.js"],"names":["Key","require","KeytransformDatastore","NamespaceDatastore","child","prefix","convert","key","invert","toString","isAncestorOf","Error","slice","length","q","Object","assign","module","exports"],"mappings":"AAAA;AACA;;;;;;;;;;;;;;AAEA,IAAMA,GAAG,GAAGC,OAAO,CAAC,qBAAD,CAAP,CAA+BD,GAA3C;;AACA,IAAME,qBAAqB,GAAGD,OAAO,CAAC,gBAAD,CAArC;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACME;AAAkB;;;;;;AACtB;AAEA,8BAAaC;AAAK;AAAlB,IAA4CC;AAAM;AAAlD,IAA+D;AAAA;;AAAA;;AAC7D,8BAAMD,KAAN,EAAa;AACXE,MAAAA,OADW,mBACFC;AAAG;AADD;AACa;AAAY;AAClC,eAAOF,MAAM,CAACD,KAAP,CAAaG,GAAb,CAAP;AACD,OAHU;AAIXC,MAAAA,MAJW,kBAIHD;AAAG;AAJA;AAIY;AAAY;AACjC,YAAIF,MAAM,CAACI,QAAP,OAAsB,GAA1B,EAA+B;AAC7B,iBAAOF,GAAP;AACD;;AAED,YAAI,CAACF,MAAM,CAACK,YAAP,CAAoBH,GAApB,CAAL,EAA+B;AAC7B,gBAAM,IAAII,KAAJ,6BAA+BN,MAAM,CAACI,QAAP,EAA/B,uBAA6DF,GAAG,CAACE,QAAJ,EAA7D,EAAN;AACD;;AAED,eAAO,IAAIT,GAAJ,CAAQO,GAAG,CAACE,QAAJ,GAAeG,KAAf,CAAqBP,MAAM,CAACI,QAAP,GAAkBI,MAAvC,CAAR,EAAwD,KAAxD,CAAP;AACD;AAdU,KAAb;AAiBA,UAAKR,MAAL,GAAcA,MAAd;AAlB6D;AAmB9D;;;;WAED,eAAOS;AAAE;AAAT;AAA8B;AAA2B;AACvD,UAAIA,CAAC,CAACT,MAAF,IAAY,KAAKA,MAAL,CAAYI,QAAZ,OAA2B,GAA3C,EAAgD;AAC9C,6FAAmBM,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,CAAlB,EAAqB;AACtCT,UAAAA,MAAM,EAAE,KAAKA,MAAL,CAAYD,KAAZ,CAAkB,IAAIJ,GAAJ,CAAQc,CAAC,CAACT,MAAV,CAAlB,EAAqCI,QAArC;AAD8B,SAArB,CAAnB;AAGD;;AACD,2FAAmBK,CAAnB;AACD;;;;;AA5CH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACwB;AAAyBZ;AAAsB;;;AAkCvEe,MAAM,CAACC,OAAP,GAAiBf,kBAAjB","sourcesContent":["/* @flow */\n'use strict'\n\nconst Key = require('interface-datastore').Key\nconst KeytransformDatastore = require('./keytransform')\n\n/* ::\nimport type {Callback, Datastore, Query, QueryResult} from 'interface-datastore'\n*/\n\n/**\n * Wraps a given datastore into a keytransform which\n * makes a given prefix transparent.\n *\n * For example, if the prefix is `new Key(/hello)` a call\n * to `store.put(new Key('/world'), mydata)` would store the data under\n * `/hello/world`.\n *\n */\nclass NamespaceDatastore/* :: <Value> */ extends KeytransformDatastore /* :: <Value> */ {\n  /* :: prefix: Key */\n\n  constructor (child/* : Datastore<Value> */, prefix/* : Key */) {\n    super(child, {\n      convert (key/* : Key */)/* : Key */ {\n        return prefix.child(key)\n      },\n      invert (key/* : Key */)/* : Key */ {\n        if (prefix.toString() === '/') {\n          return key\n        }\n\n        if (!prefix.isAncestorOf(key)) {\n          throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`)\n        }\n\n        return new Key(key.toString().slice(prefix.toString().length), false)\n      }\n    })\n\n    this.prefix = prefix\n  }\n\n  query (q /* : Query<Value> */)/* : QueryResult<Value> */ {\n    if (q.prefix && this.prefix.toString() !== '/') {\n      return super.query(Object.assign({}, q, {\n        prefix: this.prefix.child(new Key(q.prefix)).toString()\n      }))\n    }\n    return super.query(q)\n  }\n}\n\nmodule.exports = NamespaceDatastore\n"]},"metadata":{},"sourceType":"script"}