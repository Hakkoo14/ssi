{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar pull = require('pull-stream');\n\nvar lp = require('pull-length-prefixed');\n\nvar assert = require('assert');\n\nvar BaseProtocol = require('libp2p-pubsub');\n\nvar _require = require('libp2p-pubsub'),\n    message = _require.message,\n    utils = _require.utils;\n\nvar config = require('./config');\n\nvar multicodec = config.multicodec;\nvar ensureArray = utils.ensureArray;\n\nvar setImmediate = require('async/setImmediate');\n\nvar asyncMap = require('async/map');\n\nvar noop = function noop() {};\n/**\n * FloodSub (aka dumbsub is an implementation of pubsub focused on\n * delivering an API for Publish/Subscribe, but with no CastTree Forming\n * (it just floods the network).\n */\n\n\nvar FloodSub = /*#__PURE__*/function (_BaseProtocol) {\n  _inherits(FloodSub, _BaseProtocol);\n\n  var _super = _createSuper(FloodSub);\n\n  /**\n   * @param {Object} libp2p\n   * @constructor\n   */\n  function FloodSub(libp2p) {\n    var _this;\n\n    _classCallCheck(this, FloodSub);\n\n    _this = _super.call(this, 'libp2p:floodsub', multicodec, libp2p);\n    /**\n     * List of our subscriptions\n     * @type {Set<string>}\n     */\n\n    _this.subscriptions = new Set();\n    return _this;\n  }\n  /**\n   * Dial a received peer.\n   * @override\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Connection} conn connection to the peer\n   * @param {function} callback\n   */\n\n\n  _createClass(FloodSub, [{\n    key: \"_onDial\",\n    value: function _onDial(peerInfo, conn, callback) {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(FloodSub.prototype), \"_onDial\", this).call(this, peerInfo, conn, function (err) {\n        if (err) return callback(err);\n        var idB58Str = peerInfo.id.toB58String();\n\n        var peer = _this2.peers.get(idB58Str);\n\n        if (peer && peer.isWritable) {\n          // Immediately send my own subscriptions to the newly established conn\n          peer.sendSubscriptions(_this2.subscriptions);\n        }\n\n        setImmediate(function () {\n          return callback();\n        });\n      });\n    }\n    /**\n     * Overriding the implementation of _processConnection should keep the connection and is\n     * responsible for processing each RPC message received by other peers.\n     * @override\n     * @param {string} idB58Str peer id string in base58\n     * @param {Connection} conn connection\n     * @param {PeerInfo} peer peer info\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"_processConnection\",\n    value: function _processConnection(idB58Str, conn, peer) {\n      var _this3 = this;\n\n      pull(conn, lp.decode(), pull.map(function (data) {\n        return message.rpc.RPC.decode(data);\n      }), pull.drain(function (rpc) {\n        return _this3._onRpc(idB58Str, rpc);\n      }, function (err) {\n        return _this3._onConnectionEnd(idB58Str, peer, err);\n      }));\n    }\n  }, {\n    key: \"_onRpc\",\n    value: function _onRpc(idB58Str, rpc) {\n      if (!rpc) {\n        return;\n      }\n\n      this.log('rpc from', idB58Str);\n      var subs = rpc.subscriptions;\n      var msgs = rpc.msgs;\n\n      if (msgs && msgs.length) {\n        this._processRpcMessages(utils.normalizeInRpcMessages(rpc.msgs));\n      }\n\n      if (subs && subs.length) {\n        var peer = this.peers.get(idB58Str);\n\n        if (peer) {\n          peer.updateSubscriptions(subs);\n          this.emit('floodsub:subscription-change', peer.info, peer.topics, subs);\n        }\n      }\n    }\n  }, {\n    key: \"_processRpcMessages\",\n    value: function _processRpcMessages(msgs) {\n      var _this4 = this;\n\n      msgs.forEach(function (msg) {\n        var seqno = utils.msgId(msg.from, msg.seqno); // 1. check if I've seen the message, if yes, ignore\n\n        if (_this4.seenCache.has(seqno)) {\n          return;\n        }\n\n        _this4.seenCache.put(seqno); // 2. emit to self\n\n\n        _this4._emitMessages(msg.topicIDs, [msg]); // 3. propagate msg to others\n\n\n        _this4._forwardMessages(msg.topicIDs, [msg]);\n      });\n    }\n  }, {\n    key: \"_emitMessages\",\n    value: function _emitMessages(topics, messages) {\n      var _this5 = this;\n\n      topics.forEach(function (topic) {\n        if (!_this5.subscriptions.has(topic)) {\n          return;\n        }\n\n        messages.forEach(function (message) {\n          _this5.emit(topic, message);\n        });\n      });\n    }\n  }, {\n    key: \"_forwardMessages\",\n    value: function _forwardMessages(topics, messages) {\n      var _this6 = this;\n\n      this.peers.forEach(function (peer) {\n        if (!peer.isWritable || !utils.anyMatch(peer.topics, topics)) {\n          return;\n        }\n\n        peer.sendMessages(utils.normalizeOutRpcMessages(messages));\n\n        _this6.log('publish msgs on topics', topics, peer.info.id.toB58String());\n      });\n    }\n    /**\n     * Unmounts the floodsub protocol and shuts down every connection\n     * @override\n     * @param {Function} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var _this7 = this;\n\n      _get(_getPrototypeOf(FloodSub.prototype), \"stop\", this).call(this, function (err) {\n        if (err) return callback(err);\n        _this7.subscriptions = new Set();\n        callback();\n      });\n    }\n    /**\n     * Publish messages to the given topics.\n     * @override\n     * @param {Array<string>|string} topics\n     * @param {Array<any>|any} messages\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"publish\",\n    value: function publish(topics, messages, callback) {\n      var _this8 = this;\n\n      assert(this.started, 'FloodSub is not started');\n      callback = callback || noop;\n      this.log('publish', topics, messages);\n      topics = ensureArray(topics);\n      messages = ensureArray(messages);\n      var from = this.libp2p.peerInfo.id.toB58String();\n\n      var buildMessage = function buildMessage(msg, cb) {\n        var seqno = utils.randomSeqno();\n\n        _this8.seenCache.put(utils.msgId(from, seqno));\n\n        var message = {\n          from: from,\n          data: msg,\n          seqno: seqno,\n          topicIDs: topics\n        }; // Emit to self if I'm interested\n\n        _this8._emitMessages(topics, [message]);\n\n        _this8._buildMessage(message, cb);\n      };\n\n      asyncMap(messages, buildMessage, function (err, msgObjects) {\n        if (err) return callback(err); // send to all the other peers\n\n        _this8._forwardMessages(topics, msgObjects);\n\n        callback(null);\n      });\n    }\n    /**\n     * Subscribe to the given topic(s).\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(topics) {\n      var _this9 = this;\n\n      assert(this.started, 'FloodSub is not started');\n      topics = ensureArray(topics);\n      topics.forEach(function (topic) {\n        return _this9.subscriptions.add(topic);\n      });\n      this.peers.forEach(function (peer) {\n        return sendSubscriptionsOnceReady(peer);\n      }); // make sure that FloodSub is already mounted\n\n      function sendSubscriptionsOnceReady(peer) {\n        if (peer && peer.isWritable) {\n          return peer.sendSubscriptions(topics);\n        }\n\n        var onConnection = function onConnection() {\n          peer.removeListener('connection', onConnection);\n          sendSubscriptionsOnceReady(peer);\n        };\n\n        peer.on('connection', onConnection);\n        peer.once('close', function () {\n          return peer.removeListener('connection', onConnection);\n        });\n      }\n    }\n    /**\n     * Unsubscribe from the given topic(s).\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(topics) {\n      var _this10 = this;\n\n      // Avoid race conditions, by quietly ignoring unsub when shutdown.\n      if (!this.started) {\n        return;\n      }\n\n      topics = ensureArray(topics);\n      topics.forEach(function (topic) {\n        return _this10.subscriptions.delete(topic);\n      });\n      this.peers.forEach(function (peer) {\n        return checkIfReady(peer);\n      }); // make sure that FloodSub is already mounted\n\n      function checkIfReady(peer) {\n        if (peer && peer.isWritable) {\n          peer.sendUnsubscriptions(topics);\n        } else {\n          setImmediate(checkIfReady.bind(peer));\n        }\n      }\n    }\n  }]);\n\n  return FloodSub;\n}(BaseProtocol);\n\nmodule.exports = FloodSub;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/libp2p-floodsub/src/index.js"],"names":["pull","require","lp","assert","BaseProtocol","message","utils","config","multicodec","ensureArray","setImmediate","asyncMap","noop","FloodSub","libp2p","subscriptions","Set","peerInfo","conn","callback","err","idB58Str","id","toB58String","peer","peers","get","isWritable","sendSubscriptions","decode","map","data","rpc","RPC","drain","_onRpc","_onConnectionEnd","log","subs","msgs","length","_processRpcMessages","normalizeInRpcMessages","updateSubscriptions","emit","info","topics","forEach","msg","seqno","msgId","from","seenCache","has","put","_emitMessages","topicIDs","_forwardMessages","messages","topic","anyMatch","sendMessages","normalizeOutRpcMessages","started","buildMessage","cb","randomSeqno","_buildMessage","msgObjects","add","sendSubscriptionsOnceReady","onConnection","removeListener","on","once","delete","checkIfReady","sendUnsubscriptions","bind","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream')\nconst lp = require('pull-length-prefixed')\nconst assert = require('assert')\n\nconst BaseProtocol = require('libp2p-pubsub')\nconst { message, utils } = require('libp2p-pubsub')\nconst config = require('./config')\n\nconst multicodec = config.multicodec\nconst ensureArray = utils.ensureArray\nconst setImmediate = require('async/setImmediate')\nconst asyncMap = require('async/map')\nconst noop = () => {}\n\n/**\n * FloodSub (aka dumbsub is an implementation of pubsub focused on\n * delivering an API for Publish/Subscribe, but with no CastTree Forming\n * (it just floods the network).\n */\nclass FloodSub extends BaseProtocol {\n  /**\n   * @param {Object} libp2p\n   * @constructor\n   */\n  constructor (libp2p) {\n    super('libp2p:floodsub', multicodec, libp2p)\n\n    /**\n     * List of our subscriptions\n     * @type {Set<string>}\n     */\n    this.subscriptions = new Set()\n  }\n\n  /**\n   * Dial a received peer.\n   * @override\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Connection} conn connection to the peer\n   * @param {function} callback\n   */\n  _onDial (peerInfo, conn, callback) {\n    super._onDial(peerInfo, conn, (err) => {\n      if (err) return callback(err)\n      const idB58Str = peerInfo.id.toB58String()\n      const peer = this.peers.get(idB58Str)\n      if (peer && peer.isWritable) {\n        // Immediately send my own subscriptions to the newly established conn\n        peer.sendSubscriptions(this.subscriptions)\n      }\n      setImmediate(() => callback())\n    })\n  }\n\n  /**\n   * Overriding the implementation of _processConnection should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @override\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {PeerInfo} peer peer info\n   * @returns {undefined}\n   *\n   */\n  _processConnection (idB58Str, conn, peer) {\n    pull(\n      conn,\n      lp.decode(),\n      pull.map((data) => message.rpc.RPC.decode(data)),\n      pull.drain(\n        (rpc) => this._onRpc(idB58Str, rpc),\n        (err) => this._onConnectionEnd(idB58Str, peer, err)\n      )\n    )\n  }\n\n  _onRpc (idB58Str, rpc) {\n    if (!rpc) {\n      return\n    }\n\n    this.log('rpc from', idB58Str)\n    const subs = rpc.subscriptions\n    const msgs = rpc.msgs\n\n    if (msgs && msgs.length) {\n      this._processRpcMessages(utils.normalizeInRpcMessages(rpc.msgs))\n    }\n\n    if (subs && subs.length) {\n      const peer = this.peers.get(idB58Str)\n      if (peer) {\n        peer.updateSubscriptions(subs)\n        this.emit('floodsub:subscription-change', peer.info, peer.topics, subs)\n      }\n    }\n  }\n\n  _processRpcMessages (msgs) {\n    msgs.forEach((msg) => {\n      const seqno = utils.msgId(msg.from, msg.seqno)\n      // 1. check if I've seen the message, if yes, ignore\n      if (this.seenCache.has(seqno)) {\n        return\n      }\n\n      this.seenCache.put(seqno)\n\n      // 2. emit to self\n      this._emitMessages(msg.topicIDs, [msg])\n\n      // 3. propagate msg to others\n      this._forwardMessages(msg.topicIDs, [msg])\n    })\n  }\n\n  _emitMessages (topics, messages) {\n    topics.forEach((topic) => {\n      if (!this.subscriptions.has(topic)) {\n        return\n      }\n\n      messages.forEach((message) => {\n        this.emit(topic, message)\n      })\n    })\n  }\n\n  _forwardMessages (topics, messages) {\n    this.peers.forEach((peer) => {\n      if (!peer.isWritable || !utils.anyMatch(peer.topics, topics)) {\n        return\n      }\n\n      peer.sendMessages(utils.normalizeOutRpcMessages(messages))\n\n      this.log('publish msgs on topics', topics, peer.info.id.toB58String())\n    })\n  }\n\n  /**\n   * Unmounts the floodsub protocol and shuts down every connection\n   * @override\n   * @param {Function} callback\n   * @returns {undefined}\n   *\n   */\n  stop (callback) {\n    super.stop((err) => {\n      if (err) return callback(err)\n      this.subscriptions = new Set()\n      callback()\n    })\n  }\n\n  /**\n   * Publish messages to the given topics.\n   * @override\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   */\n  publish (topics, messages, callback) {\n    assert(this.started, 'FloodSub is not started')\n    callback = callback || noop\n\n    this.log('publish', topics, messages)\n\n    topics = ensureArray(topics)\n    messages = ensureArray(messages)\n\n    const from = this.libp2p.peerInfo.id.toB58String()\n\n    const buildMessage = (msg, cb) => {\n      const seqno = utils.randomSeqno()\n      this.seenCache.put(utils.msgId(from, seqno))\n\n      const message = {\n        from: from,\n        data: msg,\n        seqno: seqno,\n        topicIDs: topics\n      }\n\n      // Emit to self if I'm interested\n      this._emitMessages(topics, [message])\n\n      this._buildMessage(message, cb)\n    }\n\n    asyncMap(messages, buildMessage, (err, msgObjects) => {\n      if (err) return callback(err)\n\n      // send to all the other peers\n      this._forwardMessages(topics, msgObjects)\n\n      callback(null)\n    })\n  }\n\n  /**\n   * Subscribe to the given topic(s).\n   * @override\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n  subscribe (topics) {\n    assert(this.started, 'FloodSub is not started')\n\n    topics = ensureArray(topics)\n\n    topics.forEach((topic) => this.subscriptions.add(topic))\n\n    this.peers.forEach((peer) => sendSubscriptionsOnceReady(peer))\n    // make sure that FloodSub is already mounted\n    function sendSubscriptionsOnceReady (peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendSubscriptions(topics)\n      }\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection)\n        sendSubscriptionsOnceReady(peer)\n      }\n      peer.on('connection', onConnection)\n      peer.once('close', () => peer.removeListener('connection', onConnection))\n    }\n  }\n\n  /**\n   * Unsubscribe from the given topic(s).\n   * @override\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n  unsubscribe (topics) {\n    // Avoid race conditions, by quietly ignoring unsub when shutdown.\n    if (!this.started) {\n      return\n    }\n\n    topics = ensureArray(topics)\n\n    topics.forEach((topic) => this.subscriptions.delete(topic))\n\n    this.peers.forEach((peer) => checkIfReady(peer))\n    // make sure that FloodSub is already mounted\n    function checkIfReady (peer) {\n      if (peer && peer.isWritable) {\n        peer.sendUnsubscriptions(topics)\n      } else {\n        setImmediate(checkIfReady.bind(peer))\n      }\n    }\n  }\n}\n\nmodule.exports = FloodSub\n"]},"metadata":{},"sourceType":"script"}