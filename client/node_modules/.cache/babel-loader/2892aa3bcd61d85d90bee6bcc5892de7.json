{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar FSM = require('fsm-event');\n\nvar multistream = require('multistream-select');\n\nvar withIs = require('class-is');\n\nvar BaseConnection = require('./base');\n\nvar IncomingConnectionFSM = /*#__PURE__*/function (_BaseConnection) {\n  _inherits(IncomingConnectionFSM, _BaseConnection);\n\n  var _super = _createSuper(IncomingConnectionFSM);\n\n  function IncomingConnectionFSM(_ref) {\n    var _this;\n\n    var connection = _ref.connection,\n        _switch = _ref._switch,\n        transportKey = _ref.transportKey,\n        peerInfo = _ref.peerInfo;\n\n    _classCallCheck(this, IncomingConnectionFSM);\n\n    _this = _super.call(this, {\n      _switch: _switch,\n      name: \"inc:\".concat(_switch._peerInfo.id.toB58String().slice(0, 8))\n    });\n    _this.conn = connection;\n    _this.theirPeerInfo = peerInfo || null;\n    _this.theirB58Id = _this.theirPeerInfo ? _this.theirPeerInfo.id.toB58String() : null;\n    _this.ourPeerInfo = _this.switch._peerInfo;\n    _this.transportKey = transportKey;\n    _this.protocolMuxer = _this.switch.protocolMuxer(_this.transportKey);\n    _this.msListener = new multistream.Listener();\n    _this._state = FSM('DIALED', {\n      DISCONNECTED: {\n        disconnect: 'DISCONNECTED'\n      },\n      DIALED: {\n        // Base connection to peer established\n        privatize: 'PRIVATIZING',\n        encrypt: 'ENCRYPTING'\n      },\n      PRIVATIZING: {\n        // Protecting the base connection\n        done: 'PRIVATIZED',\n        disconnect: 'DISCONNECTING'\n      },\n      PRIVATIZED: {\n        // Base connection is protected\n        encrypt: 'ENCRYPTING'\n      },\n      ENCRYPTING: {\n        // Encrypting the base connection\n        done: 'ENCRYPTED',\n        disconnect: 'DISCONNECTING'\n      },\n      ENCRYPTED: {\n        // Upgrading could not happen, the connection is encrypted and waiting\n        upgrade: 'UPGRADING',\n        disconnect: 'DISCONNECTING'\n      },\n      UPGRADING: {\n        // Attempting to upgrade the connection with muxers\n        done: 'MUXED'\n      },\n      MUXED: {\n        disconnect: 'DISCONNECTING'\n      },\n      DISCONNECTING: {\n        // Shutting down the connection\n        done: 'DISCONNECTED'\n      }\n    });\n\n    _this._state.on('DISCONNECTED', function () {\n      return _this._onDisconnected();\n    });\n\n    _this._state.on('PRIVATIZING', function () {\n      return _this._onPrivatizing();\n    });\n\n    _this._state.on('PRIVATIZED', function () {\n      return _this._onPrivatized();\n    });\n\n    _this._state.on('ENCRYPTING', function () {\n      return _this._onEncrypting();\n    });\n\n    _this._state.on('ENCRYPTED', function () {\n      _this.log('successfully encrypted connection to %s', _this.theirB58Id || 'unknown peer');\n\n      _this.emit('encrypted', _this.conn);\n    });\n\n    _this._state.on('UPGRADING', function () {\n      return _this._onUpgrading();\n    });\n\n    _this._state.on('MUXED', function () {\n      _this.log('successfully muxed connection to %s', _this.theirB58Id || 'unknown peer');\n\n      _this.emit('muxed', _this.conn);\n    });\n\n    _this._state.on('DISCONNECTING', function () {\n      _this._state('done');\n    });\n\n    return _this;\n  }\n  /**\n   * Attempts to encrypt `this.conn` with the Switch's crypto.\n   *\n   * @private\n   * @fires IncomingConnectionFSM#error\n   * @returns {void}\n   */\n\n\n  _createClass(IncomingConnectionFSM, [{\n    key: \"_onEncrypting\",\n    value: function _onEncrypting() {\n      var _this2 = this;\n\n      this.log('encrypting connection via %s', this.switch.crypto.tag);\n      this.msListener.addHandler(this.switch.crypto.tag, function (protocol, _conn) {\n        _this2.conn = _this2.switch.crypto.encrypt(_this2.ourPeerInfo.id, _conn, undefined, function (err) {\n          if (err) {\n            return _this2.close(err);\n          }\n\n          _this2.conn.getPeerInfo(function (_, peerInfo) {\n            _this2.theirPeerInfo = peerInfo;\n\n            _this2._state('done');\n          });\n        });\n      }, null); // Start handling the connection\n\n      this.msListener.handle(this.conn, function (err) {\n        if (err) {\n          _this2.emit('crypto handshaking failed', err);\n        }\n      });\n    }\n  }, {\n    key: \"_onUpgrading\",\n    value: function _onUpgrading() {\n      this.log('adding the protocol muxer to the connection');\n      this.protocolMuxer(this.conn, this.msListener);\n\n      this._state('done');\n    }\n  }]);\n\n  return IncomingConnectionFSM;\n}(BaseConnection);\n\nmodule.exports = withIs(IncomingConnectionFSM, {\n  className: 'IncomingConnectionFSM',\n  symbolName: 'libp2p-switch/IncomingConnectionFSM'\n});","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/libp2p-switch/src/connection/incoming.js"],"names":["FSM","require","multistream","withIs","BaseConnection","IncomingConnectionFSM","connection","_switch","transportKey","peerInfo","name","_peerInfo","id","toB58String","slice","conn","theirPeerInfo","theirB58Id","ourPeerInfo","switch","protocolMuxer","msListener","Listener","_state","DISCONNECTED","disconnect","DIALED","privatize","encrypt","PRIVATIZING","done","PRIVATIZED","ENCRYPTING","ENCRYPTED","upgrade","UPGRADING","MUXED","DISCONNECTING","on","_onDisconnected","_onPrivatizing","_onPrivatized","_onEncrypting","log","emit","_onUpgrading","crypto","tag","addHandler","protocol","_conn","undefined","err","close","getPeerInfo","_","handle","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst FSM = require('fsm-event')\nconst multistream = require('multistream-select')\nconst withIs = require('class-is')\n\nconst BaseConnection = require('./base')\n\nclass IncomingConnectionFSM extends BaseConnection {\n  constructor ({ connection, _switch, transportKey, peerInfo }) {\n    super({\n      _switch,\n      name: `inc:${_switch._peerInfo.id.toB58String().slice(0, 8)}`\n    })\n    this.conn = connection\n    this.theirPeerInfo = peerInfo || null\n    this.theirB58Id = this.theirPeerInfo ? this.theirPeerInfo.id.toB58String() : null\n    this.ourPeerInfo = this.switch._peerInfo\n    this.transportKey = transportKey\n    this.protocolMuxer = this.switch.protocolMuxer(this.transportKey)\n    this.msListener = new multistream.Listener()\n\n    this._state = FSM('DIALED', {\n      DISCONNECTED: {\n        disconnect: 'DISCONNECTED'\n      },\n      DIALED: { // Base connection to peer established\n        privatize: 'PRIVATIZING',\n        encrypt: 'ENCRYPTING'\n      },\n      PRIVATIZING: { // Protecting the base connection\n        done: 'PRIVATIZED',\n        disconnect: 'DISCONNECTING'\n      },\n      PRIVATIZED: { // Base connection is protected\n        encrypt: 'ENCRYPTING'\n      },\n      ENCRYPTING: { // Encrypting the base connection\n        done: 'ENCRYPTED',\n        disconnect: 'DISCONNECTING'\n      },\n      ENCRYPTED: { // Upgrading could not happen, the connection is encrypted and waiting\n        upgrade: 'UPGRADING',\n        disconnect: 'DISCONNECTING'\n      },\n      UPGRADING: { // Attempting to upgrade the connection with muxers\n        done: 'MUXED'\n      },\n      MUXED: {\n        disconnect: 'DISCONNECTING'\n      },\n      DISCONNECTING: { // Shutting down the connection\n        done: 'DISCONNECTED'\n      }\n    })\n\n    this._state.on('DISCONNECTED', () => this._onDisconnected())\n    this._state.on('PRIVATIZING', () => this._onPrivatizing())\n    this._state.on('PRIVATIZED', () => this._onPrivatized())\n    this._state.on('ENCRYPTING', () => this._onEncrypting())\n    this._state.on('ENCRYPTED', () => {\n      this.log('successfully encrypted connection to %s', this.theirB58Id || 'unknown peer')\n      this.emit('encrypted', this.conn)\n    })\n    this._state.on('UPGRADING', () => this._onUpgrading())\n    this._state.on('MUXED', () => {\n      this.log('successfully muxed connection to %s', this.theirB58Id || 'unknown peer')\n      this.emit('muxed', this.conn)\n    })\n    this._state.on('DISCONNECTING', () => {\n      this._state('done')\n    })\n  }\n\n  /**\n   * Attempts to encrypt `this.conn` with the Switch's crypto.\n   *\n   * @private\n   * @fires IncomingConnectionFSM#error\n   * @returns {void}\n   */\n  _onEncrypting () {\n    this.log('encrypting connection via %s', this.switch.crypto.tag)\n\n    this.msListener.addHandler(this.switch.crypto.tag, (protocol, _conn) => {\n      this.conn = this.switch.crypto.encrypt(this.ourPeerInfo.id, _conn, undefined, (err) => {\n        if (err) {\n          return this.close(err)\n        }\n        this.conn.getPeerInfo((_, peerInfo) => {\n          this.theirPeerInfo = peerInfo\n          this._state('done')\n        })\n      })\n    }, null)\n\n    // Start handling the connection\n    this.msListener.handle(this.conn, (err) => {\n      if (err) {\n        this.emit('crypto handshaking failed', err)\n      }\n    })\n  }\n\n  _onUpgrading () {\n    this.log('adding the protocol muxer to the connection')\n    this.protocolMuxer(this.conn, this.msListener)\n    this._state('done')\n  }\n}\n\nmodule.exports = withIs(IncomingConnectionFSM, {\n  className: 'IncomingConnectionFSM',\n  symbolName: 'libp2p-switch/IncomingConnectionFSM'\n})\n"]},"metadata":{},"sourceType":"script"}