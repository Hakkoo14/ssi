{"ast":null,"code":"'use strict';\n\nvar Key = require('interface-datastore').Key;\n\nvar debug = require('debug');\n\nvar log = debug('repo:version');\nvar versionKey = new Key('version');\n\nmodule.exports = function (store) {\n  return {\n    /**\n     * Check if a version file exists.\n     *\n     * @param {function(Error, bool)} callback\n     * @returns {void}\n     */\n    exists: function exists(callback) {\n      store.has(versionKey, callback);\n    },\n\n    /**\n     * Get the current version.\n     *\n     * @param {function(Error, number)} callback\n     * @returns {void}\n     */\n    get: function get(callback) {\n      store.get(versionKey, function (err, buf) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, parseInt(buf.toString().trim(), 10));\n      });\n    },\n\n    /**\n     * Set the version of the repo, writing it to the underlying store.\n     *\n     * @param {number} version\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    set: function set(version, callback) {\n      store.put(versionKey, Buffer.from(String(version)), callback);\n    },\n\n    /**\n     * Check the current version, and return an error on missmatch\n     * @param {number} expected\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    check: function check(expected, callback) {\n      this.get(function (err, version) {\n        if (err) {\n          return callback(err);\n        }\n\n        log('comparing version: %s and %s', version, expected); // Version 6 and 7 are the same\n        // TODO: Clean up the compatibility logic. Repo feature detection would be ideal, or a better version schema\n\n        var compatibleVersion = version === 6 && expected === 7 || expected === 6 && version === 7;\n\n        if (version !== expected && !compatibleVersion) {\n          return callback(new Error(\"ipfs repo needs migration: expected version v\".concat(expected, \", found version v\").concat(version)));\n        }\n\n        callback();\n      });\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs-repo/src/version.js"],"names":["Key","require","debug","log","versionKey","module","exports","store","exists","callback","has","get","err","buf","parseInt","toString","trim","set","version","put","Buffer","from","String","check","expected","compatibleVersion","Error"],"mappings":"AAAA;;AAEA,IAAMA,GAAG,GAAGC,OAAO,CAAC,qBAAD,CAAP,CAA+BD,GAA3C;;AACA,IAAME,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,IAAME,GAAG,GAAGD,KAAK,CAAC,cAAD,CAAjB;AAEA,IAAME,UAAU,GAAG,IAAIJ,GAAJ,CAAQ,SAAR,CAAnB;;AAEAK,MAAM,CAACC,OAAP,GAAiB,UAACC,KAAD,EAAW;AAC1B,SAAO;AACL;AACJ;AACA;AACA;AACA;AACA;AACIC,IAAAA,MAPK,kBAOGC,QAPH,EAOa;AAChBF,MAAAA,KAAK,CAACG,GAAN,CAAUN,UAAV,EAAsBK,QAAtB;AACD,KATI;;AAUL;AACJ;AACA;AACA;AACA;AACA;AACIE,IAAAA,GAhBK,eAgBAF,QAhBA,EAgBU;AACbF,MAAAA,KAAK,CAACI,GAAN,CAAUP,UAAV,EAAsB,UAACQ,GAAD,EAAMC,GAAN,EAAc;AAClC,YAAID,GAAJ,EAAS;AACP,iBAAOH,QAAQ,CAACG,GAAD,CAAf;AACD;;AACDH,QAAAA,QAAQ,CAAC,IAAD,EAAOK,QAAQ,CAACD,GAAG,CAACE,QAAJ,GAAeC,IAAf,EAAD,EAAwB,EAAxB,CAAf,CAAR;AACD,OALD;AAMD,KAvBI;;AAwBL;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,IAAAA,GA/BK,eA+BAC,OA/BA,EA+BST,QA/BT,EA+BmB;AACtBF,MAAAA,KAAK,CAACY,GAAN,CAAUf,UAAV,EAAsBgB,MAAM,CAACC,IAAP,CAAYC,MAAM,CAACJ,OAAD,CAAlB,CAAtB,EAAoDT,QAApD;AACD,KAjCI;;AAkCL;AACJ;AACA;AACA;AACA;AACA;AACIc,IAAAA,KAxCK,iBAwCEC,QAxCF,EAwCYf,QAxCZ,EAwCsB;AACzB,WAAKE,GAAL,CAAS,UAACC,GAAD,EAAMM,OAAN,EAAkB;AACzB,YAAIN,GAAJ,EAAS;AACP,iBAAOH,QAAQ,CAACG,GAAD,CAAf;AACD;;AACDT,QAAAA,GAAG,CAAC,8BAAD,EAAiCe,OAAjC,EAA0CM,QAA1C,CAAH,CAJyB,CAMzB;AACA;;AACA,YAAMC,iBAAiB,GAAIP,OAAO,KAAK,CAAZ,IAAiBM,QAAQ,KAAK,CAA/B,IAAsCA,QAAQ,KAAK,CAAb,IAAkBN,OAAO,KAAK,CAA9F;;AAEA,YAAIA,OAAO,KAAKM,QAAZ,IAAwB,CAACC,iBAA7B,EAAgD;AAC9C,iBAAOhB,QAAQ,CAAC,IAAIiB,KAAJ,wDAA0DF,QAA1D,8BAAsFN,OAAtF,EAAD,CAAf;AACD;;AACDT,QAAAA,QAAQ;AACT,OAdD;AAeD;AAxDI,GAAP;AA0DD,CA3DD","sourcesContent":["'use strict'\n\nconst Key = require('interface-datastore').Key\nconst debug = require('debug')\nconst log = debug('repo:version')\n\nconst versionKey = new Key('version')\n\nmodule.exports = (store) => {\n  return {\n    /**\n     * Check if a version file exists.\n     *\n     * @param {function(Error, bool)} callback\n     * @returns {void}\n     */\n    exists (callback) {\n      store.has(versionKey, callback)\n    },\n    /**\n     * Get the current version.\n     *\n     * @param {function(Error, number)} callback\n     * @returns {void}\n     */\n    get (callback) {\n      store.get(versionKey, (err, buf) => {\n        if (err) {\n          return callback(err)\n        }\n        callback(null, parseInt(buf.toString().trim(), 10))\n      })\n    },\n    /**\n     * Set the version of the repo, writing it to the underlying store.\n     *\n     * @param {number} version\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    set (version, callback) {\n      store.put(versionKey, Buffer.from(String(version)), callback)\n    },\n    /**\n     * Check the current version, and return an error on missmatch\n     * @param {number} expected\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    check (expected, callback) {\n      this.get((err, version) => {\n        if (err) {\n          return callback(err)\n        }\n        log('comparing version: %s and %s', version, expected)\n\n        // Version 6 and 7 are the same\n        // TODO: Clean up the compatibility logic. Repo feature detection would be ideal, or a better version schema\n        const compatibleVersion = (version === 6 && expected === 7) || (expected === 6 && version === 7)\n\n        if (version !== expected && !compatibleVersion) {\n          return callback(new Error(`ipfs repo needs migration: expected version v${expected}, found version v${version}`))\n        }\n        callback()\n      })\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}