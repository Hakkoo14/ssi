{"ast":null,"code":"'use strict';\n\nvar pull = require('pull-stream');\n\nvar Source = require('pull-defer/source');\n\nvar path = require('path');\n\nvar os = require('os');\n\nvar uuid = require('uuid/v4');\n\nexports.asyncFilter = function (test) {\n  var busy = false;\n  var abortCb;\n  var aborted;\n  return function (read) {\n    return function next(abort, cb) {\n      if (aborted) return cb(aborted);\n\n      if (abort) {\n        aborted = abort;\n\n        if (!busy) {\n          read(abort, cb);\n        } else {\n          read(abort, function () {\n            // if we are still busy, wait for the test to complete.\n            if (busy) abortCb = cb;else cb(abort);\n          });\n        }\n      } else {\n        read(null, function (end, data) {\n          if (end) cb(end);else if (aborted) cb(aborted);else {\n            busy = true;\n            test(data, function (err, valid) {\n              busy = false;\n\n              if (aborted) {\n                cb(aborted);\n                abortCb(aborted);\n              } else if (err) {\n                next(err, cb);\n              } else if (valid) {\n                cb(null, data);\n              } else {\n                next(null, cb);\n              }\n            });\n          }\n        });\n      }\n    };\n  };\n};\n\nexports.asyncSort = function (sorter) {\n  var source = Source();\n  var sink = pull.collect(function (err, ary) {\n    if (err) {\n      return source.abort(err);\n    }\n\n    sorter(ary, function (err, res) {\n      if (err) {\n        return source.abort(err);\n      }\n\n      source.resolve(pull.values(ary));\n    });\n  });\n  return function (read) {\n    sink(read);\n    return source;\n  };\n};\n\nexports.replaceStartWith = function (s, r) {\n  var matcher = new RegExp('^' + r);\n  return s.replace(matcher, '');\n};\n\nexports.tmpdir = function () {\n  return path.join(os.tmpdir(), uuid());\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/interface-datastore/src/utils.js"],"names":["pull","require","Source","path","os","uuid","exports","asyncFilter","test","busy","abortCb","aborted","read","next","abort","cb","end","data","err","valid","asyncSort","sorter","source","sink","collect","ary","res","resolve","values","replaceStartWith","s","r","matcher","RegExp","replace","tmpdir","join"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream')\nconst Source = require('pull-defer/source')\nconst path = require('path')\nconst os = require('os')\nconst uuid = require('uuid/v4')\n\nexports.asyncFilter = function (test) {\n  let busy = false\n  let abortCb\n  let aborted\n\n  return function (read) {\n    return function next (abort, cb) {\n      if (aborted) return cb(aborted)\n      if (abort) {\n        aborted = abort\n        if (!busy) {\n          read(abort, cb)\n        } else {\n          read(abort, () => {\n            // if we are still busy, wait for the test to complete.\n            if (busy) abortCb = cb; else cb(abort)\n          })\n        }\n      } else {\n        read(null, (end, data) => {\n          if (end) cb(end); else if (aborted) cb(aborted); else {\n            busy = true\n            test(data, (err, valid) => {\n              busy = false\n              if (aborted) {\n                cb(aborted)\n                abortCb(aborted)\n              } else if (err) {\n                next(err, cb)\n              } else if (valid) {\n                cb(null, data)\n              } else {\n                next(null, cb)\n              }\n            })\n          }\n        })\n      }\n    }\n  }\n}\n\nexports.asyncSort = function (sorter) {\n  const source = Source()\n\n  const sink = pull.collect((err, ary) => {\n    if (err) {\n      return source.abort(err)\n    }\n    sorter(ary, (err, res) => {\n      if (err) {\n        return source.abort(err)\n      }\n      source.resolve(pull.values(ary))\n    })\n  })\n\n  return function (read) {\n    sink(read)\n    return source\n  }\n}\n\nexports.replaceStartWith = function (s, r) {\n  const matcher = new RegExp('^' + r)\n  return s.replace(matcher, '')\n}\n\nexports.tmpdir = () => {\n  return path.join(os.tmpdir(), uuid())\n}\n"]},"metadata":{},"sourceType":"script"}