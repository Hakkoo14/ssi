{"ast":null,"code":"/* @flow */\n'use strict';\n/* :: import type {Batch, Query, QueryResult, Callback} from './' */\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pull = require('pull-stream');\n\nvar setImmediate = require('async/setImmediate');\n\nvar asyncFilter = require('./utils').asyncFilter;\n\nvar asyncSort = require('./utils').asyncSort;\n\nvar Key = require('./key'); // Errors\n\n\nvar Errors = require('./errors');\n\nvar MemoryDatastore = /*#__PURE__*/function () {\n  /* :: data: {[key: string]: Buffer} */\n  function MemoryDatastore() {\n    _classCallCheck(this, MemoryDatastore);\n\n    this.data = {};\n  }\n\n  _createClass(MemoryDatastore, [{\n    key: \"open\",\n    value: function open(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      setImmediate(callback);\n    }\n  }, {\n    key: \"put\",\n    value: function put(key\n    /* : Key */\n    , val\n    /* : Buffer */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.data[key.toString()] = val;\n      setImmediate(callback);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key\n    /* : Key */\n    , callback\n    /* : Callback<Buffer> */\n    )\n    /* : void */\n    {\n      var _this = this;\n\n      this.has(key, function (err, exists) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!exists) {\n          return callback(Errors.notFoundError());\n        }\n\n        callback(null, _this.data[key.toString()]);\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(key\n    /* : Key */\n    , callback\n    /* : Callback<bool> */\n    )\n    /* : void */\n    {\n      var _this2 = this;\n\n      setImmediate(function () {\n        callback(null, _this2.data[key.toString()] !== undefined);\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key\n    /* : Key */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      delete this.data[key.toString()];\n      setImmediate(function () {\n        callback();\n      });\n    }\n  }, {\n    key: \"batch\",\n    value: function batch()\n    /* : Batch<Buffer> */\n    {\n      var _this3 = this;\n\n      var puts = [];\n      var dels = [];\n      return {\n        put: function put(key\n        /* : Key */\n        , value\n        /* : Buffer */\n        )\n        /* : void */\n        {\n          puts.push([key, value]);\n        },\n        delete: function _delete(key\n        /* : Key */\n        )\n        /* : void */\n        {\n          dels.push(key);\n        },\n        commit: function commit(callback\n        /* : Callback<void> */\n        )\n        /* : void */\n        {\n          puts.forEach(function (v) {\n            _this3.data[v[0].toString()] = v[1];\n          });\n          puts = [];\n          dels.forEach(function (key) {\n            delete _this3.data[key.toString()];\n          });\n          dels = [];\n          setImmediate(callback);\n        }\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q\n    /* : Query<Buffer> */\n    )\n    /* : QueryResult<Buffer> */\n    {\n      var _this4 = this;\n\n      var tasks = [pull.keys(this.data), pull.map(function (k) {\n        return {\n          key: new Key(k),\n          value: _this4.data[k]\n        };\n      })];\n      var filters = [];\n\n      if (q.prefix != null) {\n        var prefix = q.prefix;\n        filters.push(function (e, cb) {\n          return cb(null, e.key.toString().startsWith(prefix));\n        });\n      }\n\n      if (q.filters != null) {\n        filters = filters.concat(q.filters);\n      }\n\n      tasks = tasks.concat(filters.map(function (f) {\n        return asyncFilter(f);\n      }));\n\n      if (q.orders != null) {\n        tasks = tasks.concat(q.orders.map(function (o) {\n          return asyncSort(o);\n        }));\n      }\n\n      if (q.offset != null) {\n        var i = 0; // $FlowFixMe\n\n        tasks.push(pull.filter(function () {\n          return i++ >= q.offset;\n        }));\n      }\n\n      if (q.limit != null) {\n        tasks.push(pull.take(q.limit));\n      }\n\n      if (q.keysOnly === true) {\n        tasks.push(pull.map(function (e) {\n          return {\n            key: e.key\n          };\n        }));\n      }\n\n      return pull.apply(null, tasks);\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      setImmediate(callback);\n    }\n  }]);\n\n  return MemoryDatastore;\n}();\n\nmodule.exports = MemoryDatastore;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/interface-datastore/src/memory.js"],"names":["pull","require","setImmediate","asyncFilter","asyncSort","Key","Errors","MemoryDatastore","data","callback","key","val","toString","has","err","exists","notFoundError","undefined","puts","dels","put","value","push","delete","commit","forEach","v","q","tasks","keys","map","k","filters","prefix","e","cb","startsWith","concat","f","orders","o","offset","i","filter","limit","take","keysOnly","apply","module","exports"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\n/* :: import type {Batch, Query, QueryResult, Callback} from './' */\n\nconst pull = require('pull-stream')\nconst setImmediate = require('async/setImmediate')\n\nconst asyncFilter = require('./utils').asyncFilter\nconst asyncSort = require('./utils').asyncSort\nconst Key = require('./key')\n\n// Errors\nconst Errors = require('./errors')\n\nclass MemoryDatastore {\n  /* :: data: {[key: string]: Buffer} */\n\n  constructor () {\n    this.data = {}\n  }\n\n  open (callback /* : Callback<void> */) /* : void */ {\n    setImmediate(callback)\n  }\n\n  put (key /* : Key */, val /* : Buffer */, callback /* : Callback<void> */) /* : void */ {\n    this.data[key.toString()] = val\n\n    setImmediate(callback)\n  }\n\n  get (key /* : Key */, callback /* : Callback<Buffer> */) /* : void */ {\n    this.has(key, (err, exists) => {\n      if (err) {\n        return callback(err)\n      }\n\n      if (!exists) {\n        return callback(Errors.notFoundError())\n      }\n\n      callback(null, this.data[key.toString()])\n    })\n  }\n\n  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {\n    setImmediate(() => {\n      callback(null, this.data[key.toString()] !== undefined)\n    })\n  }\n\n  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {\n    delete this.data[key.toString()]\n\n    setImmediate(() => {\n      callback()\n    })\n  }\n\n  batch () /* : Batch<Buffer> */ {\n    let puts = []\n    let dels = []\n\n    return {\n      put (key /* : Key */, value /* : Buffer */) /* : void */ {\n        puts.push([key, value])\n      },\n      delete (key /* : Key */) /* : void */ {\n        dels.push(key)\n      },\n      commit: (callback /* : Callback<void> */) /* : void */ => {\n        puts.forEach(v => {\n          this.data[v[0].toString()] = v[1]\n        })\n\n        puts = []\n        dels.forEach(key => {\n          delete this.data[key.toString()]\n        })\n        dels = []\n\n        setImmediate(callback)\n      }\n    }\n  }\n\n  query (q /* : Query<Buffer> */) /* : QueryResult<Buffer> */ {\n    let tasks = [pull.keys(this.data), pull.map(k => ({\n      key: new Key(k),\n      value: this.data[k]\n    }))]\n\n    let filters = []\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      filters.push((e, cb) => cb(null, e.key.toString().startsWith(prefix)))\n    }\n\n    if (q.filters != null) {\n      filters = filters.concat(q.filters)\n    }\n\n    tasks = tasks.concat(filters.map(f => asyncFilter(f)))\n\n    if (q.orders != null) {\n      tasks = tasks.concat(q.orders.map(o => asyncSort(o)))\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      // $FlowFixMe\n      tasks.push(pull.filter(() => i++ >= q.offset))\n    }\n\n    if (q.limit != null) {\n      tasks.push(pull.take(q.limit))\n    }\n\n    if (q.keysOnly === true) {\n      tasks.push(pull.map(e => ({ key: e.key })))\n    }\n\n    return pull.apply(null, tasks)\n  }\n\n  close (callback /* : Callback<void> */) /* : void */ {\n    setImmediate(callback)\n  }\n}\n\nmodule.exports = MemoryDatastore\n"]},"metadata":{},"sourceType":"script"}