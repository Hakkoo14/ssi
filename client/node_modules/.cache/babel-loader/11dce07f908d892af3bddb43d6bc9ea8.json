{"ast":null,"code":"'use strict';\n\nvar importer = require('ipfs-unixfs-importer');\n\nvar kindOf = require('kind-of');\n\nvar toAsyncIterator = require('pull-stream-to-async-iterator');\n\nvar toPullStream = require('async-iterator-to-pull-stream');\n\nvar pull = require('pull-stream/pull');\n\nvar pullValues = require('pull-stream/sources/values');\n\nvar pullMap = require('pull-stream/throughs/map');\n\nvar pullAsyncMap = require('pull-stream/throughs/async-map');\n\nvar pullFlatten = require('pull-stream/throughs/flatten');\n\nvar toPull = require('stream-to-pull-stream');\n\nvar waterfall = require('async/waterfall');\n\nvar isStream = require('is-stream');\n\nvar _require = require('is-pull-stream'),\n    isSource = _require.isSource;\n\nvar _require2 = require('./utils'),\n    parseChunkerString = _require2.parseChunkerString;\n\nvar streamFromFileReader = require('ipfs-utils/src/streams/stream-from-filereader');\n\nvar _require3 = require('ipfs-utils/src/supports'),\n    supportsFileReader = _require3.supportsFileReader;\n\nfunction noop() {}\n\nfunction prepareFile(file, self, opts, callback) {\n  opts = opts || {};\n  var cid = file.cid;\n  waterfall([function (cb) {\n    return opts.onlyHash ? cb(null, file) : self.object.get(file.cid, Object.assign({}, opts, {\n      preload: false\n    }), cb);\n  }, function (node, cb) {\n    if (opts.cidVersion === 1) {\n      cid = cid.toV1();\n    }\n\n    var b58Hash = cid.toBaseEncodedString();\n    var size = node.size;\n\n    if (Buffer.isBuffer(node)) {\n      size = node.length;\n    }\n\n    cb(null, {\n      path: file.path === undefined ? b58Hash : file.path || '',\n      hash: b58Hash,\n      // multihash: b58Hash,\n      size: size\n    });\n  }], callback);\n}\n\nfunction normalizeContent(content, opts) {\n  if (!Array.isArray(content)) {\n    content = [content];\n  }\n\n  return content.map(function (data) {\n    if (supportsFileReader && kindOf(data) === 'file') {\n      data = {\n        path: '',\n        content: toPull.source(streamFromFileReader(data))\n      };\n    } // Buffer input\n\n\n    if (Buffer.isBuffer(data)) {\n      data = {\n        path: '',\n        content: pullValues([data])\n      };\n    } // Readable stream input\n\n\n    if (isStream.readable(data)) {\n      data = {\n        path: '',\n        content: toPull.source(data)\n      };\n    }\n\n    if (isSource(data)) {\n      data = {\n        path: '',\n        content: data\n      };\n    }\n\n    if (data && data.content && typeof data.content !== 'function') {\n      if (supportsFileReader && kindOf(data.content) === 'file') {\n        data = {\n          path: data.path,\n          content: toPull.source(streamFromFileReader(data.content))\n        };\n      }\n\n      if (Buffer.isBuffer(data.content)) {\n        data = {\n          path: data.path,\n          content: pullValues([data.content])\n        };\n      }\n\n      if (isStream.readable(data.content)) {\n        data = {\n          path: data.path,\n          content: toPull.source(data.content)\n        };\n      }\n    }\n\n    if (opts.wrapWithDirectory && !data.path) {\n      throw new Error('Must provide a path when wrapping with a directory');\n    }\n\n    return data;\n  });\n}\n\nfunction preloadFile(file, self, opts) {\n  var isRootFile = !file.path || opts.wrapWithDirectory ? file.path === '' : !file.path.includes('/');\n  var shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;\n\n  if (shouldPreload) {\n    self._preload(file.hash);\n  }\n\n  return file;\n}\n\nfunction pinFile(file, self, opts, cb) {\n  // Pin a file if it is the root dir of a recursive add or the single file\n  // of a direct add.\n  var pin = 'pin' in opts ? opts.pin : true;\n  var isRootDir = !file.path.includes('/');\n  var shouldPin = pin && isRootDir && !opts.onlyHash && !opts.hashAlg;\n\n  if (shouldPin) {\n    return self.pin.add(file.hash, {\n      preload: false\n    }, function (err) {\n      return cb(err, file);\n    });\n  } else {\n    cb(null, file);\n  }\n}\n\nmodule.exports = function (self) {\n  // Internal add func that gets used by all add funcs\n  return function addPullStream(options) {\n    options = options || {};\n    var chunkerOptions;\n\n    try {\n      chunkerOptions = parseChunkerString(options.chunker);\n    } catch (err) {\n      return pullMap(function () {\n        throw err;\n      });\n    }\n\n    var opts = Object.assign({}, {\n      shardSplitThreshold: self._options.EXPERIMENTAL.sharding ? 1000 : Infinity\n    }, options, {\n      chunker: chunkerOptions.chunker,\n      chunkerOptions: chunkerOptions.chunkerOptions\n    }); // CID v0 is for multihashes encoded with sha2-256\n\n    if (opts.hashAlg && opts.cidVersion !== 1) {\n      opts.cidVersion = 1;\n    }\n\n    var total = 0;\n    var prog = opts.progress || noop;\n\n    var progress = function progress(bytes) {\n      total += bytes;\n      prog(total);\n    };\n\n    opts.progress = progress;\n    return pull(pullMap(function (content) {\n      return normalizeContent(content, opts);\n    }), pullFlatten(), pullMap(function (file) {\n      return {\n        path: file.path ? file.path : undefined,\n        content: file.content ? toAsyncIterator(file.content) : undefined\n      };\n    }), toPullStream.transform(function (source) {\n      return importer(source, self._ipld, opts);\n    }), pullAsyncMap(function (file, cb) {\n      return prepareFile(file, self, opts, cb);\n    }), pullMap(function (file) {\n      return preloadFile(file, self, opts);\n    }), pullAsyncMap(function (file, cb) {\n      return pinFile(file, self, opts, cb);\n    }));\n  };\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs/src/core/components/files-regular/add-pull-stream.js"],"names":["importer","require","kindOf","toAsyncIterator","toPullStream","pull","pullValues","pullMap","pullAsyncMap","pullFlatten","toPull","waterfall","isStream","isSource","parseChunkerString","streamFromFileReader","supportsFileReader","noop","prepareFile","file","self","opts","callback","cid","cb","onlyHash","object","get","Object","assign","preload","node","cidVersion","toV1","b58Hash","toBaseEncodedString","size","Buffer","isBuffer","length","path","undefined","hash","normalizeContent","content","Array","isArray","map","data","source","readable","wrapWithDirectory","Error","preloadFile","isRootFile","includes","shouldPreload","_preload","pinFile","pin","isRootDir","shouldPin","hashAlg","add","err","module","exports","addPullStream","options","chunkerOptions","chunker","shardSplitThreshold","_options","EXPERIMENTAL","sharding","Infinity","total","prog","progress","bytes","transform","_ipld"],"mappings":"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","sourcesContent":["'use strict'\n\nconst importer = require('ipfs-unixfs-importer')\nconst kindOf = require('kind-of')\nconst toAsyncIterator = require('pull-stream-to-async-iterator')\nconst toPullStream = require('async-iterator-to-pull-stream')\nconst pull = require('pull-stream/pull')\nconst pullValues = require('pull-stream/sources/values')\nconst pullMap = require('pull-stream/throughs/map')\nconst pullAsyncMap = require('pull-stream/throughs/async-map')\nconst pullFlatten = require('pull-stream/throughs/flatten')\nconst toPull = require('stream-to-pull-stream')\nconst waterfall = require('async/waterfall')\nconst isStream = require('is-stream')\nconst { isSource } = require('is-pull-stream')\nconst { parseChunkerString } = require('./utils')\nconst streamFromFileReader = require('ipfs-utils/src/streams/stream-from-filereader')\nconst { supportsFileReader } = require('ipfs-utils/src/supports')\n\nfunction noop () {}\n\nfunction prepareFile (file, self, opts, callback) {\n  opts = opts || {}\n\n  let cid = file.cid\n\n  waterfall([\n    (cb) => opts.onlyHash\n      ? cb(null, file)\n      : self.object.get(file.cid, Object.assign({}, opts, { preload: false }), cb),\n    (node, cb) => {\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1()\n      }\n\n      const b58Hash = cid.toBaseEncodedString()\n      let size = node.size\n\n      if (Buffer.isBuffer(node)) {\n        size = node.length\n      }\n\n      cb(null, {\n        path: file.path === undefined ? b58Hash : (file.path || ''),\n        hash: b58Hash,\n        // multihash: b58Hash,\n        size\n      })\n    }\n  ], callback)\n}\n\nfunction normalizeContent (content, opts) {\n  if (!Array.isArray(content)) {\n    content = [content]\n  }\n\n  return content.map((data) => {\n    if (supportsFileReader && kindOf(data) === 'file') {\n      data = { path: '', content: toPull.source(streamFromFileReader(data)) }\n    }\n    // Buffer input\n    if (Buffer.isBuffer(data)) {\n      data = { path: '', content: pullValues([data]) }\n    }\n\n    // Readable stream input\n    if (isStream.readable(data)) {\n      data = { path: '', content: toPull.source(data) }\n    }\n\n    if (isSource(data)) {\n      data = { path: '', content: data }\n    }\n\n    if (data && data.content && typeof data.content !== 'function') {\n      if (supportsFileReader && kindOf(data.content) === 'file') {\n        data = { path: data.path, content: toPull.source(streamFromFileReader(data.content)) }\n      }\n\n      if (Buffer.isBuffer(data.content)) {\n        data = { path: data.path, content: pullValues([data.content]) }\n      }\n\n      if (isStream.readable(data.content)) {\n        data = { path: data.path, content: toPull.source(data.content) }\n      }\n    }\n\n    if (opts.wrapWithDirectory && !data.path) {\n      throw new Error('Must provide a path when wrapping with a directory')\n    }\n\n    return data\n  })\n}\n\nfunction preloadFile (file, self, opts) {\n  const isRootFile = !file.path || opts.wrapWithDirectory\n    ? file.path === ''\n    : !file.path.includes('/')\n\n  const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false\n\n  if (shouldPreload) {\n    self._preload(file.hash)\n  }\n\n  return file\n}\n\nfunction pinFile (file, self, opts, cb) {\n  // Pin a file if it is the root dir of a recursive add or the single file\n  // of a direct add.\n  const pin = 'pin' in opts ? opts.pin : true\n  const isRootDir = !file.path.includes('/')\n  const shouldPin = pin && isRootDir && !opts.onlyHash && !opts.hashAlg\n  if (shouldPin) {\n    return self.pin.add(file.hash, { preload: false }, err => cb(err, file))\n  } else {\n    cb(null, file)\n  }\n}\n\nmodule.exports = function (self) {\n  // Internal add func that gets used by all add funcs\n  return function addPullStream (options) {\n    options = options || {}\n\n    let chunkerOptions\n    try {\n      chunkerOptions = parseChunkerString(options.chunker)\n    } catch (err) {\n      return pullMap(() => { throw err })\n    }\n    const opts = Object.assign({}, {\n      shardSplitThreshold: self._options.EXPERIMENTAL.sharding\n        ? 1000\n        : Infinity\n    }, options, {\n      chunker: chunkerOptions.chunker,\n      chunkerOptions: chunkerOptions.chunkerOptions\n    })\n\n    // CID v0 is for multihashes encoded with sha2-256\n    if (opts.hashAlg && opts.cidVersion !== 1) {\n      opts.cidVersion = 1\n    }\n\n    let total = 0\n\n    const prog = opts.progress || noop\n    const progress = (bytes) => {\n      total += bytes\n      prog(total)\n    }\n\n    opts.progress = progress\n    return pull(\n      pullMap(content => normalizeContent(content, opts)),\n      pullFlatten(),\n      pullMap(file => ({\n        path: file.path ? file.path : undefined,\n        content: file.content ? toAsyncIterator(file.content) : undefined\n      })),\n      toPullStream.transform(source => importer(source, self._ipld, opts)),\n      pullAsyncMap((file, cb) => prepareFile(file, self, opts, cb)),\n      pullMap(file => preloadFile(file, self, opts)),\n      pullAsyncMap((file, cb) => pinFile(file, self, opts, cb))\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}