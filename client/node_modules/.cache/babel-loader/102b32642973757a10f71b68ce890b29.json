{"ast":null,"code":"'use strict';\n\nvar promisify = require('promisify-es6');\n\nvar every = require('async/every');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar CID = require('cids');\n\nvar each = require('async/each');\n\nvar nextTick = require('async/nextTick');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:dht');\nlog.error = debug('ipfs:dht:error');\n\nmodule.exports = function (self) {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    get: promisify(function (key, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = new CID(key).buffer;\n        } catch (err) {\n          log.error(err);\n          return nextTick(function () {\n            return callback(errcode(err, 'ERR_INVALID_CID'));\n          });\n        }\n      }\n\n      self.libp2p.dht.get(key, options, callback);\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    put: promisify(function (key, value, callback) {\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = new CID(key).buffer;\n        } catch (err) {\n          log.error(err);\n          return nextTick(function () {\n            return callback(errcode(err, 'ERR_INVALID_CID'));\n          });\n        }\n      }\n\n      self.libp2p.dht.put(key, value, callback);\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findProvs: promisify(function (key, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key);\n        } catch (err) {\n          log.error(err);\n          return nextTick(function () {\n            return callback(errcode(err, 'ERR_INVALID_CID'));\n          });\n        }\n      }\n\n      self.libp2p.contentRouting.findProviders(key, options, callback);\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peer - The id of the peer to search for.\n     * @param {function(Error, PeerInfo)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findPeer: promisify(function (peer, callback) {\n      if (typeof peer === 'string') {\n        peer = PeerId.createFromB58String(peer);\n      }\n\n      self.libp2p.peerRouting.findPeer(peer, callback);\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|Array<CID>} keys - The keys that should be announced.\n     * @param {Object} options - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    provide: promisify(function (keys, options, callback) {\n      if (!Array.isArray(keys)) {\n        keys = [keys];\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {}; // ensure blocks are actually local\n\n      every(keys, function (key, cb) {\n        self._repo.blocks.has(key, cb);\n      }, function (err, has) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!has) {\n          var errMsg = 'block(s) not found locally, cannot provide';\n          log.error(errMsg);\n          return callback(errcode(errMsg, 'ERR_BLOCK_NOT_FOUND'));\n        }\n\n        if (options.recursive) {\n          // TODO: Implement recursive providing\n          return callback(errcode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET'));\n        } else {\n          each(keys, function (cid, cb) {\n            self.libp2p.contentRouting.provide(cid, cb);\n          }, callback);\n        }\n      });\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {PeerId} peer - The `PeerId` to run the query agains.\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<Array<PeerInfo>>|void}\n     */\n    query: promisify(function (peerId, callback) {\n      if (typeof peerId === 'string') {\n        try {\n          peerId = PeerId.createFromB58String(peerId);\n        } catch (err) {\n          log.error(err);\n          return callback(err);\n        }\n      } // TODO expose this method in peerRouting\n\n\n      self.libp2p._dht.getClosestPeers(peerId.toBytes(), function (err, peerIds) {\n        if (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        callback(null, peerIds.map(function (id) {\n          return new PeerInfo(id);\n        }));\n      });\n    })\n  };\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs/src/core/components/dht.js"],"names":["promisify","require","every","PeerId","PeerInfo","CID","each","nextTick","errcode","debug","log","error","module","exports","self","get","key","options","callback","Buffer","isBuffer","buffer","err","libp2p","dht","put","value","findProvs","contentRouting","findProviders","findPeer","peer","createFromB58String","peerRouting","provide","keys","Array","isArray","cb","_repo","blocks","has","errMsg","recursive","cid","query","peerId","_dht","getClosestPeers","toBytes","peerIds","map","id"],"mappings":"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","sourcesContent":["'use strict'\n\nconst promisify = require('promisify-es6')\nconst every = require('async/every')\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst CID = require('cids')\nconst each = require('async/each')\nconst nextTick = require('async/nextTick')\n\nconst errcode = require('err-code')\n\nconst debug = require('debug')\nconst log = debug('ipfs:dht')\nlog.error = debug('ipfs:dht:error')\n\nmodule.exports = (self) => {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    get: promisify((key, options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      options = options || {}\n\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = (new CID(key)).buffer\n        } catch (err) {\n          log.error(err)\n\n          return nextTick(() => callback(errcode(err, 'ERR_INVALID_CID')))\n        }\n      }\n\n      self.libp2p.dht.get(key, options, callback)\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    put: promisify((key, value, callback) => {\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = (new CID(key)).buffer\n        } catch (err) {\n          log.error(err)\n\n          return nextTick(() => callback(errcode(err, 'ERR_INVALID_CID')))\n        }\n      }\n\n      self.libp2p.dht.put(key, value, callback)\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findProvs: promisify((key, options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      options = options || {}\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key)\n        } catch (err) {\n          log.error(err)\n\n          return nextTick(() => callback(errcode(err, 'ERR_INVALID_CID')))\n        }\n      }\n\n      self.libp2p.contentRouting.findProviders(key, options, callback)\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peer - The id of the peer to search for.\n     * @param {function(Error, PeerInfo)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findPeer: promisify((peer, callback) => {\n      if (typeof peer === 'string') {\n        peer = PeerId.createFromB58String(peer)\n      }\n\n      self.libp2p.peerRouting.findPeer(peer, callback)\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|Array<CID>} keys - The keys that should be announced.\n     * @param {Object} options - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    provide: promisify((keys, options, callback) => {\n      if (!Array.isArray(keys)) {\n        keys = [keys]\n      }\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      options = options || {}\n\n      // ensure blocks are actually local\n      every(keys, (key, cb) => {\n        self._repo.blocks.has(key, cb)\n      }, (err, has) => {\n        if (err) {\n          return callback(err)\n        }\n\n        if (!has) {\n          const errMsg = 'block(s) not found locally, cannot provide'\n\n          log.error(errMsg)\n          return callback(errcode(errMsg, 'ERR_BLOCK_NOT_FOUND'))\n        }\n\n        if (options.recursive) {\n          // TODO: Implement recursive providing\n          return callback(errcode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET'))\n        } else {\n          each(keys, (cid, cb) => {\n            self.libp2p.contentRouting.provide(cid, cb)\n          }, callback)\n        }\n      })\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {PeerId} peer - The `PeerId` to run the query agains.\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<Array<PeerInfo>>|void}\n     */\n    query: promisify((peerId, callback) => {\n      if (typeof peerId === 'string') {\n        try {\n          peerId = PeerId.createFromB58String(peerId)\n        } catch (err) {\n          log.error(err)\n          return callback(err)\n        }\n      }\n\n      // TODO expose this method in peerRouting\n      self.libp2p._dht.getClosestPeers(peerId.toBytes(), (err, peerIds) => {\n        if (err) {\n          log.error(err)\n          return callback(err)\n        }\n\n        callback(null, peerIds.map((id) => new PeerInfo(id)))\n      })\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}