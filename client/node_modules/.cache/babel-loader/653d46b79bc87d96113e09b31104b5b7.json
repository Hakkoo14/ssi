{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('./utils'),\n    encodeBase32 = _require2.encodeBase32,\n    keyToTopic = _require2.keyToTopic,\n    topicToKey = _require2.topicToKey;\n\nvar errcode = require('err-code');\n\nvar assert = require('assert');\n\nvar debug = require('debug');\n\nvar log = debug('datastore-pubsub:publisher');\nlog.error = debug('datastore-pubsub:publisher:error'); // DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nvar DatastorePubsub = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of DatastorePubsub.\n   * @param {*} pubsub - pubsub implementation.\n   * @param {*} datastore - datastore instance.\n   * @param {*} peerId - peer-id instance.\n   * @param {Object} validator - validator functions.\n   * @param {function(record, peerId, callback)} validator.validate - function to validate a record.\n   * @param {function(received, current, callback)} validator.select - function to select the newest between two records.\n   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.\n   * @memberof DatastorePubsub\n   */\n  function DatastorePubsub(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    _classCallCheck(this, DatastorePubsub);\n\n    assert.strictEqual(typeof validator, 'object', 'missing validator');\n    assert.strictEqual(typeof validator.validate, 'function', 'missing validate function');\n    assert.strictEqual(typeof validator.select, 'function', 'missing select function');\n    subscriptionKeyFn && assert.strictEqual(typeof subscriptionKeyFn, 'function', 'invalid subscriptionKeyFn received');\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Publishes a value through pubsub.\n   * @param {Buffer} key identifier of the value to be published.\n   * @param {Buffer} val value to be propagated.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(DatastorePubsub, [{\n    key: \"put\",\n    value: function put(key, val, callback) {\n      if (!Buffer.isBuffer(key)) {\n        var errMsg = \"datastore key does not have a valid format\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'));\n      }\n\n      if (!Buffer.isBuffer(val)) {\n        var _errMsg = \"received value is not a buffer\";\n        log.error(_errMsg);\n        return callback(errcode(new Error(_errMsg), 'ERR_INVALID_VALUE_RECEIVED'));\n      }\n\n      var stringifiedTopic = keyToTopic(key);\n      log(\"publish value for topic \".concat(stringifiedTopic)); // Publish record to pubsub\n\n      this._pubsub.publish(stringifiedTopic, val, callback);\n    }\n    /**\n     * Try to subscribe a topic with Pubsub and returns the local value if available.\n     * @param {Buffer} key identifier of the value to be subscribed.\n     * @param {function(Error, Buffer)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, callback) {\n      var _this = this;\n\n      if (!Buffer.isBuffer(key)) {\n        var errMsg = \"datastore key does not have a valid format\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'));\n      }\n\n      var stringifiedTopic = keyToTopic(key);\n\n      this._pubsub.ls(function (err, res) {\n        if (err) {\n          return callback(err);\n        } // If already subscribed, just try to get it\n\n\n        if (res && Array.isArray(res) && res.indexOf(stringifiedTopic) > -1) {\n          return _this._getLocal(key, callback);\n        } // Subscribe\n\n\n        _this._pubsub.subscribe(stringifiedTopic, _this._onMessage, function (err) {\n          if (err) {\n            var _errMsg2 = \"cannot subscribe topic \".concat(stringifiedTopic);\n\n            log.error(_errMsg2);\n            return callback(errcode(new Error(_errMsg2), 'ERR_SUBSCRIBING_TOPIC'));\n          }\n\n          log(\"subscribed values for key \".concat(stringifiedTopic));\n\n          _this._getLocal(key, callback);\n        });\n      });\n    }\n    /**\n     * Unsubscribe topic.\n     * @param {Buffer} key identifier of the value to unsubscribe.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(key) {\n      var stringifiedTopic = keyToTopic(key);\n\n      this._pubsub.unsubscribe(stringifiedTopic, this._onMessage);\n    } // Get record from local datastore\n\n  }, {\n    key: \"_getLocal\",\n    value: function _getLocal(key, callback) {\n      // encode key - base32(/ipns/{cid})\n      var routingKey = new Key('/' + encodeBase32(key), false);\n\n      this._datastore.get(routingKey, function (err, dsVal) {\n        if (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            var _errMsg3 = \"unexpected error getting the ipns record for \".concat(routingKey.toString());\n\n            log.error(_errMsg3);\n            return callback(errcode(new Error(_errMsg3), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD'));\n          }\n\n          var errMsg = \"local record requested was not found for \".concat(routingKey.toString());\n          log.error(errMsg);\n          return callback(errcode(new Error(errMsg), 'ERR_NOT_FOUND'));\n        }\n\n        if (!Buffer.isBuffer(dsVal)) {\n          var _errMsg4 = \"found record that we couldn't convert to a value\";\n          log.error(_errMsg4);\n          return callback(errcode(new Error(_errMsg4), 'ERR_INVALID_RECORD_RECEIVED'));\n        }\n\n        callback(null, dsVal);\n      });\n    } // handles pubsub subscription messages\n\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(msg) {\n      var _this2 = this;\n\n      var data = msg.data,\n          from = msg.from,\n          topicIDs = msg.topicIDs;\n      var key;\n\n      try {\n        key = topicToKey(topicIDs[0]);\n      } catch (err) {\n        log.error(err);\n        return;\n      }\n\n      log(\"message received for \".concat(key, \" topic\")); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n      if (from === this._peerId.toB58String()) {\n        log(\"message discarded as it is from the same peer\");\n        return;\n      }\n\n      if (this._handleSubscriptionKeyFn) {\n        this._handleSubscriptionKeyFn(key, function (err, res) {\n          if (err) {\n            log.error('message discarded by the subscriptionKeyFn');\n            return;\n          }\n\n          _this2._storeIfSubscriptionIsBetter(res, data);\n        });\n      } else {\n        this._storeIfSubscriptionIsBetter(key, data);\n      }\n    } // Store the received record if it is better than the current stored\n\n  }, {\n    key: \"_storeIfSubscriptionIsBetter\",\n    value: function _storeIfSubscriptionIsBetter(key, data) {\n      var _this3 = this;\n\n      this._isBetter(key, data, function (err, res) {\n        if (!err && res) {\n          _this3._storeRecord(Buffer.from(key), data);\n        }\n      });\n    } // Validate record according to the received validation function\n\n  }, {\n    key: \"_validateRecord\",\n    value: function _validateRecord(value, peerId, callback) {\n      this._validator.validate(value, peerId, callback);\n    } // Select the best record according to the received select function.\n\n  }, {\n    key: \"_selectRecord\",\n    value: function _selectRecord(receivedRecord, currentRecord, callback) {\n      this._validator.select(receivedRecord, currentRecord, function (err, res) {\n        if (err) {\n          log.error(err);\n          return callback(err);\n        } // If the selected was the first (0), it should be stored (true)\n\n\n        callback(null, res === 0);\n      });\n    } // Verify if the record received through pubsub is valid and better than the one currently stored\n\n  }, {\n    key: \"_isBetter\",\n    value: function _isBetter(key, val, callback) {\n      var _this4 = this;\n\n      // validate received record\n      this._validateRecord(val, key, function (err, valid) {\n        // If not valid, it is not better than the one currently available\n        if (err || !valid) {\n          var errMsg = 'record received through pubsub is not valid';\n          log.error(errMsg);\n          return callback(errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD'));\n        } // Get Local record\n\n\n        var dsKey = new Key(key);\n\n        _this4._getLocal(dsKey.toBuffer(), function (err, currentRecord) {\n          // if the old one is invalid, the new one is *always* better\n          if (err) {\n            return callback(null, true);\n          } // if the same record, do not need to store\n\n\n          if (currentRecord.equals(val)) {\n            return callback(null, false);\n          } // verify if the received record should replace the current one\n\n\n          _this4._selectRecord(val, currentRecord, callback);\n        });\n      });\n    } // add record to datastore\n\n  }, {\n    key: \"_storeRecord\",\n    value: function _storeRecord(key, data) {\n      // encode key - base32(/ipns/{cid})\n      var routingKey = new Key('/' + encodeBase32(key), false);\n\n      this._datastore.put(routingKey, data, function (err) {\n        if (err) {\n          log.error(\"record for \".concat(key.toString(), \" could not be stored in the routing\"));\n          return;\n        }\n\n        log(\"record for \".concat(key.toString(), \" was stored in the datastore\"));\n      });\n    }\n  }, {\n    key: \"open\",\n    value: function open(callback) {\n      var errMsg = \"open function was not implemented yet\";\n      log.error(errMsg);\n      return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'));\n    }\n  }, {\n    key: \"has\",\n    value: function has(key, callback) {\n      var errMsg = \"has function was not implemented yet\";\n      log.error(errMsg);\n      return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'));\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key, callback) {\n      var errMsg = \"delete function was not implemented yet\";\n      log.error(errMsg);\n      return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'));\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      var errMsg = \"close function was not implemented yet\";\n      log.error(errMsg);\n      return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'));\n    }\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      var errMsg = \"batch function was not implemented yet\";\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n    }\n  }, {\n    key: \"query\",\n    value: function query() {\n      var errMsg = \"query function was not implemented yet\";\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n    }\n  }]);\n\n  return DatastorePubsub;\n}();\n\nexports = module.exports = DatastorePubsub;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/datastore-pubsub/src/index.js"],"names":["require","Key","encodeBase32","keyToTopic","topicToKey","errcode","assert","debug","log","error","DatastorePubsub","pubsub","datastore","peerId","validator","subscriptionKeyFn","strictEqual","validate","select","_pubsub","_datastore","_peerId","_validator","_handleSubscriptionKeyFn","_onMessage","bind","key","val","callback","Buffer","isBuffer","errMsg","Error","stringifiedTopic","publish","ls","err","res","Array","isArray","indexOf","_getLocal","subscribe","unsubscribe","routingKey","get","dsVal","code","toString","msg","data","from","topicIDs","toB58String","_storeIfSubscriptionIsBetter","_isBetter","_storeRecord","value","receivedRecord","currentRecord","_validateRecord","valid","dsKey","toBuffer","equals","_selectRecord","put","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Key } = require('interface-datastore')\nconst { encodeBase32, keyToTopic, topicToKey } = require('./utils')\n\nconst errcode = require('err-code')\nconst assert = require('assert')\nconst debug = require('debug')\nconst log = debug('datastore-pubsub:publisher')\nlog.error = debug('datastore-pubsub:publisher:error')\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nclass DatastorePubsub {\n  /**\n   * Creates an instance of DatastorePubsub.\n   * @param {*} pubsub - pubsub implementation.\n   * @param {*} datastore - datastore instance.\n   * @param {*} peerId - peer-id instance.\n   * @param {Object} validator - validator functions.\n   * @param {function(record, peerId, callback)} validator.validate - function to validate a record.\n   * @param {function(received, current, callback)} validator.select - function to select the newest between two records.\n   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.\n   * @memberof DatastorePubsub\n   */\n  constructor (pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    assert.strictEqual(typeof validator, 'object', 'missing validator')\n    assert.strictEqual(typeof validator.validate, 'function', 'missing validate function')\n    assert.strictEqual(typeof validator.select, 'function', 'missing select function')\n    subscriptionKeyFn && assert.strictEqual(typeof subscriptionKeyFn, 'function', 'invalid subscriptionKeyFn received')\n\n    this._pubsub = pubsub\n    this._datastore = datastore\n    this._peerId = peerId\n    this._validator = validator\n    this._handleSubscriptionKeyFn = subscriptionKeyFn\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this)\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   * @param {Buffer} key identifier of the value to be published.\n   * @param {Buffer} val value to be propagated.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  put (key, val, callback) {\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = `datastore key does not have a valid format`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'))\n    }\n\n    if (!Buffer.isBuffer(val)) {\n      const errMsg = `received value is not a buffer`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED'))\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    log(`publish value for topic ${stringifiedTopic}`)\n\n    // Publish record to pubsub\n    this._pubsub.publish(stringifiedTopic, val, callback)\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   * @param {Buffer} key identifier of the value to be subscribed.\n   * @param {function(Error, Buffer)} callback\n   * @returns {void}\n   */\n  get (key, callback) {\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = `datastore key does not have a valid format`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'))\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    this._pubsub.ls((err, res) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // If already subscribed, just try to get it\n      if (res && Array.isArray(res) && res.indexOf(stringifiedTopic) > -1) {\n        return this._getLocal(key, callback)\n      }\n\n      // Subscribe\n      this._pubsub.subscribe(stringifiedTopic, this._onMessage, (err) => {\n        if (err) {\n          const errMsg = `cannot subscribe topic ${stringifiedTopic}`\n\n          log.error(errMsg)\n          return callback(errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC'))\n        }\n        log(`subscribed values for key ${stringifiedTopic}`)\n\n        this._getLocal(key, callback)\n      })\n    })\n  }\n\n  /**\n   * Unsubscribe topic.\n   * @param {Buffer} key identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe (key) {\n    const stringifiedTopic = keyToTopic(key)\n\n    this._pubsub.unsubscribe(stringifiedTopic, this._onMessage)\n  }\n\n  // Get record from local datastore\n  _getLocal (key, callback) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    this._datastore.get(routingKey, (err, dsVal) => {\n      if (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`\n\n          log.error(errMsg)\n          return callback(errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD'))\n        }\n        const errMsg = `local record requested was not found for ${routingKey.toString()}`\n\n        log.error(errMsg)\n        return callback(errcode(new Error(errMsg), 'ERR_NOT_FOUND'))\n      }\n\n      if (!Buffer.isBuffer(dsVal)) {\n        const errMsg = `found record that we couldn't convert to a value`\n\n        log.error(errMsg)\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED'))\n      }\n\n      callback(null, dsVal)\n    })\n  }\n\n  // handles pubsub subscription messages\n  _onMessage (msg) {\n    const { data, from, topicIDs } = msg\n    let key\n    try {\n      key = topicToKey(topicIDs[0])\n    } catch (err) {\n      log.error(err)\n      return\n    }\n\n    log(`message received for ${key} topic`)\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (from === this._peerId.toB58String()) {\n      log(`message discarded as it is from the same peer`)\n      return\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      this._handleSubscriptionKeyFn(key, (err, res) => {\n        if (err) {\n          log.error('message discarded by the subscriptionKeyFn')\n          return\n        }\n\n        this._storeIfSubscriptionIsBetter(res, data)\n      })\n    } else {\n      this._storeIfSubscriptionIsBetter(key, data)\n    }\n  }\n\n  // Store the received record if it is better than the current stored\n  _storeIfSubscriptionIsBetter (key, data) {\n    this._isBetter(key, data, (err, res) => {\n      if (!err && res) {\n        this._storeRecord(Buffer.from(key), data)\n      }\n    })\n  }\n\n  // Validate record according to the received validation function\n  _validateRecord (value, peerId, callback) {\n    this._validator.validate(value, peerId, callback)\n  }\n\n  // Select the best record according to the received select function.\n  _selectRecord (receivedRecord, currentRecord, callback) {\n    this._validator.select(receivedRecord, currentRecord, (err, res) => {\n      if (err) {\n        log.error(err)\n        return callback(err)\n      }\n\n      // If the selected was the first (0), it should be stored (true)\n      callback(null, res === 0)\n    })\n  }\n\n  // Verify if the record received through pubsub is valid and better than the one currently stored\n  _isBetter (key, val, callback) {\n    // validate received record\n    this._validateRecord(val, key, (err, valid) => {\n      // If not valid, it is not better than the one currently available\n      if (err || !valid) {\n        const errMsg = 'record received through pubsub is not valid'\n\n        log.error(errMsg)\n        return callback(errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD'))\n      }\n\n      // Get Local record\n      const dsKey = new Key(key)\n\n      this._getLocal(dsKey.toBuffer(), (err, currentRecord) => {\n        // if the old one is invalid, the new one is *always* better\n        if (err) {\n          return callback(null, true)\n        }\n\n        // if the same record, do not need to store\n        if (currentRecord.equals(val)) {\n          return callback(null, false)\n        }\n\n        // verify if the received record should replace the current one\n        this._selectRecord(val, currentRecord, callback)\n      })\n    })\n  }\n\n  // add record to datastore\n  _storeRecord (key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    this._datastore.put(routingKey, data, (err) => {\n      if (err) {\n        log.error(`record for ${key.toString()} could not be stored in the routing`)\n        return\n      }\n\n      log(`record for ${key.toString()} was stored in the datastore`)\n    })\n  }\n\n  open (callback) {\n    const errMsg = `open function was not implemented yet`\n\n    log.error(errMsg)\n    return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'))\n  }\n\n  has (key, callback) {\n    const errMsg = `has function was not implemented yet`\n\n    log.error(errMsg)\n    return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'))\n  }\n\n  delete (key, callback) {\n    const errMsg = `delete function was not implemented yet`\n\n    log.error(errMsg)\n    return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'))\n  }\n\n  close (callback) {\n    const errMsg = `close function was not implemented yet`\n\n    log.error(errMsg)\n    return callback(errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET'))\n  }\n\n  batch () {\n    const errMsg = `batch function was not implemented yet`\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  query () {\n    const errMsg = `query function was not implemented yet`\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n}\n\nexports = module.exports = DatastorePubsub\n"]},"metadata":{},"sourceType":"script"}