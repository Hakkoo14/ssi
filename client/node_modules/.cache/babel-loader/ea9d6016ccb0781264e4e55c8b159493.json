{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar pull = require('pull-stream');\n\nvar pushable = require('pull-pushable');\n\nvar through = require('pull-through');\n\nvar looper = require('looper');\n\nvar nextTick = require('async/nextTick');\n\nvar EE = require('events');\n\nvar debug = require('debug');\n\nvar _require = require('./util'),\n    emitError = _require.emitError,\n    emitStream = _require.emitStream;\n\nvar _require2 = require('./consts'),\n    Types = _require2.Types,\n    MAX_MSG_SIZE = _require2.MAX_MSG_SIZE;\n\nvar Channel = require('./channel');\n\nvar coder = require('./coder');\n\nvar log = debug('pull-plex');\nlog.err = debug('pull-plex:err');\n/**\n * @typedef {Object} Message\n * @property {number} id\n * @property {MessageType} type\n * @property {Buffer} data\n */\n\n/**\n * @fires Mplex#close Emitted when Mplex closes\n * @fires Mplex#error Emitted when an error occurs\n * @fires Mplex#stream Emitted when a new stream is opened\n */\n\nvar Mplex = /*#__PURE__*/function (_EE) {\n  _inherits(Mplex, _EE);\n\n  var _super = _createSuper(Mplex);\n\n  /**\n   * @constructor\n   * @param {Object} opts\n   * @param {boolean} opts.initiator Is this starting the stream. Default: `true`\n   * @param {function(Channel, number)} opts.onChan A handler for new streams. Can be used instead of `.on('stream')`\n   * @param {number} opts.maxChannels Maximum number of channels to have open. Default: `10000`\n   * @param {number} opts.maxMsgSize Maximum size messages are allowed to be. Default: `1 << 20` (1MB)\n   * @param {boolean} opts.lazy Should channels be opened lazily? If false, channels will be opened when they are created. Default: `false`\n   */\n  function Mplex(opts) {\n    var _this;\n\n    _classCallCheck(this, Mplex);\n\n    _this = _super.call(this);\n\n    if (typeof opts === 'boolean') {\n      opts = {\n        initiator: opts\n      };\n    }\n\n    opts = _objectSpread({\n      initiator: true,\n      onChan: null,\n      maxChannels: 10000,\n      maxMsgSize: MAX_MSG_SIZE,\n      lazy: false\n    }, opts);\n    _this._maxChannels = opts.maxChannels;\n    _this._maxMsgSize = opts.maxMsgSize;\n    _this._lazy = opts.lazy;\n    _this._initiator = Boolean(opts.initiator);\n    _this._chanId = 0;\n    _this._inChannels = new Array(_this._maxChannels / 2);\n    _this._outChannels = new Array(_this._maxChannels / 2);\n    _this._endedRemote = false; // remote stream ended\n\n    _this._endedLocal = false; // local stream ended\n\n    _this._chandata = pushable(function (err) {\n      _this._log('mplex ended');\n\n      _this._endedRemote = true;\n\n      _this.close(err);\n    });\n\n    if (opts.onChan) {\n      _this.on('stream', function (chan) {\n        return opts.onChan(chan, chan.id);\n      });\n    }\n\n    _this.source = pull(_this._chandata, coder.encode());\n\n    var self = _assertThisInitialized(_this);\n\n    _this.sink = pull(through(function (data) {\n      // ensure data is within our max size requirement\n      if (data && data.length >= self._maxMsgSize) {\n        nextTick(emitError, self, new Error('message too large!'));\n        return this.queue(null);\n      }\n\n      this.queue(data);\n    }), coder.decode(), function (read) {\n      var next = looper(function () {\n        read(null, function (end, data) {\n          if (self._endedLocal) {\n            return;\n          }\n\n          if (end === true) {\n            return self.close();\n          }\n\n          if (end) {\n            return self.destroy(end);\n          }\n\n          self._handle(data);\n\n          next();\n        });\n      });\n      next();\n    });\n    return _this;\n  }\n  /**\n   * A convenience wrapper for the log that adds useful metadata to logs\n   * @private\n   * @param {string} name The name of the operation being logged\n   * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`\n   */\n\n\n  _createClass(Mplex, [{\n    key: \"_log\",\n    value: function _log(name, data) {\n      log({\n        op: name,\n        initiator: this._initiator,\n        endedLocal: this._endedLocal,\n        endedRemote: this._endedRemote,\n        data: data && data.toString() || ''\n      });\n    }\n  }, {\n    key: \"initiator\",\n    get: function get() {\n      return this._initiator;\n    }\n    /**\n     * Closes all open channels\n     * @param {Error} err Optional error\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(err) {\n      this._log('close', err);\n\n      if (this.destroyed) {\n        return;\n      }\n\n      if (err) {\n        nextTick(emitError, this, err);\n      }\n\n      err = err || 'Underlying stream has been closed';\n      this._endedLocal = true; // propagate close to channels\n\n      var chans = Array.prototype.concat(this._outChannels, this._inChannels);\n\n      var _iterator = _createForOfIteratorHelper(chans),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var chan = _step.value;\n\n          if (chan) {\n            chan.close(err);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.emit('close');\n    }\n  }, {\n    key: \"destroyed\",\n    get: function get() {\n      return this._endedRemote && this._endedLocal;\n    }\n    /**\n     * Destroys the parent stream and closes Mplex\n     * @param {Error} err\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(err) {\n      err = err || new Error('Underlying stream has been closed');\n\n      this._chandata.end(err);\n\n      this.close(err);\n    }\n    /**\n     * Pushes data to the stream\n     * @param {Buffer} data\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      if (data.data && Buffer.byteLength(data.data) > this._maxMsgSize) {\n        this._chandata.end(new Error('message too large!'));\n      }\n\n      this._chandata.push(data);\n    }\n    /**\n     * Creates a new Channel (stream). If Mplex was created with `opts.lazy` set to true,\n     * the channel will not automatically be opened.\n     *\n     * @param {string} name The name of the channel/stream to create\n     * @returns {Channel}\n     */\n\n  }, {\n    key: \"createStream\",\n    value: function createStream(name) {\n      if (typeof name === 'number') {\n        name = name.toString();\n      }\n\n      var chan = this._newStream(null, true, false, name, this._outChannels);\n\n      if (!this._lazy) {\n        chan.openChan(name);\n      }\n\n      return chan;\n    }\n    /**\n     * Attempts to create a channel if it doesn't already exist.\n     * If a channel already exists for `id`, `Mplex#error` will be emitted.\n     *\n     * @private\n     * @param {number} id The id of the channel. If `null` it will be auto incremented from `Mplex._chanId`\n     * @param {boolean} initiator Is the channel creating the connection\n     * @param {boolean} open Should the channel be opened when created\n     * @param {string} name The name of the channel\n     * @param {Array} list The channel list to add the channel to\n     * @returns {Channel}\n     */\n\n  }, {\n    key: \"_newStream\",\n    value: function _newStream(id, initiator, open, name, list) {\n      if (this.chanSize >= this._maxChannels) {\n        this.emit('error', new Error('max channels exceeded'));\n        return;\n      }\n\n      if (typeof initiator === 'string') {\n        name = initiator;\n        initiator = false;\n        open = false;\n      }\n\n      if (typeof open === 'string') {\n        name = open;\n        open = false;\n      }\n\n      id = typeof id === 'number' ? id : this._chanId++;\n\n      if (list[id]) {\n        this.emit('error', new Error(\"channel with id \".concat(id, \" already exist!\")));\n        return;\n      }\n\n      var chan = new Channel({\n        id: id,\n        name: name,\n        plex: this,\n        initiator: initiator,\n        open: open || false\n      });\n      return this._addChan(id, chan, list);\n    }\n    /**\n     * A convenience method for setting the `chan` up to be tracked.\n     * @private\n     * @param {number} id The id of the channel\n     * @param {Channel} chan The channel to track\n     * @param {Array} list The channel list to add the channel to\n     * @returns {Channel} `chan`\n     */\n\n  }, {\n    key: \"_addChan\",\n    value: function _addChan(id, chan, list) {\n      chan.once('close', function () {\n        list[id] = null;\n      });\n      chan.once('error', function (err) {\n        log.err('channel error', err);\n      });\n      list[id] = chan;\n      return chan;\n    }\n  }, {\n    key: \"chanSize\",\n    get: function get() {\n      return this._inChannels.size + this._outChannels.size;\n    }\n    /**\n     * Takes the appropriate course of action based on `msg.type`.\n     * If `msg.type` is not recognized `Mplex#error` will be emitted.\n     * @param {Message} msg\n     */\n\n  }, {\n    key: \"_handle\",\n    value: function _handle(msg) {\n      this._log('_handle', msg);\n\n      var id = msg.id,\n          type = msg.type,\n          data = msg.data;\n\n      switch (type) {\n        // Create a new stream\n        case Types.NEW:\n          {\n            var chan = this._newStream(id, false, true, data.toString(), this._inChannels);\n\n            nextTick(emitStream, this, chan, id);\n            break;\n          }\n        // Push the data into the channel with the matching id if it exists\n\n        case Types.OUT_MESSAGE:\n        case Types.IN_MESSAGE:\n          {\n            var list = type & 1 ? this._outChannels : this._inChannels;\n            var _chan = list[id];\n\n            if (_chan) {\n              _chan.push(data);\n            }\n\n            break;\n          }\n        // Close the channel with the matching id\n\n        case Types.OUT_CLOSE:\n        case Types.IN_CLOSE:\n          {\n            var _list = type & 1 ? this._outChannels : this._inChannels;\n\n            var _chan2 = _list[id];\n\n            if (_chan2) {\n              _chan2.close();\n            }\n\n            break;\n          }\n        // Destroys the channel with the matching id\n\n        case Types.OUT_RESET:\n        case Types.IN_RESET:\n          {\n            var _list2 = type & 1 ? this._outChannels : this._inChannels;\n\n            var _chan3 = _list2[id];\n\n            if (_chan3) {\n              _chan3.destroy();\n            }\n\n            break;\n          }\n\n        default:\n          nextTick(emitError, this, new Error('Invalid message type'));\n      }\n    }\n  }]);\n\n  return Mplex;\n}(EE);\n\nmodule.exports = Mplex;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/pull-mplex/src/mplex.js"],"names":["pull","require","pushable","through","looper","nextTick","EE","debug","emitError","emitStream","Types","MAX_MSG_SIZE","Channel","coder","log","err","Mplex","opts","initiator","onChan","maxChannels","maxMsgSize","lazy","_maxChannels","_maxMsgSize","_lazy","_initiator","Boolean","_chanId","_inChannels","Array","_outChannels","_endedRemote","_endedLocal","_chandata","_log","close","on","chan","id","source","encode","self","sink","data","length","Error","queue","decode","read","next","end","destroy","_handle","name","op","endedLocal","endedRemote","toString","destroyed","chans","prototype","concat","emit","Buffer","byteLength","push","_newStream","openChan","open","list","chanSize","plex","_addChan","once","size","msg","type","NEW","OUT_MESSAGE","IN_MESSAGE","OUT_CLOSE","IN_CLOSE","OUT_RESET","IN_RESET","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream')\nconst pushable = require('pull-pushable')\nconst through = require('pull-through')\nconst looper = require('looper')\nconst nextTick = require('async/nextTick')\nconst EE = require('events')\nconst debug = require('debug')\n\nconst { emitError, emitStream } = require('./util')\nconst { Types, MAX_MSG_SIZE } = require('./consts')\nconst Channel = require('./channel')\nconst coder = require('./coder')\n\nconst log = debug('pull-plex')\nlog.err = debug('pull-plex:err')\n\n/**\n * @typedef {Object} Message\n * @property {number} id\n * @property {MessageType} type\n * @property {Buffer} data\n */\n\n/**\n * @fires Mplex#close Emitted when Mplex closes\n * @fires Mplex#error Emitted when an error occurs\n * @fires Mplex#stream Emitted when a new stream is opened\n */\nclass Mplex extends EE {\n  /**\n   * @constructor\n   * @param {Object} opts\n   * @param {boolean} opts.initiator Is this starting the stream. Default: `true`\n   * @param {function(Channel, number)} opts.onChan A handler for new streams. Can be used instead of `.on('stream')`\n   * @param {number} opts.maxChannels Maximum number of channels to have open. Default: `10000`\n   * @param {number} opts.maxMsgSize Maximum size messages are allowed to be. Default: `1 << 20` (1MB)\n   * @param {boolean} opts.lazy Should channels be opened lazily? If false, channels will be opened when they are created. Default: `false`\n   */\n  constructor (opts) {\n    super()\n\n    if (typeof opts === 'boolean') {\n      opts = { initiator: opts }\n    }\n\n    opts = {\n      initiator: true,\n      onChan: null,\n      maxChannels: 10000,\n      maxMsgSize: MAX_MSG_SIZE,\n      lazy: false,\n      ...opts\n    }\n\n    this._maxChannels = opts.maxChannels\n    this._maxMsgSize = opts.maxMsgSize\n    this._lazy = opts.lazy\n\n    this._initiator = Boolean(opts.initiator)\n    this._chanId = 0\n    this._inChannels = new Array(this._maxChannels / 2)\n    this._outChannels = new Array(this._maxChannels / 2)\n    this._endedRemote = false // remote stream ended\n    this._endedLocal = false // local stream ended\n\n    this._chandata = pushable((err) => {\n      this._log('mplex ended')\n      this._endedRemote = true\n      this.close(err)\n    })\n\n    if (opts.onChan) {\n      this.on('stream', (chan) => opts.onChan(chan, chan.id))\n    }\n\n    this.source = pull(\n      this._chandata,\n      coder.encode()\n    )\n\n    const self = this\n    this.sink = pull(\n      through(function (data) {\n        // ensure data is within our max size requirement\n        if (data && data.length >= self._maxMsgSize) {\n          nextTick(emitError, self, new Error('message too large!'))\n          return this.queue(null)\n        }\n        this.queue(data)\n      }),\n      coder.decode(),\n      (read) => {\n        const next = looper(() => {\n          read(null, (end, data) => {\n            if (self._endedLocal) { return }\n            if (end === true) { return self.close() }\n            if (end) { return self.destroy(end) }\n            self._handle(data)\n            next()\n          })\n        })\n        next()\n      })\n  }\n\n  /**\n   * A convenience wrapper for the log that adds useful metadata to logs\n   * @private\n   * @param {string} name The name of the operation being logged\n   * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`\n   */\n  _log (name, data) {\n    log({\n      op: name,\n      initiator: this._initiator,\n      endedLocal: this._endedLocal,\n      endedRemote: this._endedRemote,\n      data: (data && data.toString()) || ''\n    })\n  }\n\n  get initiator () {\n    return this._initiator\n  }\n\n  /**\n   * Closes all open channels\n   * @param {Error} err Optional error\n   */\n  close (err) {\n    this._log('close', err)\n\n    if (this.destroyed) { return }\n\n    if (err) {\n      nextTick(emitError, this, err)\n    }\n\n    err = err || 'Underlying stream has been closed'\n    this._endedLocal = true\n\n    // propagate close to channels\n    const chans = Array.prototype.concat(this._outChannels, this._inChannels)\n    for (let chan of chans) {\n      if (chan) {\n        chan.close(err)\n      }\n    }\n\n    this.emit('close')\n  }\n\n  get destroyed () {\n    return this._endedRemote && this._endedLocal\n  }\n\n  /**\n   * Destroys the parent stream and closes Mplex\n   * @param {Error} err\n   */\n  destroy (err) {\n    err = err || new Error('Underlying stream has been closed')\n    this._chandata.end(err)\n    this.close(err)\n  }\n\n  /**\n   * Pushes data to the stream\n   * @param {Buffer} data\n   */\n  push (data) {\n    if (data.data &&\n      Buffer.byteLength(data.data) > this._maxMsgSize) {\n      this._chandata.end(new Error('message too large!'))\n    }\n\n    this._chandata.push(data)\n  }\n\n  /**\n   * Creates a new Channel (stream). If Mplex was created with `opts.lazy` set to true,\n   * the channel will not automatically be opened.\n   *\n   * @param {string} name The name of the channel/stream to create\n   * @returns {Channel}\n   */\n  createStream (name) {\n    if (typeof name === 'number') { name = name.toString() }\n    const chan = this._newStream(null, true, false, name, this._outChannels)\n    if (!this._lazy) { chan.openChan(name) }\n    return chan\n  }\n\n  /**\n   * Attempts to create a channel if it doesn't already exist.\n   * If a channel already exists for `id`, `Mplex#error` will be emitted.\n   *\n   * @private\n   * @param {number} id The id of the channel. If `null` it will be auto incremented from `Mplex._chanId`\n   * @param {boolean} initiator Is the channel creating the connection\n   * @param {boolean} open Should the channel be opened when created\n   * @param {string} name The name of the channel\n   * @param {Array} list The channel list to add the channel to\n   * @returns {Channel}\n   */\n  _newStream (id, initiator, open, name, list) {\n    if (this.chanSize >= this._maxChannels) {\n      this.emit('error', new Error('max channels exceeded'))\n      return\n    }\n\n    if (typeof initiator === 'string') {\n      name = initiator\n      initiator = false\n      open = false\n    }\n\n    if (typeof open === 'string') {\n      name = open\n      open = false\n    }\n\n    id = typeof id === 'number' ? id : this._chanId++\n    if (list[id]) {\n      this.emit('error', new Error(`channel with id ${id} already exist!`))\n      return\n    }\n    const chan = new Channel({\n      id,\n      name,\n      plex: this,\n      initiator,\n      open: open || false\n    })\n\n    return this._addChan(id, chan, list)\n  }\n\n  /**\n   * A convenience method for setting the `chan` up to be tracked.\n   * @private\n   * @param {number} id The id of the channel\n   * @param {Channel} chan The channel to track\n   * @param {Array} list The channel list to add the channel to\n   * @returns {Channel} `chan`\n   */\n  _addChan (id, chan, list) {\n    chan.once('close', () => {\n      list[id] = null\n    })\n    chan.once('error', (err) => {\n      log.err('channel error', err)\n    })\n\n    list[id] = chan\n    return chan\n  }\n\n  get chanSize () {\n    return this._inChannels.size + this._outChannels.size\n  }\n\n  /**\n   * Takes the appropriate course of action based on `msg.type`.\n   * If `msg.type` is not recognized `Mplex#error` will be emitted.\n   * @param {Message} msg\n   */\n  _handle (msg) {\n    this._log('_handle', msg)\n    const { id, type, data } = msg\n    switch (type) {\n      // Create a new stream\n      case Types.NEW: {\n        const chan = this._newStream(id, false, true, data.toString(), this._inChannels)\n        nextTick(emitStream, this, chan, id)\n        break\n      }\n\n      // Push the data into the channel with the matching id if it exists\n      case Types.OUT_MESSAGE:\n      case Types.IN_MESSAGE: {\n        const list = type & 1 ? this._outChannels : this._inChannels\n        const chan = list[id]\n        if (chan) {\n          chan.push(data)\n        }\n        break\n      }\n\n      // Close the channel with the matching id\n      case Types.OUT_CLOSE:\n      case Types.IN_CLOSE: {\n        const list = type & 1 ? this._outChannels : this._inChannels\n        const chan = list[id]\n        if (chan) {\n          chan.close()\n        }\n        break\n      }\n\n      // Destroys the channel with the matching id\n      case Types.OUT_RESET:\n      case Types.IN_RESET: {\n        const list = type & 1 ? this._outChannels : this._inChannels\n        const chan = list[id]\n        if (chan) {\n          chan.destroy()\n        }\n        break\n      }\n\n      default:\n        nextTick(emitError, this, new Error('Invalid message type'))\n    }\n  }\n}\n\nmodule.exports = Mplex\n"]},"metadata":{},"sourceType":"script"}