{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar varint = require('varint');\n\nvar pull = require('pull-stream/pull');\n\nvar map = require('pull-stream/throughs/map');\n\nvar collect = require('pull-stream/sinks/collect');\n\nvar take = require('pull-stream/throughs/take');\n\nvar pullLP = require('pull-length-prefixed');\n\nvar Connection = require('interface-connection').Connection;\n\nvar util = require('../util');\n\nvar _select = require('../select');\n\nvar once = require('once');\n\nvar PROTOCOL_ID = require('./../constants').PROTOCOL_ID;\n/**\n *\n */\n\n\nvar Dialer = /*#__PURE__*/function () {\n  /**\n   * Create a new Dialer.\n   */\n  function Dialer() {\n    _classCallCheck(this, Dialer);\n\n    this.conn = null;\n    this.log = util.log.dialer();\n  }\n  /**\n   * Perform the multistream handshake.\n   *\n   * @param {Connection} rawConn - The connection on which\n   * to perform the handshake.\n   * @param {function(Error)} callback - Called when the handshake completed.\n   * @returns {undefined}\n   */\n\n\n  _createClass(Dialer, [{\n    key: \"handle\",\n    value: function handle(rawConn, callback) {\n      var _this = this;\n\n      this.log('dialer handle conn');\n      callback = once(callback);\n\n      var s = _select(PROTOCOL_ID, function (err, conn) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this.log('handshake success');\n\n        _this.conn = new Connection(conn, rawConn);\n        callback();\n      }, this.log); // Handle unexpected errors from pull, like 'already piped'\n\n\n      try {\n        pull(rawConn, s, rawConn);\n      } catch (err) {\n        this.log.error(err);\n        callback(err);\n      }\n    }\n    /**\n     * Select a protocol\n     *\n     * @param {string} protocol - A string of the protocol that we want to handshake.\n     * @param {function(Error, Connection)} callback - `err` is\n     * an error object that gets passed if something wrong happ\n     * end (e.g: if the protocol selected is not supported by\n     * the other end) and conn is the connection handshaked\n     * with the other end.\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"select\",\n    value: function select(protocol, callback) {\n      var _this2 = this;\n\n      this.log('dialer select ' + protocol);\n      callback = once(callback);\n\n      if (!this.conn) {\n        return callback(new Error('multistream handshake has not finalized yet'));\n      }\n\n      var s = _select(protocol, function (err, conn) {\n        if (err) {\n          _this2.conn = new Connection(conn, _this2.conn);\n          return callback(err);\n        }\n\n        callback(null, new Connection(conn, _this2.conn));\n      }, this.log);\n\n      pull(this.conn, s, this.conn);\n    }\n    /**\n     * List all available protocols.\n     *\n     * @param {function(Error, Array<string>)} callback - If\n     * something wrong happend `Error` exists, otherwise\n     * `protocols` is a list of the supported\n     * protocols on the other end.\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"ls\",\n    value: function ls(callback) {\n      callback = once(callback);\n\n      var lsStream = _select('ls', function (err, conn) {\n        if (err) {\n          return callback(err);\n        }\n\n        pull(conn, pullLP.decode(), collectLs(conn), map(stringify), collect(function (err, list) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, list.slice(1));\n        }));\n      }, this.log);\n\n      pull(this.conn, lsStream, this.conn);\n    }\n  }]);\n\n  return Dialer;\n}();\n\nfunction stringify(buf) {\n  return buf.toString().slice(0, -1);\n}\n\nfunction collectLs(conn) {\n  var first = true;\n  var counter = 0;\n  return take(function (msg) {\n    if (first) {\n      varint.decode(msg);\n      counter = varint.decode(msg, varint.decode.bytes);\n      return true;\n    }\n\n    return counter-- > 0;\n  });\n}\n\nmodule.exports = Dialer;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/multistream-select/src/dialer/index.js"],"names":["varint","require","pull","map","collect","take","pullLP","Connection","util","select","once","PROTOCOL_ID","Dialer","conn","log","dialer","rawConn","callback","s","err","error","protocol","Error","lsStream","decode","collectLs","stringify","list","slice","buf","toString","first","counter","msg","bytes","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst varint = require('varint')\nconst pull = require('pull-stream/pull')\nconst map = require('pull-stream/throughs/map')\nconst collect = require('pull-stream/sinks/collect')\nconst take = require('pull-stream/throughs/take')\nconst pullLP = require('pull-length-prefixed')\nconst Connection = require('interface-connection').Connection\nconst util = require('../util')\nconst select = require('../select')\nconst once = require('once')\n\nconst PROTOCOL_ID = require('./../constants').PROTOCOL_ID\n\n/**\n *\n */\nclass Dialer {\n  /**\n   * Create a new Dialer.\n   */\n  constructor () {\n    this.conn = null\n    this.log = util.log.dialer()\n  }\n\n  /**\n   * Perform the multistream handshake.\n   *\n   * @param {Connection} rawConn - The connection on which\n   * to perform the handshake.\n   * @param {function(Error)} callback - Called when the handshake completed.\n   * @returns {undefined}\n   */\n  handle (rawConn, callback) {\n    this.log('dialer handle conn')\n    callback = once(callback)\n    const s = select(PROTOCOL_ID, (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n      this.log('handshake success')\n\n      this.conn = new Connection(conn, rawConn)\n\n      callback()\n    }, this.log)\n\n    // Handle unexpected errors from pull, like 'already piped'\n    try {\n      pull(\n        rawConn,\n        s,\n        rawConn\n      )\n    } catch (err) {\n      this.log.error(err)\n      callback(err)\n    }\n  }\n\n  /**\n   * Select a protocol\n   *\n   * @param {string} protocol - A string of the protocol that we want to handshake.\n   * @param {function(Error, Connection)} callback - `err` is\n   * an error object that gets passed if something wrong happ\n   * end (e.g: if the protocol selected is not supported by\n   * the other end) and conn is the connection handshaked\n   * with the other end.\n   *\n   * @returns {undefined}\n   */\n  select (protocol, callback) {\n    this.log('dialer select ' + protocol)\n    callback = once(callback)\n    if (!this.conn) {\n      return callback(new Error('multistream handshake has not finalized yet'))\n    }\n\n    const s = select(protocol, (err, conn) => {\n      if (err) {\n        this.conn = new Connection(conn, this.conn)\n        return callback(err)\n      }\n      callback(null, new Connection(conn, this.conn))\n    }, this.log)\n\n    pull(\n      this.conn,\n      s,\n      this.conn\n    )\n  }\n\n  /**\n   * List all available protocols.\n   *\n   * @param {function(Error, Array<string>)} callback - If\n   * something wrong happend `Error` exists, otherwise\n   * `protocols` is a list of the supported\n   * protocols on the other end.\n   *\n   * @returns {undefined}\n   */\n  ls (callback) {\n    callback = once(callback)\n\n    const lsStream = select('ls', (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n\n      pull(\n        conn,\n        pullLP.decode(),\n        collectLs(conn),\n        map(stringify),\n        collect((err, list) => {\n          if (err) {\n            return callback(err)\n          }\n          callback(null, list.slice(1))\n        })\n      )\n    }, this.log)\n\n    pull(\n      this.conn,\n      lsStream,\n      this.conn\n    )\n  }\n}\n\nfunction stringify (buf) {\n  return buf.toString().slice(0, -1)\n}\n\nfunction collectLs (conn) {\n  let first = true\n  let counter = 0\n\n  return take((msg) => {\n    if (first) {\n      varint.decode(msg)\n      counter = varint.decode(msg, varint.decode.bytes)\n      return true\n    }\n\n    return counter-- > 0\n  })\n}\n\nmodule.exports = Dialer\n"]},"metadata":{},"sourceType":"script"}