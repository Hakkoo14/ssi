{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PeerId = require('peer-id');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar series = require('async/series');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:publisher');\nlog.error = debug('ipfs:ipns:publisher:error');\n\nvar ipns = require('ipns');\n\nvar defaultRecordTtl = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nvar IpnsPublisher = /*#__PURE__*/function () {\n  function IpnsPublisher(routing, datastore) {\n    _classCallCheck(this, IpnsPublisher);\n\n    this._routing = routing;\n    this._datastore = datastore;\n  } // publish record with a eol\n\n\n  _createClass(IpnsPublisher, [{\n    key: \"publishWithEOL\",\n    value: function publishWithEOL(privKey, value, lifetime, callback) {\n      var _this = this;\n\n      if (!privKey || !privKey.bytes) {\n        var errMsg = \"one or more of the provided parameters are not defined\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'));\n      }\n\n      PeerId.createFromPrivKey(privKey.bytes, function (err, peerId) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this._updateOrCreateRecord(privKey, value, lifetime, peerId, function (err, record) {\n          if (err) {\n            return callback(err);\n          }\n\n          _this._putRecordToRouting(record, peerId, callback);\n        });\n      });\n    } // Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n\n  }, {\n    key: \"publish\",\n    value: function publish(privKey, value, callback) {\n      this.publishWithEOL(privKey, value, defaultRecordTtl, callback);\n    }\n  }, {\n    key: \"_putRecordToRouting\",\n    value: function _putRecordToRouting(record, peerId, callback) {\n      var _this2 = this;\n\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      var publicKey = peerId._pubKey;\n      ipns.embedPublicKey(publicKey, record, function (err, embedPublicKeyRecord) {\n        if (err) {\n          return callback(err);\n        }\n\n        var keys;\n\n        try {\n          keys = ipns.getIdKeys(peerId.toBytes());\n        } catch (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        series([function (cb) {\n          return _this2._publishEntry(keys.routingKey, embedPublicKeyRecord || record, peerId, cb);\n        }, // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n        // We will be able to deprecate this part in the future, since the public keys will be only\n        // in IPNS record and the peerId.\n        function (cb) {\n          return _this2._publishPublicKey(keys.routingPubKey, publicKey, peerId, cb);\n        }], function (err) {\n          if (err) {\n            log.error(err);\n            return callback(err);\n          }\n\n          callback(null, embedPublicKeyRecord || record);\n        });\n      });\n    }\n  }, {\n    key: \"_publishEntry\",\n    value: function _publishEntry(key, entry, peerId, callback) {\n      if (!Key.isKey(key)) {\n        var errMsg = \"datastore key does not have a valid format\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'));\n      }\n\n      var entryData;\n\n      try {\n        // Marshal record\n        entryData = ipns.marshal(entry);\n      } catch (err) {\n        log.error(err);\n        return callback(err);\n      } // Add record to routing (buffer key)\n\n\n      this._routing.put(key.toBuffer(), entryData, function (err, res) {\n        if (err) {\n          var _errMsg = \"ipns record for \".concat(key.toString(), \" could not be stored in the routing\");\n\n          log.error(_errMsg);\n          return callback(errcode(new Error(_errMsg), 'ERR_PUTTING_TO_ROUTING'));\n        }\n\n        log(\"ipns record for \".concat(key.toString(), \" was stored in the routing\"));\n        callback(null, res);\n      });\n    }\n  }, {\n    key: \"_publishPublicKey\",\n    value: function _publishPublicKey(key, publicKey, peerId, callback) {\n      if (!Key.isKey(key)) {\n        var errMsg = \"datastore key does not have a valid format\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'));\n      }\n\n      if (!publicKey || !publicKey.bytes) {\n        var _errMsg2 = \"one or more of the provided parameters are not defined\";\n        log.error(_errMsg2);\n        return callback(errcode(new Error(_errMsg2), 'ERR_UNDEFINED_PARAMETER'));\n      } // Add public key to routing (buffer key)\n\n\n      this._routing.put(key.toBuffer(), publicKey.bytes, function (err, res) {\n        if (err) {\n          var _errMsg3 = \"public key for \".concat(key.toString(), \" could not be stored in the routing\");\n\n          log.error(_errMsg3);\n          return callback(errcode(new Error(_errMsg3), 'ERR_PUTTING_TO_ROUTING'));\n        }\n\n        log(\"public key for \".concat(key.toString(), \" was stored in the routing\"));\n        callback(null, res);\n      });\n    } // Returns the record this node has published corresponding to the given peer ID.\n    // If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n\n  }, {\n    key: \"_getPublished\",\n    value: function _getPublished(peerId, options, callback) {\n      var _this3 = this;\n\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      options = options || {};\n      var checkRouting = options.checkRouting !== false;\n\n      this._datastore.get(ipns.getLocalKey(peerId.id), function (err, dsVal) {\n        if (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            var _errMsg4 = \"unexpected error getting the ipns record \".concat(peerId.id, \" from datastore\");\n\n            log.error(_errMsg4);\n            return callback(errcode(new Error(_errMsg4), 'ERR_UNEXPECTED_DATASTORE_RESPONSE'));\n          }\n\n          if (!checkRouting) {\n            return callback(errcode(err));\n          } // Try to get from routing\n\n\n          var keys;\n\n          try {\n            keys = ipns.getIdKeys(peerId.toBytes());\n          } catch (err) {\n            log.error(err);\n            return callback(err);\n          }\n\n          _this3._routing.get(keys.routingKey.toBuffer(), function (err, res) {\n            if (err) {\n              return callback(err);\n            } // unmarshal data\n\n\n            _this3._unmarshalData(res, callback);\n          });\n        } else {\n          // unmarshal data\n          _this3._unmarshalData(dsVal, callback);\n        }\n      });\n    }\n  }, {\n    key: \"_unmarshalData\",\n    value: function _unmarshalData(data, callback) {\n      var result;\n\n      try {\n        result = ipns.unmarshal(data);\n      } catch (err) {\n        log.error(err);\n        return callback(errcode(err, 'ERR_INVALID_RECORD_DATA'));\n      }\n\n      callback(null, result);\n    }\n  }, {\n    key: \"_updateOrCreateRecord\",\n    value: function _updateOrCreateRecord(privKey, value, validity, peerId, callback) {\n      var _this4 = this;\n\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      var getPublishedOptions = {\n        checkRouting: true\n      };\n\n      this._getPublished(peerId, getPublishedOptions, function (err, record) {\n        if (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            var _errMsg5 = \"unexpected error when determining the last published IPNS record for \".concat(peerId.id);\n\n            log.error(_errMsg5);\n            return callback(errcode(new Error(_errMsg5), 'ERR_DETERMINING_PUBLISHED_RECORD'));\n          }\n        } // Determinate the record sequence number\n\n\n        var seqNumber = 0;\n\n        if (record && record.sequence !== undefined) {\n          seqNumber = record.value.toString() !== value ? record.sequence + 1 : record.sequence;\n        } // Create record\n\n\n        ipns.create(privKey, value, seqNumber, validity, function (err, entryData) {\n          if (err) {\n            var _errMsg6 = \"ipns record for \".concat(value, \" could not be created\");\n\n            log.error(_errMsg6);\n            return callback(errcode(new Error(_errMsg6), 'ERR_CREATING_IPNS_RECORD'));\n          } // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n          // Marshal record\n\n\n          var data = ipns.marshal(entryData); // Store the new record\n\n          _this4._datastore.put(ipns.getLocalKey(peerId.id), data, function (err, res) {\n            if (err) {\n              var _errMsg7 = \"ipns record for \".concat(value, \" could not be stored in the datastore\");\n\n              log.error(_errMsg7);\n              return callback(errcode(new Error(_errMsg7), 'ERR_STORING_IN_DATASTORE'));\n            }\n\n            log(\"ipns record for \".concat(value, \" was stored in the datastore\"));\n            callback(null, entryData);\n          });\n        });\n      });\n    }\n  }]);\n\n  return IpnsPublisher;\n}();\n\nexports = module.exports = IpnsPublisher;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs/src/core/ipns/publisher.js"],"names":["PeerId","require","Key","series","errcode","debug","log","error","ipns","defaultRecordTtl","IpnsPublisher","routing","datastore","_routing","_datastore","privKey","value","lifetime","callback","bytes","errMsg","Error","createFromPrivKey","err","peerId","_updateOrCreateRecord","record","_putRecordToRouting","publishWithEOL","isPeerId","publicKey","_pubKey","embedPublicKey","embedPublicKeyRecord","keys","getIdKeys","toBytes","cb","_publishEntry","routingKey","_publishPublicKey","routingPubKey","key","entry","isKey","entryData","marshal","put","toBuffer","res","toString","options","checkRouting","get","getLocalKey","id","dsVal","code","_unmarshalData","data","result","unmarshal","validity","getPublishedOptions","_getPublished","seqNumber","sequence","undefined","create","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Key } = require('interface-datastore')\nconst series = require('async/series')\nconst errcode = require('err-code')\n\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:publisher')\nlog.error = debug('ipfs:ipns:publisher:error')\n\nconst ipns = require('ipns')\n\nconst defaultRecordTtl = 60 * 60 * 1000\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nclass IpnsPublisher {\n  constructor (routing, datastore) {\n    this._routing = routing\n    this._datastore = datastore\n  }\n\n  // publish record with a eol\n  publishWithEOL (privKey, value, lifetime, callback) {\n    if (!privKey || !privKey.bytes) {\n      const errMsg = `one or more of the provided parameters are not defined`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'))\n    }\n\n    PeerId.createFromPrivKey(privKey.bytes, (err, peerId) => {\n      if (err) {\n        return callback(err)\n      }\n\n      this._updateOrCreateRecord(privKey, value, lifetime, peerId, (err, record) => {\n        if (err) {\n          return callback(err)\n        }\n\n        this._putRecordToRouting(record, peerId, callback)\n      })\n    })\n  }\n\n  // Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n  publish (privKey, value, callback) {\n    this.publishWithEOL(privKey, value, defaultRecordTtl, callback)\n  }\n\n  _putRecordToRouting (record, peerId, callback) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = `peerId received is not valid`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'))\n    }\n    const publicKey = peerId._pubKey\n\n    ipns.embedPublicKey(publicKey, record, (err, embedPublicKeyRecord) => {\n      if (err) {\n        return callback(err)\n      }\n\n      let keys\n      try {\n        keys = ipns.getIdKeys(peerId.toBytes())\n      } catch (err) {\n        log.error(err)\n        return callback(err)\n      }\n\n      series([\n        (cb) => this._publishEntry(keys.routingKey, embedPublicKeyRecord || record, peerId, cb),\n        // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n        // We will be able to deprecate this part in the future, since the public keys will be only\n        // in IPNS record and the peerId.\n        (cb) => this._publishPublicKey(keys.routingPubKey, publicKey, peerId, cb)\n      ], (err) => {\n        if (err) {\n          log.error(err)\n          return callback(err)\n        }\n\n        callback(null, embedPublicKeyRecord || record)\n      })\n    })\n  }\n\n  _publishEntry (key, entry, peerId, callback) {\n    if (!(Key.isKey(key))) {\n      const errMsg = `datastore key does not have a valid format`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'))\n    }\n\n    let entryData\n    try {\n      // Marshal record\n      entryData = ipns.marshal(entry)\n    } catch (err) {\n      log.error(err)\n      return callback(err)\n    }\n\n    // Add record to routing (buffer key)\n    this._routing.put(key.toBuffer(), entryData, (err, res) => {\n      if (err) {\n        const errMsg = `ipns record for ${key.toString()} could not be stored in the routing`\n\n        log.error(errMsg)\n        return callback(errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING'))\n      }\n\n      log(`ipns record for ${key.toString()} was stored in the routing`)\n      callback(null, res)\n    })\n  }\n\n  _publishPublicKey (key, publicKey, peerId, callback) {\n    if ((!Key.isKey(key))) {\n      const errMsg = `datastore key does not have a valid format`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'))\n    }\n\n    if (!publicKey || !publicKey.bytes) {\n      const errMsg = `one or more of the provided parameters are not defined`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'))\n    }\n\n    // Add public key to routing (buffer key)\n    this._routing.put(key.toBuffer(), publicKey.bytes, (err, res) => {\n      if (err) {\n        const errMsg = `public key for ${key.toString()} could not be stored in the routing`\n\n        log.error(errMsg)\n        return callback(errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING'))\n      }\n\n      log(`public key for ${key.toString()} was stored in the routing`)\n      callback(null, res)\n    })\n  }\n\n  // Returns the record this node has published corresponding to the given peer ID.\n  // If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n  _getPublished (peerId, options, callback) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = `peerId received is not valid`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'))\n    }\n\n    options = options || {}\n    const checkRouting = options.checkRouting !== false\n\n    this._datastore.get(ipns.getLocalKey(peerId.id), (err, dsVal) => {\n      if (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`\n\n          log.error(errMsg)\n          return callback(errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE'))\n        }\n\n        if (!checkRouting) {\n          return callback((errcode(err)))\n        }\n\n        // Try to get from routing\n        let keys\n        try {\n          keys = ipns.getIdKeys(peerId.toBytes())\n        } catch (err) {\n          log.error(err)\n          return callback(err)\n        }\n\n        this._routing.get(keys.routingKey.toBuffer(), (err, res) => {\n          if (err) {\n            return callback(err)\n          }\n\n          // unmarshal data\n          this._unmarshalData(res, callback)\n        })\n      } else {\n        // unmarshal data\n        this._unmarshalData(dsVal, callback)\n      }\n    })\n  }\n\n  _unmarshalData (data, callback) {\n    let result\n    try {\n      result = ipns.unmarshal(data)\n    } catch (err) {\n      log.error(err)\n      return callback(errcode(err, 'ERR_INVALID_RECORD_DATA'))\n    }\n\n    callback(null, result)\n  }\n\n  _updateOrCreateRecord (privKey, value, validity, peerId, callback) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = `peerId received is not valid`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'))\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    }\n\n    this._getPublished(peerId, getPublishedOptions, (err, record) => {\n      if (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id}`\n\n          log.error(errMsg)\n          return callback(errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD'))\n        }\n      }\n\n      // Determinate the record sequence number\n      let seqNumber = 0\n      if (record && record.sequence !== undefined) {\n        seqNumber = record.value.toString() !== value ? record.sequence + 1 : record.sequence\n      }\n\n      // Create record\n      ipns.create(privKey, value, seqNumber, validity, (err, entryData) => {\n        if (err) {\n          const errMsg = `ipns record for ${value} could not be created`\n\n          log.error(errMsg)\n          return callback(errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD'))\n        }\n\n        // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n        // Marshal record\n        const data = ipns.marshal(entryData)\n\n        // Store the new record\n        this._datastore.put(ipns.getLocalKey(peerId.id), data, (err, res) => {\n          if (err) {\n            const errMsg = `ipns record for ${value} could not be stored in the datastore`\n\n            log.error(errMsg)\n            return callback(errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE'))\n          }\n\n          log(`ipns record for ${value} was stored in the datastore`)\n          callback(null, entryData)\n        })\n      })\n    })\n  }\n}\n\nexports = module.exports = IpnsPublisher\n"]},"metadata":{},"sourceType":"script"}