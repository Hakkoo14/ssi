{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('libp2p-record'),\n    Record = _require2.Record;\n\nvar _require3 = require('./utils'),\n    encodeBase32 = _require3.encodeBase32;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:offline-datastore');\nlog.error = debug('ipfs:ipns:offline-datastore:error'); // Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\n\nvar OfflineDatastore = /*#__PURE__*/function () {\n  function OfflineDatastore(repo) {\n    _classCallCheck(this, OfflineDatastore);\n\n    this._repo = repo;\n  }\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(OfflineDatastore, [{\n    key: \"put\",\n    value: function put(key, value, callback) {\n      if (!Buffer.isBuffer(key)) {\n        var errMsg = \"Offline datastore key must be a buffer\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'));\n      }\n\n      if (!Buffer.isBuffer(value)) {\n        var _errMsg = \"Offline datastore value must be a buffer\";\n        log.error(_errMsg);\n        return callback(errcode(new Error(_errMsg), 'ERR_INVALID_VALUE'));\n      }\n\n      var routingKey;\n\n      try {\n        routingKey = this._routingKey(key);\n      } catch (err) {\n        var _errMsg2 = \"Not possible to generate the routing key\";\n        log.error(_errMsg2);\n        return callback(errcode(new Error(_errMsg2), 'ERR_GENERATING_ROUTING_KEY'));\n      } // Marshal to libp2p record as the DHT does\n\n\n      var record = new Record(key, value);\n\n      this._repo.datastore.put(routingKey, record.serialize(), callback);\n    }\n    /**\n     * Get a value from the local datastore indexed by the received key properly encoded.\n     * @param {Buffer} key identifier of the value to be obtained.\n     * @param {function(Error, Buffer)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, callback) {\n      if (!Buffer.isBuffer(key)) {\n        var errMsg = \"Offline datastore key must be a buffer\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'));\n      }\n\n      var routingKey;\n\n      try {\n        routingKey = this._routingKey(key);\n      } catch (err) {\n        var _errMsg3 = \"Not possible to generate the routing key\";\n        log.error(_errMsg3);\n        return callback(errcode(new Error(_errMsg3), 'ERR_GENERATING_ROUTING_KEY'));\n      }\n\n      this._repo.datastore.get(routingKey, function (err, res) {\n        if (err) {\n          return callback(err);\n        } // Unmarshal libp2p record as the DHT does\n\n\n        var record;\n\n        try {\n          record = Record.deserialize(res);\n        } catch (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        callback(null, record.value);\n      });\n    } // encode key properly - base32(/ipns/{cid})\n\n  }, {\n    key: \"_routingKey\",\n    value: function _routingKey(key) {\n      return new Key('/' + encodeBase32(key), false);\n    }\n  }]);\n\n  return OfflineDatastore;\n}();\n\nexports = module.exports = OfflineDatastore;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs/src/core/ipns/routing/offline-datastore.js"],"names":["require","Key","Record","encodeBase32","errcode","debug","log","error","OfflineDatastore","repo","_repo","key","value","callback","Buffer","isBuffer","errMsg","Error","routingKey","_routingKey","err","record","datastore","put","serialize","get","res","deserialize","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Key } = require('interface-datastore')\nconst { Record } = require('libp2p-record')\nconst { encodeBase32 } = require('./utils')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:offline-datastore')\nlog.error = debug('ipfs:ipns:offline-datastore:error')\n\n// Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\nclass OfflineDatastore {\n  constructor (repo) {\n    this._repo = repo\n  }\n\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  put (key, value, callback) {\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = `Offline datastore key must be a buffer`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'))\n    }\n\n    if (!Buffer.isBuffer(value)) {\n      const errMsg = `Offline datastore value must be a buffer`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_VALUE'))\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (err) {\n      const errMsg = `Not possible to generate the routing key`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_GENERATING_ROUTING_KEY'))\n    }\n\n    // Marshal to libp2p record as the DHT does\n    const record = new Record(key, value)\n\n    this._repo.datastore.put(routingKey, record.serialize(), callback)\n  }\n\n  /**\n   * Get a value from the local datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value to be obtained.\n   * @param {function(Error, Buffer)} callback\n   * @returns {void}\n   */\n  get (key, callback) {\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = `Offline datastore key must be a buffer`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'))\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (err) {\n      const errMsg = `Not possible to generate the routing key`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_GENERATING_ROUTING_KEY'))\n    }\n\n    this._repo.datastore.get(routingKey, (err, res) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // Unmarshal libp2p record as the DHT does\n      let record\n      try {\n        record = Record.deserialize(res)\n      } catch (err) {\n        log.error(err)\n        return callback(err)\n      }\n\n      callback(null, record.value)\n    })\n  }\n\n  // encode key properly - base32(/ipns/{cid})\n  _routingKey (key) {\n    return new Key('/' + encodeBase32(key), false)\n  }\n}\n\nexports = module.exports = OfflineDatastore\n"]},"metadata":{},"sourceType":"script"}