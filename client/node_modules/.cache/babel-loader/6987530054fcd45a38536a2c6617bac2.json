{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\n\n/**\n * Define a struct error.\n *\n * @type {StructError}\n */\nvar StructError = /*#__PURE__*/function (_TypeError) {\n  _inherits(StructError, _TypeError);\n\n  var _super = _createSuper(StructError);\n\n  function StructError(attrs) {\n    var _this;\n\n    _classCallCheck(this, StructError);\n\n    var message = StructError.format(attrs);\n    _this = _super.call(this, message);\n    var data = attrs.data,\n        path = attrs.path,\n        value = attrs.value,\n        reason = attrs.reason,\n        type = attrs.type,\n        _attrs$errors = attrs.errors,\n        errors = _attrs$errors === void 0 ? [] : _attrs$errors;\n    _this.data = data;\n    _this.path = path;\n    _this.value = value;\n    _this.reason = reason;\n    _this.type = type;\n    _this.errors = errors;\n\n    if (!errors.length) {\n      errors.push(_assertThisInitialized(_this));\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);\n    } else {\n      _this.stack = new Error().stack;\n    }\n\n    return _this;\n  }\n\n  _createClass(StructError, null, [{\n    key: \"format\",\n    value: function format(attrs) {\n      var type = attrs.type,\n          path = attrs.path,\n          value = attrs.value;\n      var message = \"Expected a value of type `\".concat(type, \"`\").concat(path.length ? \" for `\".concat(path.join('.'), \"`\") : '', \" but received `\").concat(JSON.stringify(value), \"`.\");\n      return message;\n    }\n  }]);\n\n  return StructError;\n}( /*#__PURE__*/_wrapNativeSuper(TypeError));\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol':\n      return 'symbol';\n\n    case 'Promise':\n      return 'promise';\n    // Set, Map, WeakSet, WeakMap\n\n    case 'WeakMap':\n      return 'weakmap';\n\n    case 'WeakSet':\n      return 'weakset';\n\n    case 'Map':\n      return 'map';\n\n    case 'Set':\n      return 'set';\n    // 8-bit typed arrays\n\n    case 'Int8Array':\n      return 'int8array';\n\n    case 'Uint8Array':\n      return 'uint8array';\n\n    case 'Uint8ClampedArray':\n      return 'uint8clampedarray';\n    // 16-bit typed arrays\n\n    case 'Int16Array':\n      return 'int16array';\n\n    case 'Uint16Array':\n      return 'uint16array';\n    // 32-bit typed arrays\n\n    case 'Int32Array':\n      return 'int32array';\n\n    case 'Uint32Array':\n      return 'uint32array';\n\n    case 'Float32Array':\n      return 'float32array';\n\n    case 'Float64Array':\n      return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  } // Non-plain objects\n\n\n  type = toString.call(val);\n\n  switch (type) {\n    case '[object Object]':\n      return 'object';\n    // iterators\n\n    case '[object Map Iterator]':\n      return 'mapiterator';\n\n    case '[object Set Iterator]':\n      return 'setiterator';\n\n    case '[object String Iterator]':\n      return 'stringiterator';\n\n    case '[object Array Iterator]':\n      return 'arrayiterator';\n  } // other\n\n\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string' && typeof val.ignoreCase === 'boolean' && typeof val.multiline === 'boolean' && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function' && typeof val.return === 'function' && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n\n  return false;\n}\n/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\n\nvar IS_STRUCT = '@@__STRUCT__@@';\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nvar KIND = '@@__KIND__@@';\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nfunction isStruct(value) {\n  return !!(value && value[IS_STRUCT]);\n}\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\n\nfunction resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults;\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\n\nvar Kind = function Kind(name, type, validate) {\n  _classCallCheck(this, Kind);\n\n  this.name = name;\n  this.type = type;\n  this.validate = validate;\n};\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction any(schema, defaults$$1, options) {\n  if (isStruct(schema)) {\n    return schema[KIND];\n  }\n\n  if (schema instanceof Kind) {\n    return schema;\n  }\n\n  switch (kindOf(schema)) {\n    case 'array':\n      {\n        return schema.length > 1 ? tuple(schema, defaults$$1, options) : list(schema, defaults$$1, options);\n      }\n\n    case 'function':\n      {\n        return func(schema, defaults$$1, options);\n      }\n\n    case 'object':\n      {\n        return object(schema, defaults$$1, options);\n      }\n\n    case 'string':\n      {\n        var required = true;\n        var type;\n\n        if (schema.endsWith('?')) {\n          required = false;\n          schema = schema.slice(0, -1);\n        }\n\n        if (schema.includes('|')) {\n          var scalars = schema.split(/\\s*\\|\\s*/g);\n          type = union(scalars, defaults$$1, options);\n        } else if (schema.includes('&')) {\n          var _scalars = schema.split(/\\s*&\\s*/g);\n\n          type = intersection(_scalars, defaults$$1, options);\n        } else {\n          type = scalar(schema, defaults$$1, options);\n        }\n\n        if (!required) {\n          type = optional(type, undefined, options);\n        }\n\n        return type;\n      }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(\"A schema definition must be an object, array, string or function, but you passed: \".concat(schema));\n  } else {\n    throw new Error(\"Invalid schema: \".concat(schema));\n  }\n}\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction dict(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Dict structs must be defined as an array with two elements, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var obj = scalar('object', undefined, options);\n  var keys = any(schema[0], undefined, options);\n  var values = any(schema[1], undefined, options);\n  var name = 'dict';\n  var type = \"dict<\".concat(keys.type, \",\").concat(values.type, \">\");\n\n  var validate = function validate(value) {\n    var resolved = resolveDefaults(defaults$$1);\n    value = resolved ? _extends({}, resolved, value) : value;\n\n    var _obj$validate = obj.validate(value),\n        _obj$validate2 = _slicedToArray(_obj$validate, 1),\n        error = _obj$validate2[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var ret = {};\n    var errors = [];\n\n    var _loop = function _loop(_k) {\n      var v = value[_k];\n\n      var _keys$validate = keys.validate(_k),\n          _keys$validate2 = _slicedToArray(_keys$validate, 2),\n          e = _keys$validate2[0],\n          r = _keys$validate2[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [_k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        k = _k;\n        return \"continue\";\n      }\n\n      _k = r;\n\n      var _values$validate = values.validate(v),\n          _values$validate2 = _slicedToArray(_values$validate, 2),\n          e2 = _values$validate2[0],\n          r2 = _values$validate2[1];\n\n      if (e2) {\n        var allE2 = e2.errors || [e2];\n        allE2.forEach(function (singleE) {\n          singleE.path = [_k].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        k = _k;\n        return \"continue\";\n      }\n\n      ret[_k] = r2;\n      k = _k;\n    };\n\n    for (var k in value) {\n      var _ret = _loop(k);\n\n      if (_ret === \"continue\") continue;\n    }\n\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction en(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Enum structs must be defined as an array, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var name = 'enum';\n  var type = schema.map(function (s) {\n    try {\n      return JSON.stringify(s);\n    } catch (e) {\n      return String(s);\n    }\n  }).join(' | ');\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    return schema.includes(value) ? [undefined, value] : [{\n      data: value,\n      path: [],\n      value: value,\n      type: type\n    }];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction enums(schema, defaults$$1, options) {\n  var e = en(schema, undefined, options);\n  var l = list([e], defaults$$1, options);\n  return l;\n}\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction func(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Function structs must be defined as a function, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var name = 'function';\n  var type = '<function>';\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var data = arguments.length > 1 ? arguments[1] : undefined;\n    var result = schema(value, data);\n    var failure = {\n      path: [],\n      reason: null\n    };\n    var isValid;\n\n    switch (kindOf(result)) {\n      case 'boolean':\n        {\n          isValid = result;\n          break;\n        }\n\n      case 'string':\n        {\n          isValid = false;\n          failure.reason = result;\n          break;\n        }\n\n      case 'object':\n        {\n          isValid = false;\n          failure = _extends({}, failure, result);\n          break;\n        }\n\n      default:\n        {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\"Validator functions must return a boolean, an error reason string or an error reason object, but you passed: \".concat(schema));\n          } else {\n            throw new Error(\"Invalid result: \".concat(result));\n          }\n        }\n    }\n\n    return isValid ? [undefined, value] : [_extends({\n      type: type,\n      value: value,\n      data: value\n    }, failure)];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction instance(schema, defaults$$1, options) {\n  var name = 'instance';\n  var type = \"instance<\".concat(schema.name, \">\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    return value instanceof schema ? [undefined, value] : [{\n      data: value,\n      path: [],\n      value: value,\n      type: type\n    }];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction inter(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Interface structs must be defined as an object, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var obj = scalar('object', undefined, options);\n  var ks = [];\n  var properties = {};\n\n  for (var key in schema) {\n    ks.push(key);\n    var s = schema[key];\n    var kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  var name = 'interface';\n  var type = \"{\".concat(ks.join(), \"}\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _obj$validate3 = obj.validate(value),\n        _obj$validate4 = _slicedToArray(_obj$validate3, 1),\n        error = _obj$validate4[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var errors = [];\n    var ret = value;\n\n    var _loop2 = function _loop2(_key) {\n      var v = value[_key];\n      var kind = properties[_key];\n\n      if (v === undefined) {\n        var d = defaults$$1 && defaults$$1[_key];\n        v = resolveDefaults(d, value);\n      }\n\n      var _kind$validate = kind.validate(v, value),\n          _kind$validate2 = _slicedToArray(_kind$validate, 2),\n          e = _kind$validate2[0],\n          r = _kind$validate2[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [_key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      if (_key in value || r !== undefined) {\n        ret[_key] = r;\n      }\n    };\n\n    for (var _key in properties) {\n      var _ret2 = _loop2(_key);\n\n      if (_ret2 === \"continue\") continue;\n    }\n\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction lazy(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Lazy structs must be defined as an function that returns a schema, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var kind;\n  var struct;\n  var name = 'lazy';\n  var type = \"lazy...\";\n\n  var compile = function compile(value) {\n    struct = schema();\n    kind.name = struct.kind;\n    kind.type = struct.type;\n    kind.validate = struct.validate;\n    return kind.validate(value);\n  };\n\n  kind = new Kind(name, type, compile);\n  return kind;\n}\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction dynamic(createSchema, defaults$$1, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Dynamic structs must be defined as a function, but you passed: \".concat(createSchema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(createSchema));\n    }\n  }\n\n  var name = 'dynamic';\n  var type = 'dynamic...';\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var data = arguments.length > 1 ? arguments[1] : undefined;\n    var schema = createSchema(value, data);\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\"Dynamic structs must return a schema, but you passed: \".concat(schema));\n      } else {\n        throw new Error(\"Invalid schema: \".concat(schema));\n      }\n    }\n\n    var _schema$validate = schema.validate(value),\n        _schema$validate2 = _slicedToArray(_schema$validate, 2),\n        error = _schema$validate2[0],\n        result = _schema$validate2[1];\n\n    if (error) {\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\n\nfunction list(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"List structs must be defined as an array with a single element, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var array = scalar('array', undefined, options);\n  var element = any(schema[0], undefined, options);\n  var name = 'list';\n  var type = \"[\".concat(element.type, \"]\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _array$validate = array.validate(value),\n        _array$validate2 = _slicedToArray(_array$validate, 2),\n        error = _array$validate2[0],\n        result = _array$validate2[1];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    value = result;\n    var errors = [];\n    var ret = [];\n\n    var _loop3 = function _loop3(i) {\n      var v = value[i];\n\n      var _element$validate = element.validate(v),\n          _element$validate2 = _slicedToArray(_element$validate, 2),\n          e = _element$validate2[0],\n          r = _element$validate2[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      ret[i] = r;\n    };\n\n    for (var i = 0; i < value.length; i++) {\n      var _ret3 = _loop3(i);\n\n      if (_ret3 === \"continue\") continue;\n    }\n\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction literal(schema, defaults$$1, options) {\n  var name = 'literal';\n  var type = \"literal: \".concat(JSON.stringify(schema));\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    return value === schema ? [undefined, value] : [{\n      data: value,\n      path: [],\n      value: value,\n      type: type\n    }];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction object(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Object structs must be defined as an object, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var obj = scalar('object', undefined, options);\n  var ks = [];\n  var properties = {};\n\n  for (var key in schema) {\n    ks.push(key);\n    var s = schema[key];\n    var kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  var name = 'object';\n  var type = \"{\".concat(ks.join(), \"}\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _obj$validate5 = obj.validate(value),\n        _obj$validate6 = _slicedToArray(_obj$validate5, 1),\n        error = _obj$validate6[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var errors = [];\n    var ret = {};\n    var valueKeys = Object.keys(value);\n    var propertiesKeys = Object.keys(properties);\n    var keys = new Set(valueKeys.concat(propertiesKeys));\n    keys.forEach(function (key) {\n      var v = value[key];\n      var kind = properties[key];\n\n      if (v === undefined) {\n        var d = defaults$$1 && defaults$$1[key];\n        v = resolveDefaults(d, value);\n      }\n\n      if (!kind) {\n        var _e = {\n          data: value,\n          path: [key],\n          value: v\n        };\n        errors.push(_e);\n        return;\n      }\n\n      var _kind$validate3 = kind.validate(v, value),\n          _kind$validate4 = _slicedToArray(_kind$validate3, 2),\n          e = _kind$validate4[0],\n          r = _kind$validate4[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [key].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return;\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r;\n      }\n    });\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction optional(schema, defaults$$1, options) {\n  return union([schema, 'undefined'], defaults$$1, options);\n}\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\n\nfunction partial(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Partial structs must be defined as an object, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var obj = scalar('object', undefined, options);\n  var ks = [];\n  var properties = {};\n\n  for (var key in schema) {\n    ks.push(key);\n    var s = schema[key];\n    var kind = any(s, undefined, options);\n    properties[key] = kind;\n  }\n\n  var name = 'partial';\n  var type = \"{\".concat(ks.join(), \",...}\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _obj$validate7 = obj.validate(value),\n        _obj$validate8 = _slicedToArray(_obj$validate7, 1),\n        error = _obj$validate8[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var errors = [];\n    var ret = {};\n\n    var _loop4 = function _loop4(_key2) {\n      var v = value[_key2];\n      var kind = properties[_key2];\n\n      if (v === undefined) {\n        var d = defaults$$1 && defaults$$1[_key2];\n        v = resolveDefaults(d, value);\n      }\n\n      var _kind$validate5 = kind.validate(v, value),\n          _kind$validate6 = _slicedToArray(_kind$validate5, 2),\n          e = _kind$validate6[0],\n          r = _kind$validate6[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [_key2].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      if (_key2 in value || r !== undefined) {\n        ret[_key2] = r;\n      }\n    };\n\n    for (var _key2 in properties) {\n      var _ret4 = _loop4(_key2);\n\n      if (_ret4 === \"continue\") continue;\n    }\n\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction scalar(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Scalar structs must be defined as a string, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var types = options.types;\n  var fn = types[schema];\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"No struct validator function found for type \\\"\".concat(schema, \"\\\".\"));\n    } else {\n      throw new Error(\"Invalid type: \".concat(schema));\n    }\n  }\n\n  var kind = func(fn, defaults$$1, options);\n  var name = 'scalar';\n  var type = schema;\n\n  var validate = function validate(value) {\n    var _kind$validate7 = kind.validate(value),\n        _kind$validate8 = _slicedToArray(_kind$validate7, 2),\n        error = _kind$validate8[0],\n        result = _kind$validate8[1];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    return [undefined, result];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\n\nfunction tuple(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Tuple structs must be defined as an array, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var kinds = schema.map(function (s) {\n    return any(s, undefined, options);\n  });\n  var array = scalar('array', undefined, options);\n  var name = 'tuple';\n  var type = \"[\".concat(kinds.map(function (k) {\n    return k.type;\n  }).join(), \"]\");\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n\n    var _array$validate3 = array.validate(value),\n        _array$validate4 = _slicedToArray(_array$validate3, 1),\n        error = _array$validate4[0];\n\n    if (error) {\n      error.type = type;\n      return [error];\n    }\n\n    var ret = [];\n    var errors = [];\n    var length = Math.max(value.length, kinds.length);\n\n    var _loop5 = function _loop5(i) {\n      var kind = kinds[i];\n      var v = value[i];\n\n      if (!kind) {\n        var _e2 = {\n          data: value,\n          path: [i],\n          value: v\n        };\n        errors.push(_e2);\n        return \"continue\";\n      }\n\n      var _kind$validate9 = kind.validate(v),\n          _kind$validate10 = _slicedToArray(_kind$validate9, 2),\n          e = _kind$validate10[0],\n          r = _kind$validate10[1];\n\n      if (e) {\n        var allE = e.errors || [e];\n        allE.forEach(function (singleE) {\n          singleE.path = [i].concat(singleE.path);\n          singleE.data = value;\n          errors.push(singleE);\n        });\n        return \"continue\";\n      }\n\n      ret[i] = r;\n    };\n\n    for (var i = 0; i < length; i++) {\n      var _ret5 = _loop5(i);\n\n      if (_ret5 === \"continue\") continue;\n    }\n\n    return errors.length ? [_extends({}, errors[0], {\n      errors: errors\n    })] : [undefined, ret];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction union(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Union structs must be defined as an array, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var kinds = schema.map(function (s) {\n    return any(s, undefined, options);\n  });\n  var name = 'union';\n  var type = kinds.map(function (k) {\n    return k.type;\n  }).join(' | ');\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var errors = [];\n\n    var _iterator = _createForOfIteratorHelper(kinds),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _k2 = _step.value;\n\n        var _k2$validate = _k2.validate(value),\n            _k2$validate2 = _slicedToArray(_k2$validate, 2),\n            e = _k2$validate2[0],\n            r = _k2$validate2[1];\n\n        if (!e) {\n          return [undefined, r];\n        }\n\n        errors.push(e);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    errors[0].type = type;\n    return errors;\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\n\nfunction intersection(schema, defaults$$1, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"Intersection structs must be defined as an array, but you passed: \".concat(schema));\n    } else {\n      throw new Error(\"Invalid schema: \".concat(schema));\n    }\n  }\n\n  var types = schema.map(function (s) {\n    return any(s, undefined, options);\n  });\n  var name = 'intersection';\n  var type = types.map(function (t) {\n    return t.type;\n  }).join(' & ');\n\n  var validate = function validate() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolveDefaults(defaults$$1);\n    var v = value;\n\n    var _iterator2 = _createForOfIteratorHelper(types),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var t = _step2.value;\n\n        var _t$validate = t.validate(v),\n            _t$validate2 = _slicedToArray(_t$validate, 2),\n            e = _t$validate2[0],\n            r = _t$validate2[1];\n\n        if (e) {\n          e.type = type;\n          return [e];\n        }\n\n        v = r;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return [undefined, v];\n  };\n\n  return new Kind(name, type, validate);\n}\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\n\nvar Kinds = {\n  any: any,\n  dict: dict,\n  enum: en,\n  enums: enums,\n  function: func,\n  instance: instance,\n  interface: inter,\n  lazy: lazy,\n  list: list,\n  literal: literal,\n  object: object,\n  optional: optional,\n  partial: partial,\n  scalar: scalar,\n  tuple: tuple,\n  union: union,\n  intersection: intersection,\n  dynamic: dynamic\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nvar TYPES = ['arguments', 'array', 'boolean', 'buffer', 'error', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'promise', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nvar Types = {\n  any: function any(value) {\n    return value !== undefined;\n  }\n};\nTYPES.forEach(function (type) {\n  Types[type] = function (value) {\n    return kindOf(value) === type;\n  };\n});\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = function (value) {\n  return kindOf(value) === 'date' && !isNaN(value);\n};\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\n\nfunction superstruct() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var types = _extends({}, Types, config.types || {});\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n\n  function struct(schema, defaults$$1) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (isStruct(schema)) {\n      schema = schema.schema;\n    }\n\n    var kind = Kinds.any(schema, defaults$$1, _extends({}, options, {\n      types: types\n    }));\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error('The `Struct` creation function should not be used with the `new` keyword.');\n        } else {\n          throw new Error('Invalid `new` keyword!');\n        }\n      }\n\n      return Struct.assert(data);\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, {\n      value: true\n    });\n    Object.defineProperty(Struct, KIND, {\n      value: kind\n    });\n    Struct.kind = kind.name;\n    Struct.type = kind.type;\n    Struct.schema = schema;\n    Struct.defaults = defaults$$1;\n    Struct.options = options;\n\n    Struct.assert = function (value) {\n      var _kind$validate11 = kind.validate(value),\n          _kind$validate12 = _slicedToArray(_kind$validate11, 2),\n          error = _kind$validate12[0],\n          result = _kind$validate12[1];\n\n      if (error) {\n        throw new StructError(error);\n      }\n\n      return result;\n    };\n\n    Struct.test = function (value) {\n      var _kind$validate13 = kind.validate(value),\n          _kind$validate14 = _slicedToArray(_kind$validate13, 1),\n          error = _kind$validate14[0];\n\n      return !error;\n    };\n\n    Struct.validate = function (value) {\n      var _kind$validate15 = kind.validate(value),\n          _kind$validate16 = _slicedToArray(_kind$validate15, 2),\n          error = _kind$validate16[0],\n          result = _kind$validate16[1];\n\n      if (error) {\n        return [new StructError(error)];\n      }\n\n      return [undefined, result];\n    };\n\n    return Struct;\n  }\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n\n  Object.keys(Kinds).forEach(function (name) {\n    var kind = Kinds[name];\n\n    struct[name] = function (schema, defaults$$1, options) {\n      var type = kind(schema, defaults$$1, _extends({}, options, {\n        types: types\n      }));\n      var s = struct(type, defaults$$1, options);\n      return s;\n    };\n  });\n  /**\n   * Return the struct factory.\n   */\n\n  return struct;\n}\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\n\nvar struct = superstruct();\nexport { struct, superstruct, isStruct, StructError };","map":{"version":3,"sources":["../src/error.js","../node_modules/kind-of/index.js","../src/constants.js","../src/utils.js","../src/kinds.js","../src/types.js","../src/superstruct.js","../src/index.js"],"names":["message","type","path","JSON","StructError","errors","Error","IS_STRUCT","KIND","value","defaults","isStruct","schema","kindOf","tuple","list","func","object","required","scalars","union","intersection","scalar","optional","process","obj","keys","any","values","name","validate","resolved","resolveDefaults","ret","v","allE","e","singleE","allE2","e2","s","String","data","en","l","result","failure","reason","isValid","ks","properties","kind","d","key","r","compile","struct","createSchema","array","element","i","valueKeys","Object","propertiesKeys","fn","types","kinds","k","length","Math","t","Kinds","TYPES","Types","undefined","isNaN","config","options","Struct","superstruct"],"mappings":"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","sourcesContent":["/**\n * Define a struct error.\n *\n * @type {StructError}\n */\n\nclass StructError extends TypeError {\n  static format(attrs) {\n    const { type, path, value } = attrs\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n    return message\n  }\n\n  constructor(attrs) {\n    const message = StructError.format(attrs)\n    super(message)\n\n    const { data, path, value, reason, type, errors = [] } = attrs\n    this.data = data\n    this.path = path\n    this.value = value\n    this.reason = reason\n    this.type = type\n    this.errors = errors\n\n    if (!errors.length) {\n      errors.push(this)\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {StructError}\n */\n\nexport default StructError\n","var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\nconst IS_STRUCT = '@@__STRUCT__@@'\n\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nconst KIND = '@@__KIND__@@'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport { IS_STRUCT, KIND }\n","import { IS_STRUCT } from './constants'\n\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nexport function isStruct(value) {\n  return !!(value && value[IS_STRUCT])\n}\n\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\nexport function resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults\n}\n","import kindOf from 'kind-of'\n\nimport { KIND } from './constants'\nimport { isStruct, resolveDefaults } from './utils'\n\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\nclass Kind {\n  constructor(name, type, validate) {\n    this.name = name\n    this.type = type\n    this.validate = validate\n  }\n}\n\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction any(schema, defaults, options) {\n  if (isStruct(schema)) {\n    return schema[KIND]\n  }\n\n  if (schema instanceof Kind) {\n    return schema\n  }\n\n  switch (kindOf(schema)) {\n    case 'array': {\n      return schema.length > 1\n        ? tuple(schema, defaults, options)\n        : list(schema, defaults, options)\n    }\n\n    case 'function': {\n      return func(schema, defaults, options)\n    }\n\n    case 'object': {\n      return object(schema, defaults, options)\n    }\n\n    case 'string': {\n      let required = true\n      let type\n\n      if (schema.endsWith('?')) {\n        required = false\n        schema = schema.slice(0, -1)\n      }\n\n      if (schema.includes('|')) {\n        const scalars = schema.split(/\\s*\\|\\s*/g)\n        type = union(scalars, defaults, options)\n      } else if (schema.includes('&')) {\n        const scalars = schema.split(/\\s*&\\s*/g)\n        type = intersection(scalars, defaults, options)\n      } else {\n        type = scalar(schema, defaults, options)\n      }\n\n      if (!required) {\n        type = optional(type, undefined, options)\n      }\n\n      return type\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(\n      `A schema definition must be an object, array, string or function, but you passed: ${schema}`\n    )\n  } else {\n    throw new Error(`Invalid schema: ${schema}`)\n  }\n}\n\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction dict(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Dict structs must be defined as an array with two elements, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const keys = any(schema[0], undefined, options)\n  const values = any(schema[1], undefined, options)\n  const name = 'dict'\n  const type = `dict<${keys.type},${values.type}>`\n  const validate = value => {\n    const resolved = resolveDefaults(defaults)\n    value = resolved ? { ...resolved, ...value } : value\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const ret = {}\n    const errors = []\n\n    for (let k in value) {\n      const v = value[k]\n      const [e, r] = keys.validate(k)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      k = r\n      const [e2, r2] = values.validate(v)\n\n      if (e2) {\n        const allE2 = e2.errors || [e2]\n        allE2.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[k] = r2\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction en(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Enum structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const name = 'enum'\n  const type = schema\n    .map(s => {\n      try {\n        return JSON.stringify(s)\n      } catch (e) {\n        return String(s)\n      }\n    })\n    .join(' | ')\n\n  const validate = (value = resolveDefaults(defaults)) => {\n    return schema.includes(value)\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction enums(schema, defaults, options) {\n  const e = en(schema, undefined, options)\n  const l = list([e], defaults, options)\n  return l\n}\n\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction func(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Function structs must be defined as a function, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const name = 'function'\n  const type = '<function>'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const result = schema(value, data)\n    let failure = { path: [], reason: null }\n    let isValid\n\n    switch (kindOf(result)) {\n      case 'boolean': {\n        isValid = result\n        break\n      }\n      case 'string': {\n        isValid = false\n        failure.reason = result\n        break\n      }\n      case 'object': {\n        isValid = false\n        failure = { ...failure, ...result }\n        break\n      }\n      default: {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            `Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`\n          )\n        } else {\n          throw new Error(`Invalid result: ${result}`)\n        }\n      }\n    }\n\n    return isValid\n      ? [undefined, value]\n      : [{ type, value, data: value, ...failure }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction instance(schema, defaults, options) {\n  const name = 'instance'\n  const type = `instance<${schema.name}>`\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value instanceof schema\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction inter(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Interface structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'interface'\n  const type = `{${ks.join()}}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = value\n\n    for (const key in properties) {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction lazy(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  let kind\n  let struct\n  const name = 'lazy'\n  const type = `lazy...`\n  const compile = value => {\n    struct = schema()\n    kind.name = struct.kind\n    kind.type = struct.type\n    kind.validate = struct.validate\n    return kind.validate(value)\n  }\n\n  kind = new Kind(name, type, compile)\n  return kind\n}\n\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction dynamic(createSchema, defaults, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Dynamic structs must be defined as a function, but you passed: ${createSchema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${createSchema}`)\n    }\n  }\n\n  const name = 'dynamic'\n  const type = 'dynamic...'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const schema = createSchema(value, data)\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\n          `Dynamic structs must return a schema, but you passed: ${schema}`\n        )\n      } else {\n        throw new Error(`Invalid schema: ${schema}`)\n      }\n    }\n\n    const [error, result] = schema.validate(value)\n\n    if (error) {\n      return [error]\n    }\n\n    return [undefined, result]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction list(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `List structs must be defined as an array with a single element, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const array = scalar('array', undefined, options)\n  const element = any(schema[0], undefined, options)\n  const name = 'list'\n  const type = `[${element.type}]`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error, result] = array.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    value = result\n    const errors = []\n    const ret = []\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i]\n      const [e, r] = element.validate(v)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[i] = r\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction literal(schema, defaults, options) {\n  const name = 'literal'\n  const type = `literal: ${JSON.stringify(schema)}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value === schema\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction object(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Object structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'object'\n  const type = `{${ks.join()}}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = {}\n    const valueKeys = Object.keys(value)\n    const propertiesKeys = Object.keys(properties)\n    const keys = new Set(valueKeys.concat(propertiesKeys))\n\n    keys.forEach(key => {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      if (!kind) {\n        const e = { data: value, path: [key], value: v }\n        errors.push(e)\n        return\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        return\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    })\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction optional(schema, defaults, options) {\n  return union([schema, 'undefined'], defaults, options)\n}\n\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction partial(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Partial structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'partial'\n  const type = `{${ks.join()},...}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = {}\n\n    for (const key in properties) {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction scalar(schema, defaults, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Scalar structs must be defined as a string, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const { types } = options\n  const fn = types[schema]\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `No struct validator function found for type \"${schema}\".`\n      )\n    } else {\n      throw new Error(`Invalid type: ${schema}`)\n    }\n  }\n\n  const kind = func(fn, defaults, options)\n  const name = 'scalar'\n  const type = schema\n  const validate = value => {\n    const [error, result] = kind.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    return [undefined, result]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction tuple(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Tuple structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options))\n  const array = scalar('array', undefined, options)\n  const name = 'tuple'\n  const type = `[${kinds.map(k => k.type).join()}]`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = array.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const ret = []\n    const errors = []\n    const length = Math.max(value.length, kinds.length)\n\n    for (let i = 0; i < length; i++) {\n      const kind = kinds[i]\n      const v = value[i]\n\n      if (!kind) {\n        const e = { data: value, path: [i], value: v }\n        errors.push(e)\n        continue\n      }\n\n      const [e, r] = kind.validate(v)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[i] = r\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction union(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Union structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options))\n  const name = 'union'\n  const type = kinds.map(k => k.type).join(' | ')\n  const validate = (value = resolveDefaults(defaults)) => {\n    const errors = []\n\n    for (const k of kinds) {\n      const [e, r] = k.validate(value)\n\n      if (!e) {\n        return [undefined, r]\n      }\n\n      errors.push(e)\n    }\n    errors[0].type = type\n    return errors\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction intersection(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Intersection structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const types = schema.map(s => any(s, undefined, options))\n  const name = 'intersection'\n  const type = types.map(t => t.type).join(' & ')\n  const validate = (value = resolveDefaults(defaults)) => {\n    let v = value\n\n    for (const t of types) {\n      const [e, r] = t.validate(v)\n\n      if (e) {\n        e.type = type\n        return [e]\n      }\n\n      v = r\n    }\n\n    return [undefined, v]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\nconst Kinds = {\n  any,\n  dict,\n  enum: en,\n  enums,\n  function: func,\n  instance,\n  interface: inter,\n  lazy,\n  list,\n  literal,\n  object,\n  optional,\n  partial,\n  scalar,\n  tuple,\n  union,\n  intersection,\n  dynamic,\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Kinds\n","import kindOf from 'kind-of'\n\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nconst TYPES = [\n  'arguments',\n  'array',\n  'boolean',\n  'buffer',\n  'error',\n  'float32array',\n  'float64array',\n  'function',\n  'generatorfunction',\n  'int16array',\n  'int32array',\n  'int8array',\n  'map',\n  'null',\n  'number',\n  'object',\n  'promise',\n  'regexp',\n  'set',\n  'string',\n  'symbol',\n  'uint16array',\n  'uint32array',\n  'uint8array',\n  'uint8clampedarray',\n  'undefined',\n  'weakmap',\n  'weakset',\n]\n\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nconst Types = {\n  any: value => value !== undefined,\n}\n\nTYPES.forEach(type => {\n  Types[type] = value => kindOf(value) === type\n})\n\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value)\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Types\n","import Kinds from './kinds'\nimport StructError from './error'\nimport Types from './types'\nimport { isStruct } from './utils'\nimport { IS_STRUCT, KIND } from './constants'\n\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\nfunction superstruct(config = {}) {\n  const types = {\n    ...Types,\n    ...(config.types || {}),\n  }\n\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function struct(schema, defaults, options = {}) {\n    if (isStruct(schema)) {\n      schema = schema.schema\n    }\n\n    const kind = Kinds.any(schema, defaults, { ...options, types })\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            'The `Struct` creation function should not be used with the `new` keyword.'\n          )\n        } else {\n          throw new Error('Invalid `new` keyword!')\n        }\n      }\n\n      return Struct.assert(data)\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, { value: true })\n    Object.defineProperty(Struct, KIND, { value: kind })\n\n    Struct.kind = kind.name\n    Struct.type = kind.type\n    Struct.schema = schema\n    Struct.defaults = defaults\n    Struct.options = options\n\n    Struct.assert = value => {\n      const [error, result] = kind.validate(value)\n\n      if (error) {\n        throw new StructError(error)\n      }\n\n      return result\n    }\n\n    Struct.test = value => {\n      const [error] = kind.validate(value)\n      return !error\n    }\n\n    Struct.validate = value => {\n      const [error, result] = kind.validate(value)\n\n      if (error) {\n        return [new StructError(error)]\n      }\n\n      return [undefined, result]\n    }\n\n    return Struct\n  }\n\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n  Object.keys(Kinds).forEach(name => {\n    const kind = Kinds[name]\n\n    struct[name] = (schema, defaults, options) => {\n      const type = kind(schema, defaults, { ...options, types })\n      const s = struct(type, defaults, options)\n      return s\n    }\n  })\n\n  /**\n   * Return the struct factory.\n   */\n\n  return struct\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default superstruct\n","import StructError from './error'\nimport superstruct from './superstruct'\nimport { isStruct } from './utils'\n\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\nconst struct = superstruct()\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport { struct, superstruct, isStruct, StructError }\n"]},"metadata":{},"sourceType":"module"}