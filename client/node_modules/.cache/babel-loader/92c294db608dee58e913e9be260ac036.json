{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar debug = require('debug');\n\nvar withIs = require('class-is');\n\nvar BaseConnection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(BaseConnection, _EventEmitter);\n\n  var _super = _createSuper(BaseConnection);\n\n  function BaseConnection(_ref) {\n    var _this;\n\n    var _switch = _ref._switch,\n        name = _ref.name;\n\n    _classCallCheck(this, BaseConnection);\n\n    _this = _super.call(this);\n    _this.switch = _switch;\n    _this.ourPeerInfo = _this.switch._peerInfo;\n    _this.log = debug(\"libp2p:conn:\".concat(name));\n    _this.log.error = debug(\"libp2p:conn:\".concat(name, \":error\"));\n    return _this;\n  }\n  /**\n   * Puts the state into its disconnecting flow\n   *\n   * @param {Error} err Will be emitted if provided\n   * @returns {void}\n   */\n\n\n  _createClass(BaseConnection, [{\n    key: \"close\",\n    value: function close(err) {\n      if (this._state._state === 'DISCONNECTING') return;\n      this.log('closing connection to %s', this.theirB58Id);\n\n      if (err && this._events.error) {\n        this.emit('error', err);\n      }\n\n      this._state('disconnect');\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (eventName === 'error' && !this._events.error) {\n        var _this$log;\n\n        (_this$log = this.log).error.apply(_this$log, args);\n      } else {\n        var _get2;\n\n        (_get2 = _get(_getPrototypeOf(BaseConnection.prototype), \"emit\", this)).call.apply(_get2, [this, eventName].concat(args));\n      }\n    }\n    /**\n     * Gets the current state of the connection\n     *\n     * @returns {string} The current state of the connection\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this._state._state;\n    }\n    /**\n     * Puts the state into encrypting mode\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt() {\n      this._state('encrypt');\n    }\n    /**\n     * Puts the state into privatizing mode\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"protect\",\n    value: function protect() {\n      this._state('privatize');\n    }\n    /**\n     * Puts the state into muxing mode\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"upgrade\",\n    value: function upgrade() {\n      this._state('upgrade');\n    }\n    /**\n     * Event handler for disconnected.\n     *\n     * @fires BaseConnection#close\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onDisconnected\",\n    value: function _onDisconnected() {\n      this.switch.connection.remove(this);\n      this.log('disconnected from %s', this.theirB58Id);\n      this.emit('close');\n      this.removeAllListeners();\n    }\n    /**\n     * Event handler for privatized\n     *\n     * @fires BaseConnection#private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onPrivatized\",\n    value: function _onPrivatized() {\n      this.emit('private', this.conn);\n    }\n    /**\n     * Wraps this.conn with the Switch.protector for private connections\n     *\n     * @private\n     * @fires ConnectionFSM#error\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onPrivatizing\",\n    value: function _onPrivatizing() {\n      var _this2 = this;\n\n      if (!this.switch.protector) {\n        return this._state('done');\n      }\n\n      this.conn = this.switch.protector.protect(this.conn, function (err) {\n        if (err) {\n          return _this2.close(err);\n        }\n\n        _this2.log('successfully privatized conn to %s', _this2.theirB58Id);\n\n        _this2.conn.setPeerInfo(_this2.theirPeerInfo);\n\n        _this2._state('done');\n      });\n    }\n  }]);\n\n  return BaseConnection;\n}(EventEmitter);\n\nmodule.exports = withIs(BaseConnection, {\n  className: 'BaseConnection',\n  symbolName: 'libp2p-switch/BaseConnection'\n});","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-switch/src/connection/base.js"],"names":["EventEmitter","require","debug","withIs","BaseConnection","_switch","name","switch","ourPeerInfo","_peerInfo","log","error","err","_state","theirB58Id","_events","emit","eventName","args","connection","remove","removeAllListeners","conn","protector","protect","close","setPeerInfo","theirPeerInfo","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events').EventEmitter\nconst debug = require('debug')\nconst withIs = require('class-is')\n\nclass BaseConnection extends EventEmitter {\n  constructor ({ _switch, name }) {\n    super()\n\n    this.switch = _switch\n    this.ourPeerInfo = this.switch._peerInfo\n    this.log = debug(`libp2p:conn:${name}`)\n    this.log.error = debug(`libp2p:conn:${name}:error`)\n  }\n\n  /**\n   * Puts the state into its disconnecting flow\n   *\n   * @param {Error} err Will be emitted if provided\n   * @returns {void}\n   */\n  close (err) {\n    if (this._state._state === 'DISCONNECTING') return\n    this.log('closing connection to %s', this.theirB58Id)\n    if (err && this._events.error) {\n      this.emit('error', err)\n    }\n    this._state('disconnect')\n  }\n\n  emit (eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      this.log.error(...args)\n    } else {\n      super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Gets the current state of the connection\n   *\n   * @returns {string} The current state of the connection\n   */\n  getState () {\n    return this._state._state\n  }\n\n  /**\n   * Puts the state into encrypting mode\n   *\n   * @returns {void}\n   */\n  encrypt () {\n    this._state('encrypt')\n  }\n\n  /**\n   * Puts the state into privatizing mode\n   *\n   * @returns {void}\n   */\n  protect () {\n    this._state('privatize')\n  }\n\n  /**\n   * Puts the state into muxing mode\n   *\n   * @returns {void}\n   */\n  upgrade () {\n    this._state('upgrade')\n  }\n\n  /**\n   * Event handler for disconnected.\n   *\n   * @fires BaseConnection#close\n   * @returns {void}\n   */\n  _onDisconnected () {\n    this.switch.connection.remove(this)\n    this.log('disconnected from %s', this.theirB58Id)\n    this.emit('close')\n    this.removeAllListeners()\n  }\n\n  /**\n   * Event handler for privatized\n   *\n   * @fires BaseConnection#private\n   * @returns {void}\n   */\n  _onPrivatized () {\n    this.emit('private', this.conn)\n  }\n\n  /**\n   * Wraps this.conn with the Switch.protector for private connections\n   *\n   * @private\n   * @fires ConnectionFSM#error\n   * @returns {void}\n   */\n  _onPrivatizing () {\n    if (!this.switch.protector) {\n      return this._state('done')\n    }\n\n    this.conn = this.switch.protector.protect(this.conn, (err) => {\n      if (err) {\n        return this.close(err)\n      }\n\n      this.log('successfully privatized conn to %s', this.theirB58Id)\n      this.conn.setPeerInfo(this.theirPeerInfo)\n      this._state('done')\n    })\n  }\n}\n\nmodule.exports = withIs(BaseConnection, {\n  className: 'BaseConnection',\n  symbolName: 'libp2p-switch/BaseConnection'\n})\n"]},"metadata":{},"sourceType":"script"}