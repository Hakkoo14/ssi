{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar Bucket = require('hamt-sharding/src/bucket');\n\nvar DirSharded = require('ipfs-unixfs-importer/src/dir-sharded');\n\nvar addLinksToHamtBucket = function addLinksToHamtBucket(links, bucket, rootBucket) {\n  return Promise.all(links.map(function (link) {\n    if (link.Name.length === 2) {\n      var pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hashFn: DirSharded.hashFn\n      }, bucket, pos));\n    }\n\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\nvar toPrefix = function toPrefix(position) {\n  return position.toString('16').toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\nvar toBucketPath = function toBucketPath(position) {\n  var bucket = position.bucket;\n  var path = [];\n\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n\n  path.push(bucket);\n  return path.reverse();\n};\n\nvar findShardCid = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(node, name, ipld, context) {\n    var position, prefix, bucketPath, link;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!context) {\n              context = {\n                rootBucket: new Bucket({\n                  hashFn: DirSharded.hashFn\n                }),\n                hamtDepth: 1\n              };\n              context.lastBucket = context.rootBucket;\n            }\n\n            _context.next = 3;\n            return addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n\n          case 3:\n            _context.next = 5;\n            return context.rootBucket._findNewBucketAndPos(name);\n\n          case 5:\n            position = _context.sent;\n            prefix = toPrefix(position.pos);\n            bucketPath = toBucketPath(position);\n\n            if (bucketPath.length > context.hamtDepth) {\n              context.lastBucket = bucketPath[context.hamtDepth];\n              prefix = toPrefix(context.lastBucket._posAtParent);\n            }\n\n            link = node.Links.find(function (link) {\n              var entryPrefix = link.Name.substring(0, 2);\n              var entryName = link.Name.substring(2);\n\n              if (entryPrefix !== prefix) {\n                // not the entry or subshard we're looking for\n                return;\n              }\n\n              if (entryName && entryName !== name) {\n                // not the entry we're looking for\n                return;\n              }\n\n              return true;\n            });\n\n            if (link) {\n              _context.next = 12;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 12:\n            if (!(link.Name.substring(2) === name)) {\n              _context.next = 14;\n              break;\n            }\n\n            return _context.abrupt(\"return\", link.Hash);\n\n          case 14:\n            context.hamtDepth++;\n            _context.next = 17;\n            return ipld.get(link.Hash);\n\n          case 17:\n            node = _context.sent;\n            return _context.abrupt(\"return\", findShardCid(node, name, ipld, context));\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function findShardCid(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = findShardCid;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js"],"names":["Bucket","require","DirSharded","addLinksToHamtBucket","links","bucket","rootBucket","Promise","all","map","link","Name","length","pos","parseInt","_putObjectAt","hashFn","put","substring","toPrefix","position","toString","toUpperCase","padStart","toBucketPath","path","_parent","push","reverse","findShardCid","node","name","ipld","context","hamtDepth","lastBucket","Links","_findNewBucketAndPos","prefix","bucketPath","_posAtParent","find","entryPrefix","entryName","Hash","get","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Bucket = require('hamt-sharding/src/bucket')\nconst DirSharded = require('ipfs-unixfs-importer/src/dir-sharded')\n\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(\n    links.map(link => {\n      if (link.Name.length === 2) {\n        const pos = parseInt(link.Name, 16)\n\n        return bucket._putObjectAt(pos, new Bucket({\n          hashFn: DirSharded.hashFn\n        }, bucket, pos))\n      }\n\n      return rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\nconst toPrefix = (position) => {\n  return position\n    .toString('16')\n    .toUpperCase()\n    .padStart(2, '0')\n    .substring(0, 2)\n}\n\nconst toBucketPath = (position) => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\nconst findShardCid = async (node, name, ipld, context) => {\n  if (!context) {\n    context = {\n      rootBucket: new Bucket({\n        hashFn: DirSharded.hashFn\n      }),\n      hamtDepth: 1\n    }\n\n    context.lastBucket = context.rootBucket\n  }\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > (context.hamtDepth)) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent)\n  }\n\n  const link = node.Links.find(link => {\n    const entryPrefix = link.Name.substring(0, 2)\n    const entryName = link.Name.substring(2)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return\n    }\n\n    if (entryName && entryName !== name) {\n      // not the entry we're looking for\n      return\n    }\n\n    return true\n  })\n\n  if (!link) {\n    return null\n  }\n\n  if (link.Name.substring(2) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  node = await ipld.get(link.Hash)\n\n  return findShardCid(node, name, ipld, context)\n}\n\nmodule.exports = findShardCid\n"]},"metadata":{},"sourceType":"script"}