{"ast":null,"code":"'use strict';\n\nvar core = require('datastore-core');\n\nvar ShardingStore = core.ShardingDatastore;\n\nvar Key = require('interface-datastore').Key;\n\nvar base32 = require('base32.js');\n\nvar Block = require('ipfs-block');\n\nvar setImmediate = require('async/setImmediate');\n\nvar reject = require('async/reject');\n\nvar CID = require('cids');\n\nvar pull = require('pull-stream/pull');\n\nvar collect = require('pull-stream/sinks/collect');\n/**\n * Transform a raw buffer to a base32 encoded key.\n *\n * @param {Buffer} rawKey\n * @returns {Key}\n */\n\n\nvar keyFromBuffer = function keyFromBuffer(rawKey) {\n  var enc = new base32.Encoder();\n  return new Key('/' + enc.write(rawKey).finalize(), false);\n};\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} cid\n * @returns {Key}\n */\n\n\nvar cidToDsKey = function cidToDsKey(cid) {\n  return keyFromBuffer(cid.buffer);\n};\n\nmodule.exports = function (filestore, options, callback) {\n  maybeWithSharding(filestore, options, function (err, store) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, createBaseStore(store));\n  });\n};\n\nfunction maybeWithSharding(filestore, options, callback) {\n  if (options.sharding) {\n    var shard = new core.shard.NextToLast(2);\n    ShardingStore.createOrOpen(filestore, shard, callback);\n  } else {\n    setImmediate(function () {\n      return callback(null, filestore);\n    });\n  }\n}\n\nfunction createBaseStore(store) {\n  return {\n    /**\n     * Query the store.\n     *\n     * @param {object} query\n     * @param {function(Error, Array)} callback\n     * @return {void}\n     */\n    query: function query(_query, callback) {\n      pull(store.query(_query), collect(callback));\n    },\n\n    /**\n     * Get a single block by CID.\n     *\n     * @param {CID} cid\n     * @param {function(Error, Block)} callback\n     * @returns {void}\n     */\n    get: function get(cid, callback) {\n      if (!CID.isCID(cid)) {\n        return setImmediate(function () {\n          callback(new Error('Not a valid cid'));\n        });\n      }\n\n      var key = cidToDsKey(cid);\n      store.get(key, function (err, blockData) {\n        if (err) {\n          // If not found, we try with the other CID version.\n          // If exists, then store that block under the CID that was requested.\n          // Some duplication occurs.\n          if (err.code === 'ERR_NOT_FOUND') {\n            var otherCid = cidToOtherVersion(cid);\n            if (!otherCid) return callback(err);\n            var otherKey = cidToDsKey(otherCid);\n            return store.get(otherKey, function (err, blockData) {\n              if (err) return callback(err);\n              store.put(key, blockData, function (err) {\n                if (err) return callback(err);\n                callback(null, new Block(blockData, cid));\n              });\n            });\n          }\n\n          return callback(err);\n        }\n\n        callback(null, new Block(blockData, cid));\n      });\n    },\n    put: function put(block, callback) {\n      if (!Block.isBlock(block)) {\n        return setImmediate(function () {\n          callback(new Error('invalid block'));\n        });\n      }\n\n      var k = cidToDsKey(block.cid);\n      store.has(k, function (err, exists) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (exists) {\n          return callback();\n        }\n\n        store.put(k, block.data, callback);\n      });\n    },\n\n    /**\n     * Like put, but for more.\n     *\n     * @param {Array<Block>} blocks\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    putMany: function putMany(blocks, callback) {\n      var keys = blocks.map(function (b) {\n        return {\n          key: cidToDsKey(b.cid),\n          block: b\n        };\n      });\n      var batch = store.batch();\n      reject(keys, function (k, cb) {\n        return store.has(k.key, cb);\n      }, function (err, newKeys) {\n        if (err) {\n          return callback(err);\n        }\n\n        newKeys.forEach(function (k) {\n          batch.put(k.key, k.block.data);\n        });\n        batch.commit(callback);\n      });\n    },\n\n    /**\n     * Does the store contain block with this cid?\n     *\n     * @param {CID} cid\n     * @param {function(Error, bool)} callback\n     * @returns {void}\n     */\n    has: function has(cid, callback) {\n      if (!CID.isCID(cid)) {\n        return setImmediate(function () {\n          callback(new Error('Not a valid cid'));\n        });\n      }\n\n      store.has(cidToDsKey(cid), function (err, exists) {\n        if (err) return callback(err);\n        if (exists) return callback(null, true); // If not found, we try with the other CID version.\n\n        var otherCid = cidToOtherVersion(cid);\n        if (!otherCid) return callback(null, false);\n        store.has(cidToDsKey(otherCid), callback);\n      });\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {CID} cid\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    delete: function _delete(cid, callback) {\n      if (!CID.isCID(cid)) {\n        return setImmediate(function () {\n          callback(new Error('Not a valid cid'));\n        });\n      }\n\n      store.delete(cidToDsKey(cid), callback);\n    },\n    close: function close(callback) {\n      store.close(callback);\n    }\n  };\n}\n\nfunction cidToOtherVersion(cid) {\n  try {\n    return cid.version === 0 ? cid.toV1() : cid.toV0();\n  } catch (err) {\n    return null;\n  }\n}","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs-repo/src/blockstore.js"],"names":["core","require","ShardingStore","ShardingDatastore","Key","base32","Block","setImmediate","reject","CID","pull","collect","keyFromBuffer","rawKey","enc","Encoder","write","finalize","cidToDsKey","cid","buffer","module","exports","filestore","options","callback","maybeWithSharding","err","store","createBaseStore","sharding","shard","NextToLast","createOrOpen","query","get","isCID","Error","key","blockData","code","otherCid","cidToOtherVersion","otherKey","put","block","isBlock","k","has","exists","data","putMany","blocks","keys","map","b","batch","cb","newKeys","forEach","commit","delete","close","version","toV1","toV0"],"mappings":"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","sourcesContent":["'use strict'\n\nconst core = require('datastore-core')\nconst ShardingStore = core.ShardingDatastore\nconst Key = require('interface-datastore').Key\nconst base32 = require('base32.js')\nconst Block = require('ipfs-block')\nconst setImmediate = require('async/setImmediate')\nconst reject = require('async/reject')\nconst CID = require('cids')\nconst pull = require('pull-stream/pull')\nconst collect = require('pull-stream/sinks/collect')\n\n/**\n * Transform a raw buffer to a base32 encoded key.\n *\n * @param {Buffer} rawKey\n * @returns {Key}\n */\nconst keyFromBuffer = (rawKey) => {\n  const enc = new base32.Encoder()\n  return new Key('/' + enc.write(rawKey).finalize(), false)\n}\n\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} cid\n * @returns {Key}\n */\nconst cidToDsKey = (cid) => {\n  return keyFromBuffer(cid.buffer)\n}\n\nmodule.exports = (filestore, options, callback) => {\n  maybeWithSharding(filestore, options, (err, store) => {\n    if (err) { return callback(err) }\n\n    callback(null, createBaseStore(store))\n  })\n}\n\nfunction maybeWithSharding (filestore, options, callback) {\n  if (options.sharding) {\n    const shard = new core.shard.NextToLast(2)\n    ShardingStore.createOrOpen(filestore, shard, callback)\n  } else {\n    setImmediate(() => callback(null, filestore))\n  }\n}\n\nfunction createBaseStore (store) {\n  return {\n    /**\n     * Query the store.\n     *\n     * @param {object} query\n     * @param {function(Error, Array)} callback\n     * @return {void}\n     */\n    query (query, callback) {\n      pull(\n        store.query(query),\n        collect(callback)\n      )\n    },\n    /**\n     * Get a single block by CID.\n     *\n     * @param {CID} cid\n     * @param {function(Error, Block)} callback\n     * @returns {void}\n     */\n    get (cid, callback) {\n      if (!CID.isCID(cid)) {\n        return setImmediate(() => {\n          callback(new Error('Not a valid cid'))\n        })\n      }\n\n      const key = cidToDsKey(cid)\n      store.get(key, (err, blockData) => {\n        if (err) {\n          // If not found, we try with the other CID version.\n          // If exists, then store that block under the CID that was requested.\n          // Some duplication occurs.\n          if (err.code === 'ERR_NOT_FOUND') {\n            const otherCid = cidToOtherVersion(cid)\n            if (!otherCid) return callback(err)\n\n            const otherKey = cidToDsKey(otherCid)\n            return store.get(otherKey, (err, blockData) => {\n              if (err) return callback(err)\n\n              store.put(key, blockData, (err) => {\n                if (err) return callback(err)\n                callback(null, new Block(blockData, cid))\n              })\n            })\n          }\n\n          return callback(err)\n        }\n\n        callback(null, new Block(blockData, cid))\n      })\n    },\n    put (block, callback) {\n      if (!Block.isBlock(block)) {\n        return setImmediate(() => {\n          callback(new Error('invalid block'))\n        })\n      }\n\n      const k = cidToDsKey(block.cid)\n\n      store.has(k, (err, exists) => {\n        if (err) { return callback(err) }\n        if (exists) { return callback() }\n\n        store.put(k, block.data, callback)\n      })\n    },\n    /**\n     * Like put, but for more.\n     *\n     * @param {Array<Block>} blocks\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    putMany (blocks, callback) {\n      const keys = blocks.map((b) => ({\n        key: cidToDsKey(b.cid),\n        block: b\n      }))\n\n      const batch = store.batch()\n      reject(keys, (k, cb) => store.has(k.key, cb), (err, newKeys) => {\n        if (err) {\n          return callback(err)\n        }\n\n        newKeys.forEach((k) => {\n          batch.put(k.key, k.block.data)\n        })\n\n        batch.commit(callback)\n      })\n    },\n    /**\n     * Does the store contain block with this cid?\n     *\n     * @param {CID} cid\n     * @param {function(Error, bool)} callback\n     * @returns {void}\n     */\n    has (cid, callback) {\n      if (!CID.isCID(cid)) {\n        return setImmediate(() => {\n          callback(new Error('Not a valid cid'))\n        })\n      }\n\n      store.has(cidToDsKey(cid), (err, exists) => {\n        if (err) return callback(err)\n        if (exists) return callback(null, true)\n\n        // If not found, we try with the other CID version.\n        const otherCid = cidToOtherVersion(cid)\n        if (!otherCid) return callback(null, false)\n\n        store.has(cidToDsKey(otherCid), callback)\n      })\n    },\n    /**\n     * Delete a block from the store\n     *\n     * @param {CID} cid\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    delete (cid, callback) {\n      if (!CID.isCID(cid)) {\n        return setImmediate(() => {\n          callback(new Error('Not a valid cid'))\n        })\n      }\n\n      store.delete(cidToDsKey(cid), callback)\n    },\n\n    close (callback) {\n      store.close(callback)\n    }\n  }\n}\n\nfunction cidToOtherVersion (cid) {\n  try {\n    return cid.version === 0 ? cid.toV1() : cid.toV0()\n  } catch (err) {\n    return null\n  }\n}\n"]},"metadata":{},"sourceType":"script"}