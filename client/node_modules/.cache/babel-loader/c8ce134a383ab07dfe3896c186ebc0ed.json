{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar KBucket = require('k-bucket');\n\nvar utils = require('./utils');\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrival for peers.\n */\n\n\nvar RoutingTable = /*#__PURE__*/function () {\n  /**\n   * @param {PeerId} self\n   * @param {number} kBucketSize\n   */\n  function RoutingTable(self, kBucketSize) {\n    var _this = this;\n\n    _classCallCheck(this, RoutingTable);\n\n    this.self = self;\n    this._onPing = this._onPing.bind(this);\n    utils.convertPeerId(self, function (err, selfKey) {\n      if (err) {\n        throw err;\n      }\n\n      _this.kb = new KBucket({\n        localNodeId: selfKey,\n        numberOfNodesPerKBucket: kBucketSize,\n        numberOfNodesToPing: 1\n      });\n\n      _this.kb.on('ping', _this._onPing);\n    });\n  } // -- Private Methods\n\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without acutally pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {Array<Object>} oldContacts\n   * @param {Object} newContact\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _createClass(RoutingTable, [{\n    key: \"_onPing\",\n    value: function _onPing(oldContacts, newContact) {\n      // just use the first one (k-bucket sorts from oldest to newest)\n      var oldest = oldContacts[0]; // remove the oldest one\n\n      this.kb.remove(oldest.id); // add the new one\n\n      this.kb.add(newContact);\n    } // -- Public Interface\n\n    /**\n     * Amount of currently stored peers.\n     *\n     * @type {number}\n     */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.kb.count();\n    }\n    /**\n     * Find a specific peer by id.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error, PeerId)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(peer, callback) {\n      var _this2 = this;\n\n      utils.convertPeerId(peer, function (err, key) {\n        if (err) {\n          return callback(err);\n        }\n\n        var closest = _this2.closestPeer(key);\n\n        if (closest && closest.isEqual(peer)) {\n          return callback(null, closest);\n        }\n\n        callback();\n      });\n    }\n    /**\n     * Retrieve the closest peers to the given key.\n     *\n     * @param {Buffer} key\n     * @param {number} count\n     * @returns {PeerId|undefined}\n     */\n\n  }, {\n    key: \"closestPeer\",\n    value: function closestPeer(key, count) {\n      var res = this.closestPeers(key, 1);\n\n      if (res.length > 0) {\n        return res[0];\n      }\n    }\n    /**\n     * Retrieve the `count`-closest peers to the given key.\n     *\n     * @param {Buffer} key\n     * @param {number} count\n     * @returns {Array<PeerId>}\n     */\n\n  }, {\n    key: \"closestPeers\",\n    value: function closestPeers(key, count) {\n      return this.kb.closest(key, count).map(function (p) {\n        return p.peer;\n      });\n    }\n    /**\n     * Add or update the routing table with the given peer.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(peer, callback) {\n      var _this3 = this;\n\n      utils.convertPeerId(peer, function (err, id) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this3.kb.add({\n          id: id,\n          peer: peer\n        });\n\n        callback();\n      });\n    }\n    /**\n     * Remove a given peer from the table.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(peer, callback) {\n      var _this4 = this;\n\n      utils.convertPeerId(peer, function (err, id) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this4.kb.remove(id);\n\n        callback();\n      });\n    }\n  }]);\n\n  return RoutingTable;\n}();\n\nmodule.exports = RoutingTable;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/libp2p-kad-dht/src/routing.js"],"names":["KBucket","require","utils","RoutingTable","self","kBucketSize","_onPing","bind","convertPeerId","err","selfKey","kb","localNodeId","numberOfNodesPerKBucket","numberOfNodesToPing","on","oldContacts","newContact","oldest","remove","id","add","count","peer","callback","key","closest","closestPeer","isEqual","res","closestPeers","length","map","p","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst KBucket = require('k-bucket')\n\nconst utils = require('./utils')\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrival for peers.\n */\nclass RoutingTable {\n  /**\n   * @param {PeerId} self\n   * @param {number} kBucketSize\n   */\n  constructor (self, kBucketSize) {\n    this.self = self\n    this._onPing = this._onPing.bind(this)\n\n    utils.convertPeerId(self, (err, selfKey) => {\n      if (err) {\n        throw err\n      }\n\n      this.kb = new KBucket({\n        localNodeId: selfKey,\n        numberOfNodesPerKBucket: kBucketSize,\n        numberOfNodesToPing: 1\n      })\n\n      this.kb.on('ping', this._onPing)\n    })\n  }\n\n  // -- Private Methods\n\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without acutally pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {Array<Object>} oldContacts\n   * @param {Object} newContact\n   * @returns {undefined}\n   * @private\n   */\n  _onPing (oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0]\n\n    // remove the oldest one\n    this.kb.remove(oldest.id)\n\n    // add the new one\n    this.kb.add(newContact)\n  }\n\n  // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   *\n   * @type {number}\n   */\n  get size () {\n    return this.kb.count()\n  }\n\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PeerId)} callback\n   * @returns {void}\n   */\n  find (peer, callback) {\n    utils.convertPeerId(peer, (err, key) => {\n      if (err) {\n        return callback(err)\n      }\n      const closest = this.closestPeer(key)\n\n      if (closest && closest.isEqual(peer)) {\n        return callback(null, closest)\n      }\n\n      callback()\n    })\n  }\n\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Buffer} key\n   * @param {number} count\n   * @returns {PeerId|undefined}\n   */\n  closestPeer (key, count) {\n    const res = this.closestPeers(key, 1)\n    if (res.length > 0) {\n      return res[0]\n    }\n  }\n\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Buffer} key\n   * @param {number} count\n   * @returns {Array<PeerId>}\n   */\n  closestPeers (key, count) {\n    return this.kb.closest(key, count).map((p) => p.peer)\n  }\n\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   */\n  add (peer, callback) {\n    utils.convertPeerId(peer, (err, id) => {\n      if (err) {\n        return callback(err)\n      }\n      this.kb.add({ id: id, peer: peer })\n      callback()\n    })\n  }\n\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   */\n  remove (peer, callback) {\n    utils.convertPeerId(peer, (err, id) => {\n      if (err) {\n        return callback(err)\n      }\n      this.kb.remove(id)\n      callback()\n    })\n  }\n}\n\nmodule.exports = RoutingTable\n"]},"metadata":{},"sourceType":"script"}