{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar identify = require('libp2p-identify');\n\nvar multistream = require('multistream-select');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:conn-manager');\n\nvar once = require('once');\n\nvar ConnectionFSM = require('../connection');\n\nvar _require = require('../utils'),\n    msHandle = _require.msHandle,\n    msSelect = _require.msSelect,\n    identifyDialer = _require.identifyDialer;\n\nvar Circuit = require('libp2p-circuit');\n\nvar plaintext = require('../plaintext');\n/**\n * Contains methods for binding handlers to the Switch\n * in order to better manage its connections.\n */\n\n\nvar ConnectionManager = /*#__PURE__*/function () {\n  function ConnectionManager(_switch) {\n    _classCallCheck(this, ConnectionManager);\n\n    this.switch = _switch;\n    this.connections = {};\n  }\n  /**\n   * Adds the connection for tracking if it's not already added\n   * @private\n   * @param {ConnectionFSM} connection\n   * @returns {void}\n   */\n\n\n  _createClass(ConnectionManager, [{\n    key: \"add\",\n    value: function add(connection) {\n      var _this = this;\n\n      this.connections[connection.theirB58Id] = this.connections[connection.theirB58Id] || []; // Only add it if it's not there\n\n      if (!this.get(connection)) {\n        this.connections[connection.theirB58Id].push(connection);\n        this.switch.emit('connection:start', connection.theirPeerInfo);\n\n        if (connection.getState() === 'MUXED') {\n          this.switch.emit('peer-mux-established', connection.theirPeerInfo); // Clear the blacklist of the peer\n\n          this.switch.dialer.clearBlacklist(connection.theirPeerInfo);\n        } else {\n          connection.once('muxed', function () {\n            _this.switch.emit('peer-mux-established', connection.theirPeerInfo); // Clear the blacklist of the peer\n\n\n            _this.switch.dialer.clearBlacklist(connection.theirPeerInfo);\n          });\n        }\n      }\n    }\n    /**\n     * Gets the connection from the list if it exists\n     * @private\n     * @param {ConnectionFSM} connection\n     * @returns {ConnectionFSM|null} The found connection or null\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(connection) {\n      if (!this.connections[connection.theirB58Id]) return null;\n\n      for (var i = 0; i < this.connections[connection.theirB58Id].length; i++) {\n        if (this.connections[connection.theirB58Id][i] === connection) {\n          return this.connections[connection.theirB58Id][i];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a connection associated with the given peer\n     * @private\n     * @param {string} peerId The peers id\n     * @returns {ConnectionFSM|null} The found connection or null\n     */\n\n  }, {\n    key: \"getOne\",\n    value: function getOne(peerId) {\n      if (this.connections[peerId]) {\n        // Only return muxed connections\n        for (var i = 0; i < this.connections[peerId].length; i++) {\n          if (this.connections[peerId][i].getState() === 'MUXED') {\n            return this.connections[peerId][i];\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Removes the connection from tracking\n     * @private\n     * @param {ConnectionFSM} connection The connection to remove\n     * @returns {void}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(connection) {\n      // No record of the peer, disconnect it\n      if (!this.connections[connection.theirB58Id]) {\n        if (connection.theirPeerInfo) {\n          connection.theirPeerInfo.disconnect();\n          this.switch.emit('peer-mux-closed', connection.theirPeerInfo);\n        }\n\n        return;\n      }\n\n      for (var i = 0; i < this.connections[connection.theirB58Id].length; i++) {\n        if (this.connections[connection.theirB58Id][i] === connection) {\n          this.connections[connection.theirB58Id].splice(i, 1);\n          break;\n        }\n      } // The peer is fully disconnected\n\n\n      if (this.connections[connection.theirB58Id].length === 0) {\n        delete this.connections[connection.theirB58Id];\n        connection.theirPeerInfo.disconnect();\n        this.switch.emit('peer-mux-closed', connection.theirPeerInfo);\n      } // A tracked connection was closed, let the world know\n\n\n      this.switch.emit('connection:end', connection.theirPeerInfo);\n    }\n    /**\n     * Returns all connections being tracked\n     * @private\n     * @returns {ConnectionFSM[]}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var connections = [];\n\n      for (var _i = 0, _Object$values = Object.values(this.connections); _i < _Object$values.length; _i++) {\n        var conns = _Object$values[_i];\n        connections = [].concat(_toConsumableArray(connections), _toConsumableArray(conns));\n      }\n\n      return connections;\n    }\n    /**\n     * Returns all connections being tracked for a given peer id\n     * @private\n     * @param {string} peerId Stringified peer id\n     * @returns {ConnectionFSM[]}\n     */\n\n  }, {\n    key: \"getAllById\",\n    value: function getAllById(peerId) {\n      return this.connections[peerId] || [];\n    }\n    /**\n     * Adds a listener for the given `muxer` and creates a handler for it\n     * leveraging the Switch.protocolMuxer handler factory\n     *\n     * @param {Muxer} muxer\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addStreamMuxer\",\n    value: function addStreamMuxer(muxer) {\n      var _this2 = this;\n\n      // for dialing\n      this.switch.muxers[muxer.multicodec] = muxer; // for listening\n\n      this.switch.handle(muxer.multicodec, function (protocol, conn) {\n        var muxedConn = muxer.listener(conn);\n        muxedConn.on('stream', _this2.switch.protocolMuxer(null)); // If identify is enabled\n        //   1. overload getPeerInfo\n        //   2. call getPeerInfo\n        //   3. add this conn to the pool\n\n        if (_this2.switch.identify) {\n          // Get the peer info from the crypto exchange\n          conn.getPeerInfo(function (err, cryptoPI) {\n            if (err || !cryptoPI) {\n              log('crypto peerInfo wasnt found');\n            } // overload peerInfo to use Identify instead\n\n\n            conn.getPeerInfo = /*#__PURE__*/function () {\n              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(callback) {\n                var conn, ms, results, msConn, _results, peerInfo;\n\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        conn = muxedConn.newStream();\n                        ms = new multistream.Dialer();\n                        callback = once(callback);\n                        _context.prev = 3;\n                        _context.next = 6;\n                        return msHandle(ms, conn);\n\n                      case 6:\n                        _context.next = 8;\n                        return msSelect(ms, identify.multicodec);\n\n                      case 8:\n                        msConn = _context.sent;\n                        _context.next = 11;\n                        return identifyDialer(msConn, cryptoPI);\n\n                      case 11:\n                        results = _context.sent;\n                        _context.next = 17;\n                        break;\n\n                      case 14:\n                        _context.prev = 14;\n                        _context.t0 = _context[\"catch\"](3);\n                        return _context.abrupt(\"return\", muxedConn.end(function () {\n                          callback(_context.t0, null);\n                        }));\n\n                      case 17:\n                        _results = results, peerInfo = _results.peerInfo;\n\n                        if (peerInfo) {\n                          conn.setPeerInfo(peerInfo);\n                        }\n\n                        callback(null, peerInfo);\n\n                      case 20:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[3, 14]]);\n              }));\n\n              return function (_x) {\n                return _ref.apply(this, arguments);\n              };\n            }();\n\n            conn.getPeerInfo(function (err, peerInfo) {\n              /* eslint no-warning-comments: off */\n              if (err) {\n                return log('identify not successful');\n              }\n\n              var b58Str = peerInfo.id.toB58String();\n              peerInfo = _this2.switch._peerBook.put(peerInfo);\n              var connection = new ConnectionFSM({\n                _switch: _this2.switch,\n                peerInfo: peerInfo,\n                muxer: muxedConn,\n                conn: conn,\n                type: 'inc'\n              });\n\n              _this2.switch.connection.add(connection); // Only update if it's not already connected\n\n\n              if (!peerInfo.isConnected()) {\n                if (peerInfo.multiaddrs.size > 0) {\n                  // with incomming conn and through identify, going to pick one\n                  // of the available multiaddrs from the other peer as the one\n                  // I'm connected to as we really can't be sure at the moment\n                  // TODO add this consideration to the connection abstraction!\n                  peerInfo.connect(peerInfo.multiaddrs.toArray()[0]);\n                } else {\n                  // for the case of websockets in the browser, where peers have\n                  // no addr, use just their IPFS id\n                  peerInfo.connect(\"/ipfs/\".concat(b58Str));\n                }\n              }\n\n              muxedConn.once('close', function () {\n                connection.close();\n              });\n            });\n          });\n        }\n\n        return conn;\n      });\n    }\n    /**\n     * Adds the `encrypt` handler for the given `tag` and also sets the\n     * Switch's crypto to passed `encrypt` function\n     *\n     * @param {String} tag\n     * @param {function(PeerID, Connection, PeerId, Callback)} encrypt\n     * @returns {void}\n     */\n\n  }, {\n    key: \"crypto\",\n    value: function crypto(tag, encrypt) {\n      if (!tag && !encrypt) {\n        tag = plaintext.tag;\n        encrypt = plaintext.encrypt;\n      }\n\n      this.switch.crypto = {\n        tag: tag,\n        encrypt: encrypt\n      };\n    }\n    /**\n     * If config.enabled is true, a Circuit relay will be added to the\n     * available Switch transports.\n     *\n     * @param {any} config\n     * @returns {void}\n     */\n\n  }, {\n    key: \"enableCircuitRelay\",\n    value: function enableCircuitRelay(config) {\n      config = config || {};\n\n      if (config.enabled) {\n        if (!config.hop) {\n          Object.assign(config, {\n            hop: {\n              enabled: false,\n              active: false\n            }\n          });\n        }\n\n        this.switch.transport.add(Circuit.tag, new Circuit(this.switch, config));\n      }\n    }\n    /**\n     * Sets identify to true on the Switch and performs handshakes\n     * for libp2p-identify leveraging the Switch's muxer.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"reuse\",\n    value: function reuse() {\n      var _this3 = this;\n\n      this.switch.identify = true;\n      this.switch.handle(identify.multicodec, function (protocol, conn) {\n        identify.listener(conn, _this3.switch._peerInfo);\n      });\n    }\n  }]);\n\n  return ConnectionManager;\n}();\n\nmodule.exports = ConnectionManager;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-switch/src/connection/manager.js"],"names":["identify","require","multistream","debug","log","once","ConnectionFSM","msHandle","msSelect","identifyDialer","Circuit","plaintext","ConnectionManager","_switch","switch","connections","connection","theirB58Id","get","push","emit","theirPeerInfo","getState","dialer","clearBlacklist","i","length","peerId","disconnect","splice","Object","values","conns","muxer","muxers","multicodec","handle","protocol","conn","muxedConn","listener","on","protocolMuxer","getPeerInfo","err","cryptoPI","callback","newStream","ms","Dialer","msConn","results","end","peerInfo","setPeerInfo","b58Str","id","toB58String","_peerBook","put","type","add","isConnected","multiaddrs","size","connect","toArray","close","tag","encrypt","crypto","config","enabled","hop","assign","active","transport","_peerInfo","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst identify = require('libp2p-identify')\nconst multistream = require('multistream-select')\nconst debug = require('debug')\nconst log = debug('libp2p:switch:conn-manager')\nconst once = require('once')\nconst ConnectionFSM = require('../connection')\nconst { msHandle, msSelect, identifyDialer } = require('../utils')\n\nconst Circuit = require('libp2p-circuit')\n\nconst plaintext = require('../plaintext')\n\n/**\n * Contains methods for binding handlers to the Switch\n * in order to better manage its connections.\n */\nclass ConnectionManager {\n  constructor (_switch) {\n    this.switch = _switch\n    this.connections = {}\n  }\n\n  /**\n   * Adds the connection for tracking if it's not already added\n   * @private\n   * @param {ConnectionFSM} connection\n   * @returns {void}\n   */\n  add (connection) {\n    this.connections[connection.theirB58Id] = this.connections[connection.theirB58Id] || []\n    // Only add it if it's not there\n    if (!this.get(connection)) {\n      this.connections[connection.theirB58Id].push(connection)\n      this.switch.emit('connection:start', connection.theirPeerInfo)\n      if (connection.getState() === 'MUXED') {\n        this.switch.emit('peer-mux-established', connection.theirPeerInfo)\n        // Clear the blacklist of the peer\n        this.switch.dialer.clearBlacklist(connection.theirPeerInfo)\n      } else {\n        connection.once('muxed', () => {\n          this.switch.emit('peer-mux-established', connection.theirPeerInfo)\n          // Clear the blacklist of the peer\n          this.switch.dialer.clearBlacklist(connection.theirPeerInfo)\n        })\n      }\n    }\n  }\n\n  /**\n   * Gets the connection from the list if it exists\n   * @private\n   * @param {ConnectionFSM} connection\n   * @returns {ConnectionFSM|null} The found connection or null\n   */\n  get (connection) {\n    if (!this.connections[connection.theirB58Id]) return null\n\n    for (let i = 0; i < this.connections[connection.theirB58Id].length; i++) {\n      if (this.connections[connection.theirB58Id][i] === connection) {\n        return this.connections[connection.theirB58Id][i]\n      }\n    }\n    return null\n  }\n\n  /**\n   * Gets a connection associated with the given peer\n   * @private\n   * @param {string} peerId The peers id\n   * @returns {ConnectionFSM|null} The found connection or null\n   */\n  getOne (peerId) {\n    if (this.connections[peerId]) {\n      // Only return muxed connections\n      for (var i = 0; i < this.connections[peerId].length; i++) {\n        if (this.connections[peerId][i].getState() === 'MUXED') {\n          return this.connections[peerId][i]\n        }\n      }\n    }\n    return null\n  }\n\n  /**\n   * Removes the connection from tracking\n   * @private\n   * @param {ConnectionFSM} connection The connection to remove\n   * @returns {void}\n   */\n  remove (connection) {\n    // No record of the peer, disconnect it\n    if (!this.connections[connection.theirB58Id]) {\n      if (connection.theirPeerInfo) {\n        connection.theirPeerInfo.disconnect()\n        this.switch.emit('peer-mux-closed', connection.theirPeerInfo)\n      }\n      return\n    }\n\n    for (let i = 0; i < this.connections[connection.theirB58Id].length; i++) {\n      if (this.connections[connection.theirB58Id][i] === connection) {\n        this.connections[connection.theirB58Id].splice(i, 1)\n        break\n      }\n    }\n\n    // The peer is fully disconnected\n    if (this.connections[connection.theirB58Id].length === 0) {\n      delete this.connections[connection.theirB58Id]\n      connection.theirPeerInfo.disconnect()\n      this.switch.emit('peer-mux-closed', connection.theirPeerInfo)\n    }\n\n    // A tracked connection was closed, let the world know\n    this.switch.emit('connection:end', connection.theirPeerInfo)\n  }\n\n  /**\n   * Returns all connections being tracked\n   * @private\n   * @returns {ConnectionFSM[]}\n   */\n  getAll () {\n    let connections = []\n    for (const conns of Object.values(this.connections)) {\n      connections = [...connections, ...conns]\n    }\n    return connections\n  }\n\n  /**\n   * Returns all connections being tracked for a given peer id\n   * @private\n   * @param {string} peerId Stringified peer id\n   * @returns {ConnectionFSM[]}\n   */\n  getAllById (peerId) {\n    return this.connections[peerId] || []\n  }\n\n  /**\n   * Adds a listener for the given `muxer` and creates a handler for it\n   * leveraging the Switch.protocolMuxer handler factory\n   *\n   * @param {Muxer} muxer\n   * @returns {void}\n   */\n  addStreamMuxer (muxer) {\n    // for dialing\n    this.switch.muxers[muxer.multicodec] = muxer\n\n    // for listening\n    this.switch.handle(muxer.multicodec, (protocol, conn) => {\n      const muxedConn = muxer.listener(conn)\n\n      muxedConn.on('stream', this.switch.protocolMuxer(null))\n\n      // If identify is enabled\n      //   1. overload getPeerInfo\n      //   2. call getPeerInfo\n      //   3. add this conn to the pool\n      if (this.switch.identify) {\n        // Get the peer info from the crypto exchange\n        conn.getPeerInfo((err, cryptoPI) => {\n          if (err || !cryptoPI) {\n            log('crypto peerInfo wasnt found')\n          }\n\n          // overload peerInfo to use Identify instead\n          conn.getPeerInfo = async (callback) => {\n            const conn = muxedConn.newStream()\n            const ms = new multistream.Dialer()\n            callback = once(callback)\n\n            let results\n            try {\n              await msHandle(ms, conn)\n              const msConn = await msSelect(ms, identify.multicodec)\n              results = await identifyDialer(msConn, cryptoPI)\n            } catch (err) {\n              return muxedConn.end(() => {\n                callback(err, null)\n              })\n            }\n\n            const { peerInfo } = results\n\n            if (peerInfo) {\n              conn.setPeerInfo(peerInfo)\n            }\n            callback(null, peerInfo)\n          }\n\n          conn.getPeerInfo((err, peerInfo) => {\n            /* eslint no-warning-comments: off */\n            if (err) {\n              return log('identify not successful')\n            }\n            const b58Str = peerInfo.id.toB58String()\n            peerInfo = this.switch._peerBook.put(peerInfo)\n\n            const connection = new ConnectionFSM({\n              _switch: this.switch,\n              peerInfo,\n              muxer: muxedConn,\n              conn: conn,\n              type: 'inc'\n            })\n            this.switch.connection.add(connection)\n\n            // Only update if it's not already connected\n            if (!peerInfo.isConnected()) {\n              if (peerInfo.multiaddrs.size > 0) {\n                // with incomming conn and through identify, going to pick one\n                // of the available multiaddrs from the other peer as the one\n                // I'm connected to as we really can't be sure at the moment\n                // TODO add this consideration to the connection abstraction!\n                peerInfo.connect(peerInfo.multiaddrs.toArray()[0])\n              } else {\n                // for the case of websockets in the browser, where peers have\n                // no addr, use just their IPFS id\n                peerInfo.connect(`/ipfs/${b58Str}`)\n              }\n            }\n\n            muxedConn.once('close', () => {\n              connection.close()\n            })\n          })\n        })\n      }\n\n      return conn\n    })\n  }\n\n  /**\n   * Adds the `encrypt` handler for the given `tag` and also sets the\n   * Switch's crypto to passed `encrypt` function\n   *\n   * @param {String} tag\n   * @param {function(PeerID, Connection, PeerId, Callback)} encrypt\n   * @returns {void}\n   */\n  crypto (tag, encrypt) {\n    if (!tag && !encrypt) {\n      tag = plaintext.tag\n      encrypt = plaintext.encrypt\n    }\n\n    this.switch.crypto = { tag, encrypt }\n  }\n\n  /**\n   * If config.enabled is true, a Circuit relay will be added to the\n   * available Switch transports.\n   *\n   * @param {any} config\n   * @returns {void}\n   */\n  enableCircuitRelay (config) {\n    config = config || {}\n\n    if (config.enabled) {\n      if (!config.hop) {\n        Object.assign(config, { hop: { enabled: false, active: false } })\n      }\n\n      this.switch.transport.add(Circuit.tag, new Circuit(this.switch, config))\n    }\n  }\n\n  /**\n   * Sets identify to true on the Switch and performs handshakes\n   * for libp2p-identify leveraging the Switch's muxer.\n   *\n   * @returns {void}\n   */\n  reuse () {\n    this.switch.identify = true\n    this.switch.handle(identify.multicodec, (protocol, conn) => {\n      identify.listener(conn, this.switch._peerInfo)\n    })\n  }\n}\n\nmodule.exports = ConnectionManager\n"]},"metadata":{},"sourceType":"script"}