{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar pull = require('pull-stream/pull');\n\nvar debug = require('debug');\n\nvar PeerInfo = require('peer-info');\n\nvar PeerId = require('peer-id');\n\nvar EE = require('events').EventEmitter;\n\nvar once = require('once');\n\nvar utilsFactory = require('./utils');\n\nvar StreamHandler = require('./stream-handler');\n\nvar proto = require('../protocol').CircuitRelay;\n\nvar multiaddr = require('multiaddr');\n\nvar series = require('async/series');\n\nvar waterfall = require('async/waterfall');\n\nvar setImmediate = require('async/setImmediate');\n\nvar multicodec = require('./../multicodec');\n\nvar log = debug('libp2p:circuit:relay');\nlog.err = debug('libp2p:circuit:error:relay');\n\nvar Hop = /*#__PURE__*/function (_EE) {\n  _inherits(Hop, _EE);\n\n  var _super = _createSuper(Hop);\n\n  /**\n   * Construct a Circuit object\n   *\n   * This class will handle incoming circuit connections and\n   * either start a relay or hand the relayed connection to\n   * the swarm\n   *\n   * @param {Swarm} swarm\n   * @param {Object} options\n   */\n  function Hop(swarm, options) {\n    var _this;\n\n    _classCallCheck(this, Hop);\n\n    _this = _super.call(this);\n    _this.swarm = swarm;\n    _this.peerInfo = _this.swarm._peerInfo;\n    _this.utils = utilsFactory(swarm);\n    _this.config = options || {\n      active: false,\n      enabled: false\n    };\n    _this.active = _this.config.active;\n    return _this;\n  }\n  /**\n   * Handle the relay message\n   *\n   * @param {CircuitRelay} message\n   * @param {StreamHandler} sh\n   * @returns {*}\n   */\n\n\n  _createClass(Hop, [{\n    key: \"handle\",\n    value: function handle(message, sh) {\n      var _this2 = this;\n\n      if (!this.config.enabled) {\n        this.utils.writeResponse(sh, proto.Status.HOP_CANT_SPEAK_RELAY);\n        return sh.close();\n      } // check if message is `CAN_HOP`\n\n\n      if (message.type === proto.Type.CAN_HOP) {\n        this.utils.writeResponse(sh, proto.Status.SUCCESS);\n        return sh.close();\n      } // This is a relay request - validate and create a circuit\n\n\n      var srcPeerId = null;\n      var dstPeerId = null;\n\n      try {\n        srcPeerId = PeerId.createFromBytes(message.srcPeer.id).toB58String();\n        dstPeerId = PeerId.createFromBytes(message.dstPeer.id).toB58String();\n      } catch (err) {\n        log.err(err);\n\n        if (!srcPeerId) {\n          this.utils.writeResponse(sh, proto.Status.HOP_SRC_MULTIADDR_INVALID);\n          return sh.close();\n        }\n\n        if (!dstPeerId) {\n          this.utils.writeResponse(sh, proto.Status.HOP_DST_MULTIADDR_INVALID);\n          return sh.close();\n        }\n      }\n\n      if (srcPeerId === dstPeerId) {\n        this.utils.writeResponse(sh, proto.Status.HOP_CANT_RELAY_TO_SELF);\n        return sh.close();\n      }\n\n      if (!message.dstPeer.addrs.length) {\n        // TODO: use encapsulate here\n        var addr = multiaddr(\"/p2p-circuit/ipfs/\".concat(dstPeerId)).buffer;\n        message.dstPeer.addrs.push(addr);\n      }\n\n      log('trying to establish a circuit: %s <-> %s', srcPeerId, dstPeerId);\n\n      var noPeer = function noPeer() {\n        // log.err(err)\n        _this2.utils.writeResponse(sh, proto.Status.HOP_NO_CONN_TO_DST);\n\n        return sh.close();\n      };\n\n      var isConnected = function isConnected(cb) {\n        var dstPeer;\n\n        try {\n          dstPeer = _this2.swarm._peerBook.get(dstPeerId);\n\n          if (!dstPeer.isConnected() && !_this2.active) {\n            var err = new Error(\"No Connection to peer \".concat(dstPeerId));\n            noPeer(err);\n            return cb(err);\n          }\n        } catch (err) {\n          if (!_this2.active) {\n            noPeer(err);\n            return cb(err);\n          }\n        }\n\n        cb();\n      };\n\n      series([function (cb) {\n        return _this2.utils.validateAddrs(message, sh, proto.Type.HOP, cb);\n      }, function (cb) {\n        return isConnected(cb);\n      }, function (cb) {\n        return _this2._circuit(sh, message, cb);\n      }], function (err) {\n        if (err) {\n          log.err(err);\n          sh.close();\n          return setImmediate(function () {\n            return _this2.emit('circuit:error', err);\n          });\n        }\n\n        setImmediate(function () {\n          return _this2.emit('circuit:success');\n        });\n      });\n    }\n    /**\n     * Connect to STOP\n     *\n     * @param {PeerInfo} peer\n     * @param {StreamHandler} srcSh\n     * @param {function} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_connectToStop\",\n    value: function _connectToStop(peer, srcSh, callback) {\n      var _this3 = this;\n\n      this._dialPeer(peer, function (err, dstConn) {\n        if (err) {\n          _this3.utils.writeResponse(srcSh, proto.Status.HOP_CANT_DIAL_DST);\n\n          log.err(err);\n          return callback(err);\n        }\n\n        return _this3.utils.writeResponse(srcSh, proto.Status.SUCCESS, function (err) {\n          if (err) {\n            log.err(err);\n            return callback(err);\n          }\n\n          return callback(null, dstConn);\n        });\n      });\n    }\n    /**\n     * Negotiate STOP\n     *\n     * @param {StreamHandler} dstSh\n     * @param {StreamHandler} srcSh\n     * @param {CircuitRelay} message\n     * @param {function} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_negotiateStop\",\n    value: function _negotiateStop(dstSh, srcSh, message, callback) {\n      var _this4 = this;\n\n      var stopMsg = Object.assign({}, message, {\n        type: proto.Type.STOP // change the message type\n\n      });\n      dstSh.write(proto.encode(stopMsg), function (err) {\n        if (err) {\n          _this4.utils.writeResponse(srcSh, proto.Status.HOP_CANT_OPEN_DST_STREAM);\n\n          log.err(err);\n          return callback(err);\n        } // read response from STOP\n\n\n        dstSh.read(function (err, msg) {\n          if (err) {\n            log.err(err);\n            return callback(err);\n          }\n\n          var message = proto.decode(msg);\n\n          if (message.code !== proto.Status.SUCCESS) {\n            return callback(new Error(\"Unable to create circuit!\"));\n          }\n\n          return callback(null, msg);\n        });\n      });\n    }\n    /**\n     * Attempt to make a circuit from A <-> R <-> B where R is this relay\n     *\n     * @param {StreamHandler} srcSh - the source stream handler\n     * @param {CircuitRelay} message - the message with the src and dst entries\n     * @param {Function} callback - callback to signal success or failure\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_circuit\",\n    value: function _circuit(srcSh, message, callback) {\n      var _this5 = this;\n\n      var dstSh = null;\n      waterfall([function (cb) {\n        return _this5._connectToStop(message.dstPeer, srcSh, cb);\n      }, function (_dstConn, cb) {\n        dstSh = new StreamHandler(_dstConn);\n\n        _this5._negotiateStop(dstSh, srcSh, message, cb);\n      }], function (err) {\n        if (err) {\n          // close/end the source stream if there was an error\n          if (srcSh) {\n            srcSh.close();\n          }\n\n          if (dstSh) {\n            dstSh.close();\n          }\n\n          return callback(err);\n        }\n\n        var src = srcSh.rest();\n        var dst = dstSh.rest();\n        var srcIdStr = PeerId.createFromBytes(message.srcPeer.id).toB58String();\n        var dstIdStr = PeerId.createFromBytes(message.dstPeer.id).toB58String(); // circuit the src and dst streams\n\n        pull(src, dst, src);\n        log('circuit %s <-> %s established', srcIdStr, dstIdStr);\n        callback();\n      });\n    }\n    /**\n     * Dial the dest peer and create a circuit\n     *\n     * @param {Multiaddr} dstPeer\n     * @param {Function} callback\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(dstPeer, callback) {\n      var peerInfo = new PeerInfo(PeerId.createFromBytes(dstPeer.id));\n      dstPeer.addrs.forEach(function (a) {\n        return peerInfo.multiaddrs.add(a);\n      });\n      this.swarm.dial(peerInfo, multicodec.relay, once(function (err, conn) {\n        if (err) {\n          log.err(err);\n          return callback(err);\n        }\n\n        callback(null, conn);\n      }));\n    }\n  }]);\n\n  return Hop;\n}(EE);\n\nmodule.exports = Hop;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/libp2p-circuit/src/circuit/hop.js"],"names":["pull","require","debug","PeerInfo","PeerId","EE","EventEmitter","once","utilsFactory","StreamHandler","proto","CircuitRelay","multiaddr","series","waterfall","setImmediate","multicodec","log","err","Hop","swarm","options","peerInfo","_peerInfo","utils","config","active","enabled","message","sh","writeResponse","Status","HOP_CANT_SPEAK_RELAY","close","type","Type","CAN_HOP","SUCCESS","srcPeerId","dstPeerId","createFromBytes","srcPeer","id","toB58String","dstPeer","HOP_SRC_MULTIADDR_INVALID","HOP_DST_MULTIADDR_INVALID","HOP_CANT_RELAY_TO_SELF","addrs","length","addr","buffer","push","noPeer","HOP_NO_CONN_TO_DST","isConnected","cb","_peerBook","get","Error","validateAddrs","HOP","_circuit","emit","peer","srcSh","callback","_dialPeer","dstConn","HOP_CANT_DIAL_DST","dstSh","stopMsg","Object","assign","STOP","write","encode","HOP_CANT_OPEN_DST_STREAM","read","msg","decode","code","_connectToStop","_dstConn","_negotiateStop","src","rest","dst","srcIdStr","dstIdStr","forEach","a","multiaddrs","add","dial","relay","conn","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream/pull')\nconst debug = require('debug')\nconst PeerInfo = require('peer-info')\nconst PeerId = require('peer-id')\nconst EE = require('events').EventEmitter\nconst once = require('once')\nconst utilsFactory = require('./utils')\nconst StreamHandler = require('./stream-handler')\nconst proto = require('../protocol').CircuitRelay\nconst multiaddr = require('multiaddr')\nconst series = require('async/series')\nconst waterfall = require('async/waterfall')\nconst setImmediate = require('async/setImmediate')\n\nconst multicodec = require('./../multicodec')\n\nconst log = debug('libp2p:circuit:relay')\nlog.err = debug('libp2p:circuit:error:relay')\n\nclass Hop extends EE {\n  /**\n   * Construct a Circuit object\n   *\n   * This class will handle incoming circuit connections and\n   * either start a relay or hand the relayed connection to\n   * the swarm\n   *\n   * @param {Swarm} swarm\n   * @param {Object} options\n   */\n  constructor (swarm, options) {\n    super()\n    this.swarm = swarm\n    this.peerInfo = this.swarm._peerInfo\n    this.utils = utilsFactory(swarm)\n    this.config = options || { active: false, enabled: false }\n    this.active = this.config.active\n  }\n\n  /**\n   * Handle the relay message\n   *\n   * @param {CircuitRelay} message\n   * @param {StreamHandler} sh\n   * @returns {*}\n   */\n  handle (message, sh) {\n    if (!this.config.enabled) {\n      this.utils.writeResponse(\n        sh,\n        proto.Status.HOP_CANT_SPEAK_RELAY)\n      return sh.close()\n    }\n\n    // check if message is `CAN_HOP`\n    if (message.type === proto.Type.CAN_HOP) {\n      this.utils.writeResponse(\n        sh,\n        proto.Status.SUCCESS)\n      return sh.close()\n    }\n\n    // This is a relay request - validate and create a circuit\n    let srcPeerId = null\n    let dstPeerId = null\n    try {\n      srcPeerId = PeerId.createFromBytes(message.srcPeer.id).toB58String()\n      dstPeerId = PeerId.createFromBytes(message.dstPeer.id).toB58String()\n    } catch (err) {\n      log.err(err)\n\n      if (!srcPeerId) {\n        this.utils.writeResponse(\n          sh,\n          proto.Status.HOP_SRC_MULTIADDR_INVALID)\n        return sh.close()\n      }\n\n      if (!dstPeerId) {\n        this.utils.writeResponse(\n          sh,\n          proto.Status.HOP_DST_MULTIADDR_INVALID)\n        return sh.close()\n      }\n    }\n\n    if (srcPeerId === dstPeerId) {\n      this.utils.writeResponse(\n        sh,\n        proto.Status.HOP_CANT_RELAY_TO_SELF)\n      return sh.close()\n    }\n\n    if (!message.dstPeer.addrs.length) {\n      // TODO: use encapsulate here\n      const addr = multiaddr(`/p2p-circuit/ipfs/${dstPeerId}`).buffer\n      message.dstPeer.addrs.push(addr)\n    }\n\n    log('trying to establish a circuit: %s <-> %s', srcPeerId, dstPeerId)\n    const noPeer = () => {\n      // log.err(err)\n      this.utils.writeResponse(\n        sh,\n        proto.Status.HOP_NO_CONN_TO_DST)\n      return sh.close()\n    }\n\n    const isConnected = (cb) => {\n      let dstPeer\n      try {\n        dstPeer = this.swarm._peerBook.get(dstPeerId)\n        if (!dstPeer.isConnected() && !this.active) {\n          const err = new Error(`No Connection to peer ${dstPeerId}`)\n          noPeer(err)\n          return cb(err)\n        }\n      } catch (err) {\n        if (!this.active) {\n          noPeer(err)\n          return cb(err)\n        }\n      }\n      cb()\n    }\n\n    series([\n      (cb) => this.utils.validateAddrs(message, sh, proto.Type.HOP, cb),\n      (cb) => isConnected(cb),\n      (cb) => this._circuit(sh, message, cb)\n    ], (err) => {\n      if (err) {\n        log.err(err)\n        sh.close()\n        return setImmediate(() => this.emit('circuit:error', err))\n      }\n      setImmediate(() => this.emit('circuit:success'))\n    })\n  }\n\n  /**\n   * Connect to STOP\n   *\n   * @param {PeerInfo} peer\n   * @param {StreamHandler} srcSh\n   * @param {function} callback\n   * @returns {void}\n   */\n  _connectToStop (peer, srcSh, callback) {\n    this._dialPeer(peer, (err, dstConn) => {\n      if (err) {\n        this.utils.writeResponse(\n          srcSh,\n          proto.Status.HOP_CANT_DIAL_DST)\n        log.err(err)\n        return callback(err)\n      }\n\n      return this.utils.writeResponse(\n        srcSh,\n        proto.Status.SUCCESS,\n        (err) => {\n          if (err) {\n            log.err(err)\n            return callback(err)\n          }\n          return callback(null, dstConn)\n        })\n    })\n  }\n\n  /**\n   * Negotiate STOP\n   *\n   * @param {StreamHandler} dstSh\n   * @param {StreamHandler} srcSh\n   * @param {CircuitRelay} message\n   * @param {function} callback\n   * @returns {void}\n   */\n  _negotiateStop (dstSh, srcSh, message, callback) {\n    const stopMsg = Object.assign({}, message, {\n      type: proto.Type.STOP // change the message type\n    })\n    dstSh.write(proto.encode(stopMsg),\n      (err) => {\n        if (err) {\n          this.utils.writeResponse(\n            srcSh,\n            proto.Status.HOP_CANT_OPEN_DST_STREAM)\n          log.err(err)\n          return callback(err)\n        }\n\n        // read response from STOP\n        dstSh.read((err, msg) => {\n          if (err) {\n            log.err(err)\n            return callback(err)\n          }\n\n          const message = proto.decode(msg)\n          if (message.code !== proto.Status.SUCCESS) {\n            return callback(new Error(`Unable to create circuit!`))\n          }\n\n          return callback(null, msg)\n        })\n      })\n  }\n\n  /**\n   * Attempt to make a circuit from A <-> R <-> B where R is this relay\n   *\n   * @param {StreamHandler} srcSh - the source stream handler\n   * @param {CircuitRelay} message - the message with the src and dst entries\n   * @param {Function} callback - callback to signal success or failure\n   * @returns {void}\n   * @private\n   */\n  _circuit (srcSh, message, callback) {\n    let dstSh = null\n    waterfall([\n      (cb) => this._connectToStop(message.dstPeer, srcSh, cb),\n      (_dstConn, cb) => {\n        dstSh = new StreamHandler(_dstConn)\n        this._negotiateStop(dstSh, srcSh, message, cb)\n      }\n    ], (err) => {\n      if (err) {\n        // close/end the source stream if there was an error\n        if (srcSh) {\n          srcSh.close()\n        }\n\n        if (dstSh) {\n          dstSh.close()\n        }\n        return callback(err)\n      }\n\n      const src = srcSh.rest()\n      const dst = dstSh.rest()\n\n      const srcIdStr = PeerId.createFromBytes(message.srcPeer.id).toB58String()\n      const dstIdStr = PeerId.createFromBytes(message.dstPeer.id).toB58String()\n\n      // circuit the src and dst streams\n      pull(\n        src,\n        dst,\n        src\n      )\n      log('circuit %s <-> %s established', srcIdStr, dstIdStr)\n      callback()\n    })\n  }\n\n  /**\n   * Dial the dest peer and create a circuit\n   *\n   * @param {Multiaddr} dstPeer\n   * @param {Function} callback\n   * @returns {void}\n   * @private\n   */\n  _dialPeer (dstPeer, callback) {\n    const peerInfo = new PeerInfo(PeerId.createFromBytes(dstPeer.id))\n    dstPeer.addrs.forEach((a) => peerInfo.multiaddrs.add(a))\n    this.swarm.dial(peerInfo, multicodec.relay, once((err, conn) => {\n      if (err) {\n        log.err(err)\n        return callback(err)\n      }\n\n      callback(null, conn)\n    }))\n  }\n}\n\nmodule.exports = Hop\n"]},"metadata":{},"sourceType":"script"}