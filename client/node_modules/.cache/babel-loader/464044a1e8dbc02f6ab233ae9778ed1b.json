{"ast":null,"code":"'use strict';\n\nvar promisify = require('promisify-es6');\n\nvar OFFLINE_ERROR = require('../utils').OFFLINE_ERROR;\n\nmodule.exports = function swarm(self) {\n  return {\n    peers: promisify(function (opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n\n      opts = opts || {};\n\n      if (!self.isOnline()) {\n        return callback(new Error(OFFLINE_ERROR));\n      }\n\n      var verbose = opts.v || opts.verbose; // TODO: return latency and streams when verbose is set\n      // we currently don't have this information\n\n      var peers = [];\n      Object.values(self._peerInfoBook.getAll()).forEach(function (peer) {\n        var connectedAddr = peer.isConnected();\n\n        if (!connectedAddr) {\n          return;\n        }\n\n        var tupple = {\n          addr: connectedAddr,\n          peer: peer.id\n        };\n\n        if (verbose) {\n          tupple.latency = 'unknown';\n        }\n\n        peers.push(tupple);\n      });\n      callback(null, peers);\n    }),\n    // all the addrs we know\n    addrs: promisify(function (callback) {\n      if (!self.isOnline()) {\n        return callback(new Error(OFFLINE_ERROR));\n      }\n\n      var peers = Object.values(self._peerInfoBook.getAll());\n      callback(null, peers);\n    }),\n    localAddrs: promisify(function (callback) {\n      if (!self.isOnline()) {\n        return callback(new Error(OFFLINE_ERROR));\n      }\n\n      callback(null, self.libp2p.peerInfo.multiaddrs.toArray());\n    }),\n    connect: promisify(function (maddr, callback) {\n      if (!self.isOnline()) {\n        return callback(new Error(OFFLINE_ERROR));\n      }\n\n      self.libp2p.dial(maddr, callback);\n    }),\n    disconnect: promisify(function (maddr, callback) {\n      if (!self.isOnline()) {\n        return callback(new Error(OFFLINE_ERROR));\n      }\n\n      self.libp2p.hangUp(maddr, callback);\n    }),\n    filters: promisify(function (callback) {\n      return callback(new Error('Not implemented'));\n    })\n  };\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs/src/core/components/swarm.js"],"names":["promisify","require","OFFLINE_ERROR","module","exports","swarm","self","peers","opts","callback","isOnline","Error","verbose","v","Object","values","_peerInfoBook","getAll","forEach","peer","connectedAddr","isConnected","tupple","addr","id","latency","push","addrs","localAddrs","libp2p","peerInfo","multiaddrs","toArray","connect","maddr","dial","disconnect","hangUp","filters"],"mappings":"AAAA;;AAEA,IAAMA,SAAS,GAAGC,OAAO,CAAC,eAAD,CAAzB;;AAEA,IAAMC,aAAa,GAAGD,OAAO,CAAC,UAAD,CAAP,CAAoBC,aAA1C;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,KAAT,CAAgBC,IAAhB,EAAsB;AACrC,SAAO;AACLC,IAAAA,KAAK,EAAEP,SAAS,CAAC,UAACQ,IAAD,EAAOC,QAAP,EAAoB;AACnC,UAAI,OAAOD,IAAP,KAAgB,UAApB,EAAgC;AAC9BC,QAAAA,QAAQ,GAAGD,IAAX;AACAA,QAAAA,IAAI,GAAG,EAAP;AACD;;AAEDA,MAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;;AAEA,UAAI,CAACF,IAAI,CAACI,QAAL,EAAL,EAAsB;AACpB,eAAOD,QAAQ,CAAC,IAAIE,KAAJ,CAAUT,aAAV,CAAD,CAAf;AACD;;AAED,UAAMU,OAAO,GAAGJ,IAAI,CAACK,CAAL,IAAUL,IAAI,CAACI,OAA/B,CAZmC,CAanC;AACA;;AAEA,UAAML,KAAK,GAAG,EAAd;AAEAO,MAAAA,MAAM,CAACC,MAAP,CAAcT,IAAI,CAACU,aAAL,CAAmBC,MAAnB,EAAd,EAA2CC,OAA3C,CAAmD,UAACC,IAAD,EAAU;AAC3D,YAAMC,aAAa,GAAGD,IAAI,CAACE,WAAL,EAAtB;;AAEA,YAAI,CAACD,aAAL,EAAoB;AAAE;AAAQ;;AAE9B,YAAME,MAAM,GAAG;AACbC,UAAAA,IAAI,EAAEH,aADO;AAEbD,UAAAA,IAAI,EAAEA,IAAI,CAACK;AAFE,SAAf;;AAIA,YAAIZ,OAAJ,EAAa;AACXU,UAAAA,MAAM,CAACG,OAAP,GAAiB,SAAjB;AACD;;AAEDlB,QAAAA,KAAK,CAACmB,IAAN,CAAWJ,MAAX;AACD,OAdD;AAgBAb,MAAAA,QAAQ,CAAC,IAAD,EAAOF,KAAP,CAAR;AACD,KAnCe,CADX;AAsCL;AACAoB,IAAAA,KAAK,EAAE3B,SAAS,CAAC,UAACS,QAAD,EAAc;AAC7B,UAAI,CAACH,IAAI,CAACI,QAAL,EAAL,EAAsB;AACpB,eAAOD,QAAQ,CAAC,IAAIE,KAAJ,CAAUT,aAAV,CAAD,CAAf;AACD;;AAED,UAAMK,KAAK,GAAGO,MAAM,CAACC,MAAP,CAAcT,IAAI,CAACU,aAAL,CAAmBC,MAAnB,EAAd,CAAd;AAEAR,MAAAA,QAAQ,CAAC,IAAD,EAAOF,KAAP,CAAR;AACD,KARe,CAvCX;AAiDLqB,IAAAA,UAAU,EAAE5B,SAAS,CAAC,UAACS,QAAD,EAAc;AAClC,UAAI,CAACH,IAAI,CAACI,QAAL,EAAL,EAAsB;AACpB,eAAOD,QAAQ,CAAC,IAAIE,KAAJ,CAAUT,aAAV,CAAD,CAAf;AACD;;AAEDO,MAAAA,QAAQ,CAAC,IAAD,EAAOH,IAAI,CAACuB,MAAL,CAAYC,QAAZ,CAAqBC,UAArB,CAAgCC,OAAhC,EAAP,CAAR;AACD,KANoB,CAjDhB;AAyDLC,IAAAA,OAAO,EAAEjC,SAAS,CAAC,UAACkC,KAAD,EAAQzB,QAAR,EAAqB;AACtC,UAAI,CAACH,IAAI,CAACI,QAAL,EAAL,EAAsB;AACpB,eAAOD,QAAQ,CAAC,IAAIE,KAAJ,CAAUT,aAAV,CAAD,CAAf;AACD;;AAEDI,MAAAA,IAAI,CAACuB,MAAL,CAAYM,IAAZ,CAAiBD,KAAjB,EAAwBzB,QAAxB;AACD,KANiB,CAzDb;AAiEL2B,IAAAA,UAAU,EAAEpC,SAAS,CAAC,UAACkC,KAAD,EAAQzB,QAAR,EAAqB;AACzC,UAAI,CAACH,IAAI,CAACI,QAAL,EAAL,EAAsB;AACpB,eAAOD,QAAQ,CAAC,IAAIE,KAAJ,CAAUT,aAAV,CAAD,CAAf;AACD;;AAEDI,MAAAA,IAAI,CAACuB,MAAL,CAAYQ,MAAZ,CAAmBH,KAAnB,EAA0BzB,QAA1B;AACD,KANoB,CAjEhB;AAyEL6B,IAAAA,OAAO,EAAEtC,SAAS,CAAC,UAACS,QAAD;AAAA,aAAcA,QAAQ,CAAC,IAAIE,KAAJ,CAAU,iBAAV,CAAD,CAAtB;AAAA,KAAD;AAzEb,GAAP;AA2ED,CA5ED","sourcesContent":["'use strict'\n\nconst promisify = require('promisify-es6')\n\nconst OFFLINE_ERROR = require('../utils').OFFLINE_ERROR\n\nmodule.exports = function swarm (self) {\n  return {\n    peers: promisify((opts, callback) => {\n      if (typeof opts === 'function') {\n        callback = opts\n        opts = {}\n      }\n\n      opts = opts || {}\n\n      if (!self.isOnline()) {\n        return callback(new Error(OFFLINE_ERROR))\n      }\n\n      const verbose = opts.v || opts.verbose\n      // TODO: return latency and streams when verbose is set\n      // we currently don't have this information\n\n      const peers = []\n\n      Object.values(self._peerInfoBook.getAll()).forEach((peer) => {\n        const connectedAddr = peer.isConnected()\n\n        if (!connectedAddr) { return }\n\n        const tupple = {\n          addr: connectedAddr,\n          peer: peer.id\n        }\n        if (verbose) {\n          tupple.latency = 'unknown'\n        }\n\n        peers.push(tupple)\n      })\n\n      callback(null, peers)\n    }),\n\n    // all the addrs we know\n    addrs: promisify((callback) => {\n      if (!self.isOnline()) {\n        return callback(new Error(OFFLINE_ERROR))\n      }\n\n      const peers = Object.values(self._peerInfoBook.getAll())\n\n      callback(null, peers)\n    }),\n\n    localAddrs: promisify((callback) => {\n      if (!self.isOnline()) {\n        return callback(new Error(OFFLINE_ERROR))\n      }\n\n      callback(null, self.libp2p.peerInfo.multiaddrs.toArray())\n    }),\n\n    connect: promisify((maddr, callback) => {\n      if (!self.isOnline()) {\n        return callback(new Error(OFFLINE_ERROR))\n      }\n\n      self.libp2p.dial(maddr, callback)\n    }),\n\n    disconnect: promisify((maddr, callback) => {\n      if (!self.isOnline()) {\n        return callback(new Error(OFFLINE_ERROR))\n      }\n\n      self.libp2p.hangUp(maddr, callback)\n    }),\n\n    filters: promisify((callback) => callback(new Error('Not implemented')))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}