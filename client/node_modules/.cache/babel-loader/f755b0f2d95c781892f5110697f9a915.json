{"ast":null,"code":"/**\n * Copyright (c) 2016 Tim Kuijsten\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n'use strict';\n\nvar stream = require('stream');\n\nvar xtend = require('xtend');\n/**\n * Iterate over an IndexedDB object store with a readable stream.\n *\n * @param {IDBDatabase} db - IndexedDB instance\n * @param {String} storeName - name of the object store to iterate over\n * @param {Object} [opts]\n *\n * Options:\n * @param {IDBKeyRange} opts.range - a valid IndexedDB key range\n * @param {IDBCursorDirection} opts.direction - one of \"next\", \"nextunique\",\n *   \"prev\", \"prevunique\"\n * @param {Boolean} opts.snapshot=false - Iterate over a snapshot of the database\n *   by opening only one cursor. This disables any form of back pressure to prevent\n *   cursor timeout issues.\n */\n\n\nfunction idbReadableStream(db, storeName, opts) {\n  if (typeof db !== 'object') throw new TypeError('db must be an object');\n  if (typeof storeName !== 'string') throw new TypeError('storeName must be a string');\n  if (opts == null) opts = {};\n  if (typeof opts !== 'object') throw new TypeError('opts must be an object'); // use transform stream for buffering and back pressure\n\n  var transformer = new stream.Transform(xtend(opts, {\n    objectMode: true,\n    transform: function transform(obj, enc, cb) {\n      cb(null, obj);\n    }\n  }));\n  opts = xtend({\n    snapshot: false\n  }, opts);\n  var lastIteratedKey = null;\n  transformer._cursorsOpened = 0;\n\n  function startCursor() {\n    var lower, upper, lowerOpen, upperOpen;\n    var direction = opts.direction || 'next';\n    var range = opts.range || {};\n    lower = range.lower;\n    upper = range.upper;\n    lowerOpen = !!range.lowerOpen;\n    upperOpen = !!range.upperOpen; // if this is not the first iteration, use lastIteratedKey\n\n    if (lastIteratedKey) {\n      if (direction === 'next') {\n        lowerOpen = true; // exclude the last iterated key itself\n\n        lower = lastIteratedKey;\n      } else {\n        upperOpen = true; // exclude the last iterated key itself\n\n        upper = lastIteratedKey;\n      }\n    }\n\n    var keyRange;\n    if (lower && upper) keyRange = IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen);else if (lower) keyRange = IDBKeyRange.lowerBound(lower, lowerOpen);else if (upper) keyRange = IDBKeyRange.upperBound(upper, upperOpen);\n    var tx = db.transaction(storeName, 'readonly');\n    var store = tx.objectStore(storeName);\n    transformer._cursorsOpened++;\n    var req = store.openCursor(keyRange, opts.direction);\n\n    function proceed(cursor) {\n      try {\n        cursor.continue(); // throws a TransactionInactiveError if the cursor timed out\n      } catch (err) {\n        // either reopen a cursor or propagate the error\n        if (err.name === 'TransactionInactiveError' && !opts.snapshot) startCursor(); // IndexedDB timed out the cursor\n        else transformer.emit('error', err);\n      }\n    }\n\n    req.onsuccess = function () {\n      var cursor = req.result;\n\n      if (cursor) {\n        lastIteratedKey = cursor.key;\n        var go = transformer.write({\n          key: cursor.key,\n          value: cursor.value\n        });\n        if (opts.snapshot || go) proceed(cursor);else transformer.once('drain', function () {\n          proceed(cursor);\n        });\n      } else transformer.end();\n    };\n\n    tx.onabort = function () {\n      transformer.emit('error', tx.error);\n    };\n\n    tx.onerror = function () {\n      transformer.emit('error', tx.error);\n    };\n  }\n\n  startCursor();\n  return transformer;\n}\n\nmodule.exports = idbReadableStream;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/idb-readable-stream/index.js"],"names":["stream","require","xtend","idbReadableStream","db","storeName","opts","TypeError","transformer","Transform","objectMode","transform","obj","enc","cb","snapshot","lastIteratedKey","_cursorsOpened","startCursor","lower","upper","lowerOpen","upperOpen","direction","range","keyRange","IDBKeyRange","bound","lowerBound","upperBound","tx","transaction","store","objectStore","req","openCursor","proceed","cursor","continue","err","name","emit","onsuccess","result","key","go","write","value","once","end","onabort","error","onerror","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2016 Tim Kuijsten\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n'use strict'\n\nvar stream = require('stream')\n\nvar xtend = require('xtend')\n\n/**\n * Iterate over an IndexedDB object store with a readable stream.\n *\n * @param {IDBDatabase} db - IndexedDB instance\n * @param {String} storeName - name of the object store to iterate over\n * @param {Object} [opts]\n *\n * Options:\n * @param {IDBKeyRange} opts.range - a valid IndexedDB key range\n * @param {IDBCursorDirection} opts.direction - one of \"next\", \"nextunique\",\n *   \"prev\", \"prevunique\"\n * @param {Boolean} opts.snapshot=false - Iterate over a snapshot of the database\n *   by opening only one cursor. This disables any form of back pressure to prevent\n *   cursor timeout issues.\n */\nfunction idbReadableStream(db, storeName, opts) {\n  if (typeof db !== 'object') throw new TypeError('db must be an object')\n  if (typeof storeName !== 'string') throw new TypeError('storeName must be a string')\n  if (opts == null) opts = {}\n  if (typeof opts !== 'object') throw new TypeError('opts must be an object')\n\n  // use transform stream for buffering and back pressure\n  var transformer = new stream.Transform(xtend(opts, {\n    objectMode: true,\n    transform: function(obj, enc, cb) {\n      cb(null, obj)\n    }\n  }))\n\n  opts = xtend({\n    snapshot: false\n  }, opts)\n\n  var lastIteratedKey = null\n  transformer._cursorsOpened = 0\n\n  function startCursor() {\n    var lower, upper, lowerOpen, upperOpen\n\n    var direction = opts.direction || 'next'\n    var range = opts.range || {}\n\n    lower = range.lower\n    upper = range.upper\n    lowerOpen = !!range.lowerOpen\n    upperOpen = !!range.upperOpen\n\n    // if this is not the first iteration, use lastIteratedKey\n    if (lastIteratedKey) {\n      if (direction === 'next') {\n        lowerOpen = true // exclude the last iterated key itself\n        lower = lastIteratedKey\n      } else {\n        upperOpen = true // exclude the last iterated key itself\n        upper = lastIteratedKey\n      }\n    }\n\n    var keyRange\n    if (lower && upper)\n      keyRange = IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)\n    else if (lower)\n      keyRange = IDBKeyRange.lowerBound(lower, lowerOpen)\n    else if (upper)\n      keyRange = IDBKeyRange.upperBound(upper, upperOpen)\n\n    var tx = db.transaction(storeName, 'readonly')\n    var store = tx.objectStore(storeName)\n\n    transformer._cursorsOpened++\n    var req = store.openCursor(keyRange, opts.direction)\n\n    function proceed(cursor) {\n      try {\n        cursor.continue() // throws a TransactionInactiveError if the cursor timed out\n      } catch(err) {\n        // either reopen a cursor or propagate the error\n        if (err.name === 'TransactionInactiveError' && !opts.snapshot)\n          startCursor() // IndexedDB timed out the cursor\n        else\n          transformer.emit('error', err)\n      }\n    }\n\n    req.onsuccess = function() {\n      var cursor = req.result\n      if (cursor) {\n        lastIteratedKey = cursor.key\n\n        var go = transformer.write({ key: cursor.key, value: cursor.value })\n        if (opts.snapshot || go)\n          proceed(cursor)\n        else\n          transformer.once('drain', function() {\n            proceed(cursor)\n          })\n      } else\n        transformer.end()\n    }\n\n    tx.onabort = function() {\n      transformer.emit('error', tx.error)\n    }\n    tx.onerror = function() {\n      transformer.emit('error', tx.error)\n    }\n  }\n\n  startCursor()\n\n  return transformer\n}\n\nmodule.exports = idbReadableStream\n"]},"metadata":{},"sourceType":"script"}