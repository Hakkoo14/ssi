{"ast":null,"code":"'use strict';\n/* eslint no-warning-comments: off */\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar parallel = require('async/parallel');\n\nvar once = require('once');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:transport');\n\nvar LimitDialer = require('./limit-dialer');\n\nvar _require = require('./constants'),\n    DIAL_TIMEOUT = _require.DIAL_TIMEOUT;\n\nvar _require2 = require('./utils'),\n    uniqueBy = _require2.uniqueBy; // number of concurrent outbound dials to make per peer, same as go-libp2p-swtch\n\n\nvar defaultPerPeerRateLimit = 8;\n/**\n * Manages the transports for the switch. This simplifies dialing and listening across\n * multiple transports.\n */\n\nvar TransportManager = /*#__PURE__*/function () {\n  function TransportManager(_switch) {\n    _classCallCheck(this, TransportManager);\n\n    this.switch = _switch;\n    this.dialer = new LimitDialer(defaultPerPeerRateLimit, this.switch._options.dialTimeout || DIAL_TIMEOUT);\n  }\n  /**\n   * Adds a `Transport` to the list of transports on the switch, and assigns it to the given key\n   *\n   * @param {String} key\n   * @param {Transport} transport\n   * @returns {void}\n   */\n\n\n  _createClass(TransportManager, [{\n    key: \"add\",\n    value: function add(key, transport) {\n      log('adding %s', key);\n\n      if (this.switch.transports[key]) {\n        throw new Error('There is already a transport with this key');\n      }\n\n      this.switch.transports[key] = transport;\n\n      if (!this.switch.transports[key].listeners) {\n        this.switch.transports[key].listeners = [];\n      }\n    }\n    /**\n     * Closes connections for the given transport key\n     * and removes it from the switch.\n     *\n     * @param {String} key\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(key, callback) {\n      var _this = this;\n\n      callback = callback || function () {};\n\n      if (!this.switch.transports[key]) {\n        return callback();\n      }\n\n      this.close(key, function (err) {\n        delete _this.switch.transports[key];\n        callback(err);\n      });\n    }\n    /**\n     * Calls `remove` on each transport the switch has\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"removeAll\",\n    value: function removeAll(callback) {\n      var _this2 = this;\n\n      var tasks = Object.keys(this.switch.transports).map(function (key) {\n        return function (cb) {\n          _this2.remove(key, cb);\n        };\n      });\n      parallel(tasks, callback);\n    }\n    /**\n     * For a given transport `key`, dial to all that transport multiaddrs\n     *\n     * @param {String} key Key of the `Transport` to dial\n     * @param {PeerInfo} peerInfo\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dial\",\n    value: function dial(key, peerInfo, callback) {\n      var transport = this.switch.transports[key];\n      var multiaddrs = peerInfo.multiaddrs.toArray();\n\n      if (!Array.isArray(multiaddrs)) {\n        multiaddrs = [multiaddrs];\n      } // filter the multiaddrs that are actually valid for this transport\n\n\n      multiaddrs = TransportManager.dialables(transport, multiaddrs, this.switch._peerInfo);\n      log('dialing %s', key, multiaddrs.map(function (m) {\n        return m.toString();\n      })); // dial each of the multiaddrs with the given transport\n\n      this.dialer.dialMany(peerInfo.id, transport, multiaddrs, function (errors, success) {\n        if (errors) {\n          return callback(errors);\n        }\n\n        peerInfo.connect(success.multiaddr);\n        callback(null, success.conn);\n      });\n    }\n    /**\n     * For a given Transport `key`, listen on all multiaddrs in the switch's `_peerInfo`.\n     * If a `handler` is not provided, the Switch's `protocolMuxer` will be used.\n     *\n     * @param {String} key\n     * @param {*} _options Currently ignored\n     * @param {function(Connection)} handler\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(key, _options, handler, callback) {\n      var _this3 = this;\n\n      handler = this.switch._connectionHandler(key, handler);\n      var transport = this.switch.transports[key];\n\n      var originalAddrs = this.switch._peerInfo.multiaddrs.toArray(); // Until TCP can handle distinct addresses on listen, https://github.com/libp2p/interface-transport/issues/41,\n      // make sure we aren't trying to listen on duplicate ports. This also applies to websockets.\n\n\n      originalAddrs = uniqueBy(originalAddrs, function (addr) {\n        // Any non 0 port should register as unique\n        var port = Number(addr.toOptions().port);\n        return isNaN(port) || port === 0 ? addr.toString() : port;\n      });\n      var multiaddrs = TransportManager.dialables(transport, originalAddrs);\n\n      if (!transport.listeners) {\n        transport.listeners = [];\n      }\n\n      var freshMultiaddrs = [];\n      var createListeners = multiaddrs.map(function (ma) {\n        return function (cb) {\n          var done = once(cb);\n          var listener = transport.createListener(handler);\n          listener.once('error', done);\n          listener.listen(ma, function (err) {\n            if (err) {\n              return done(err);\n            }\n\n            listener.removeListener('error', done);\n            listener.getAddrs(function (err, addrs) {\n              if (err) {\n                return done(err);\n              }\n\n              freshMultiaddrs = freshMultiaddrs.concat(addrs);\n              transport.listeners.push(listener);\n              done();\n            });\n          });\n        };\n      });\n      parallel(createListeners, function (err) {\n        if (err) {\n          return callback(err);\n        } // cause we can listen on port 0 or 0.0.0.0\n\n\n        _this3.switch._peerInfo.multiaddrs.replace(multiaddrs, freshMultiaddrs);\n\n        callback();\n      });\n    }\n    /**\n     * Closes the transport with the given key, by closing all of its listeners\n     *\n     * @param {String} key\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(key, callback) {\n      var transport = this.switch.transports[key];\n\n      if (!transport) {\n        return callback(new Error(\"Trying to close non existing transport: \".concat(key)));\n      }\n\n      parallel(transport.listeners.map(function (listener) {\n        return function (cb) {\n          listener.close(cb);\n        };\n      }), callback);\n    }\n    /**\n     * For a given transport, return its multiaddrs that match the given multiaddrs\n     *\n     * @param {Transport} transport\n     * @param {Array<Multiaddr>} multiaddrs\n     * @param {PeerInfo} peerInfo Optional - a peer whose addresses should not be returned\n     * @returns {Array<Multiaddr>}\n     */\n\n  }], [{\n    key: \"dialables\",\n    value: function dialables(transport, multiaddrs, peerInfo) {\n      // If we dont have a proper transport, return no multiaddrs\n      if (!transport || !transport.filter) return [];\n      var transportAddrs = transport.filter(multiaddrs);\n\n      if (!peerInfo || !transportAddrs.length) {\n        return transportAddrs;\n      }\n\n      var ourAddrs = ourAddresses(peerInfo);\n      var result = transportAddrs.filter(function (transportAddr) {\n        // If our address is in the destination address, filter it out\n        return !ourAddrs.some(function (a) {\n          return getDestination(transportAddr).startsWith(a);\n        });\n      });\n      return result;\n    }\n  }]);\n\n  return TransportManager;\n}();\n/**\n * Expand addresses in peer info into array of addresses with and without peer\n * ID suffix.\n *\n * @param {PeerInfo} peerInfo Our peer info object\n * @returns {String[]}\n */\n\n\nfunction ourAddresses(peerInfo) {\n  var ourPeerId = peerInfo.id.toB58String();\n  return peerInfo.multiaddrs.toArray().reduce(function (ourAddrs, addr) {\n    var peerId = addr.getPeerId();\n    addr = addr.toString();\n    var otherAddr = peerId ? addr.slice(0, addr.lastIndexOf(\"/ipfs/\".concat(peerId))) : \"\".concat(addr, \"/ipfs/\").concat(ourPeerId);\n    return ourAddrs.concat([addr, otherAddr]);\n  }, []).filter(function (a) {\n    return Boolean(a);\n  }).concat(\"/ipfs/\".concat(ourPeerId));\n}\n\nvar RelayProtos = ['p2p-circuit', 'p2p-websocket-star', 'p2p-webrtc-star', 'p2p-stardust'];\n/**\n * Get the destination address of a (possibly relay) multiaddr as a string\n *\n * @param {Multiaddr} addr\n * @returns {String}\n */\n\nfunction getDestination(addr) {\n  var protos = addr.protoNames().reverse();\n  var splitProto = protos.find(function (p) {\n    return RelayProtos.includes(p);\n  });\n  addr = addr.toString();\n  if (!splitProto) return addr;\n  return addr.slice(addr.lastIndexOf(splitProto) + splitProto.length);\n}\n\nmodule.exports = TransportManager;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/libp2p-switch/src/transport.js"],"names":["parallel","require","once","debug","log","LimitDialer","DIAL_TIMEOUT","uniqueBy","defaultPerPeerRateLimit","TransportManager","_switch","switch","dialer","_options","dialTimeout","key","transport","transports","Error","listeners","callback","close","err","tasks","Object","keys","map","cb","remove","peerInfo","multiaddrs","toArray","Array","isArray","dialables","_peerInfo","m","toString","dialMany","id","errors","success","connect","multiaddr","conn","handler","_connectionHandler","originalAddrs","addr","port","Number","toOptions","isNaN","freshMultiaddrs","createListeners","ma","done","listener","createListener","listen","removeListener","getAddrs","addrs","concat","push","replace","filter","transportAddrs","length","ourAddrs","ourAddresses","result","transportAddr","some","a","getDestination","startsWith","ourPeerId","toB58String","reduce","peerId","getPeerId","otherAddr","slice","lastIndexOf","Boolean","RelayProtos","protos","protoNames","reverse","splitProto","find","p","includes","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/* eslint no-warning-comments: off */\n\nconst parallel = require('async/parallel')\nconst once = require('once')\nconst debug = require('debug')\nconst log = debug('libp2p:switch:transport')\n\nconst LimitDialer = require('./limit-dialer')\nconst { DIAL_TIMEOUT } = require('./constants')\nconst { uniqueBy } = require('./utils')\n\n// number of concurrent outbound dials to make per peer, same as go-libp2p-swtch\nconst defaultPerPeerRateLimit = 8\n\n/**\n * Manages the transports for the switch. This simplifies dialing and listening across\n * multiple transports.\n */\nclass TransportManager {\n  constructor (_switch) {\n    this.switch = _switch\n    this.dialer = new LimitDialer(defaultPerPeerRateLimit, this.switch._options.dialTimeout || DIAL_TIMEOUT)\n  }\n\n  /**\n   * Adds a `Transport` to the list of transports on the switch, and assigns it to the given key\n   *\n   * @param {String} key\n   * @param {Transport} transport\n   * @returns {void}\n   */\n  add (key, transport) {\n    log('adding %s', key)\n    if (this.switch.transports[key]) {\n      throw new Error('There is already a transport with this key')\n    }\n\n    this.switch.transports[key] = transport\n    if (!this.switch.transports[key].listeners) {\n      this.switch.transports[key].listeners = []\n    }\n  }\n\n  /**\n   * Closes connections for the given transport key\n   * and removes it from the switch.\n   *\n   * @param {String} key\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  remove (key, callback) {\n    callback = callback || function () {}\n\n    if (!this.switch.transports[key]) {\n      return callback()\n    }\n\n    this.close(key, (err) => {\n      delete this.switch.transports[key]\n      callback(err)\n    })\n  }\n\n  /**\n   * Calls `remove` on each transport the switch has\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  removeAll (callback) {\n    const tasks = Object.keys(this.switch.transports).map((key) => {\n      return (cb) => {\n        this.remove(key, cb)\n      }\n    })\n\n    parallel(tasks, callback)\n  }\n\n  /**\n   * For a given transport `key`, dial to all that transport multiaddrs\n   *\n   * @param {String} key Key of the `Transport` to dial\n   * @param {PeerInfo} peerInfo\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  dial (key, peerInfo, callback) {\n    const transport = this.switch.transports[key]\n    let multiaddrs = peerInfo.multiaddrs.toArray()\n\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs]\n    }\n\n    // filter the multiaddrs that are actually valid for this transport\n    multiaddrs = TransportManager.dialables(transport, multiaddrs, this.switch._peerInfo)\n    log('dialing %s', key, multiaddrs.map((m) => m.toString()))\n\n    // dial each of the multiaddrs with the given transport\n    this.dialer.dialMany(peerInfo.id, transport, multiaddrs, (errors, success) => {\n      if (errors) {\n        return callback(errors)\n      }\n\n      peerInfo.connect(success.multiaddr)\n      callback(null, success.conn)\n    })\n  }\n\n  /**\n   * For a given Transport `key`, listen on all multiaddrs in the switch's `_peerInfo`.\n   * If a `handler` is not provided, the Switch's `protocolMuxer` will be used.\n   *\n   * @param {String} key\n   * @param {*} _options Currently ignored\n   * @param {function(Connection)} handler\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  listen (key, _options, handler, callback) {\n    handler = this.switch._connectionHandler(key, handler)\n\n    const transport = this.switch.transports[key]\n    let originalAddrs = this.switch._peerInfo.multiaddrs.toArray()\n\n    // Until TCP can handle distinct addresses on listen, https://github.com/libp2p/interface-transport/issues/41,\n    // make sure we aren't trying to listen on duplicate ports. This also applies to websockets.\n    originalAddrs = uniqueBy(originalAddrs, (addr) => {\n      // Any non 0 port should register as unique\n      const port = Number(addr.toOptions().port)\n      return isNaN(port) || port === 0 ? addr.toString() : port\n    })\n\n    const multiaddrs = TransportManager.dialables(transport, originalAddrs)\n\n    if (!transport.listeners) {\n      transport.listeners = []\n    }\n\n    let freshMultiaddrs = []\n\n    const createListeners = multiaddrs.map((ma) => {\n      return (cb) => {\n        const done = once(cb)\n        const listener = transport.createListener(handler)\n        listener.once('error', done)\n\n        listener.listen(ma, (err) => {\n          if (err) {\n            return done(err)\n          }\n          listener.removeListener('error', done)\n          listener.getAddrs((err, addrs) => {\n            if (err) {\n              return done(err)\n            }\n            freshMultiaddrs = freshMultiaddrs.concat(addrs)\n            transport.listeners.push(listener)\n            done()\n          })\n        })\n      }\n    })\n\n    parallel(createListeners, (err) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // cause we can listen on port 0 or 0.0.0.0\n      this.switch._peerInfo.multiaddrs.replace(multiaddrs, freshMultiaddrs)\n      callback()\n    })\n  }\n\n  /**\n   * Closes the transport with the given key, by closing all of its listeners\n   *\n   * @param {String} key\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  close (key, callback) {\n    const transport = this.switch.transports[key]\n\n    if (!transport) {\n      return callback(new Error(`Trying to close non existing transport: ${key}`))\n    }\n\n    parallel(transport.listeners.map((listener) => {\n      return (cb) => {\n        listener.close(cb)\n      }\n    }), callback)\n  }\n\n  /**\n   * For a given transport, return its multiaddrs that match the given multiaddrs\n   *\n   * @param {Transport} transport\n   * @param {Array<Multiaddr>} multiaddrs\n   * @param {PeerInfo} peerInfo Optional - a peer whose addresses should not be returned\n   * @returns {Array<Multiaddr>}\n   */\n  static dialables (transport, multiaddrs, peerInfo) {\n    // If we dont have a proper transport, return no multiaddrs\n    if (!transport || !transport.filter) return []\n\n    const transportAddrs = transport.filter(multiaddrs)\n    if (!peerInfo || !transportAddrs.length) {\n      return transportAddrs\n    }\n\n    const ourAddrs = ourAddresses(peerInfo)\n\n    const result = transportAddrs.filter(transportAddr => {\n      // If our address is in the destination address, filter it out\n      return !ourAddrs.some(a => getDestination(transportAddr).startsWith(a))\n    })\n\n    return result\n  }\n}\n\n/**\n * Expand addresses in peer info into array of addresses with and without peer\n * ID suffix.\n *\n * @param {PeerInfo} peerInfo Our peer info object\n * @returns {String[]}\n */\nfunction ourAddresses (peerInfo) {\n  const ourPeerId = peerInfo.id.toB58String()\n  return peerInfo.multiaddrs.toArray()\n    .reduce((ourAddrs, addr) => {\n      const peerId = addr.getPeerId()\n      addr = addr.toString()\n      const otherAddr = peerId\n        ? addr.slice(0, addr.lastIndexOf(`/ipfs/${peerId}`))\n        : `${addr}/ipfs/${ourPeerId}`\n      return ourAddrs.concat([addr, otherAddr])\n    }, [])\n    .filter(a => Boolean(a))\n    .concat(`/ipfs/${ourPeerId}`)\n}\n\nconst RelayProtos = [\n  'p2p-circuit',\n  'p2p-websocket-star',\n  'p2p-webrtc-star',\n  'p2p-stardust'\n]\n\n/**\n * Get the destination address of a (possibly relay) multiaddr as a string\n *\n * @param {Multiaddr} addr\n * @returns {String}\n */\nfunction getDestination (addr) {\n  const protos = addr.protoNames().reverse()\n  const splitProto = protos.find(p => RelayProtos.includes(p))\n  addr = addr.toString()\n  if (!splitProto) return addr\n  return addr.slice(addr.lastIndexOf(splitProto) + splitProto.length)\n}\n\nmodule.exports = TransportManager\n"]},"metadata":{},"sourceType":"script"}