{"ast":null,"code":"'use strict';\n\nvar _toArray = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar promisify = require('promisify-es6');\n\nvar map = require('async/map');\n\nvar isIpfs = require('is-ipfs');\n\nvar CID = require('cids');\n\nvar ERR_BAD_PATH = 'ERR_BAD_PATH';\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\n\nfunction parseIpfsPath(ipfsPath) {\n  var invalidPathErr = new Error('invalid ipfs ref path');\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '');\n  var matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/);\n\n  if (!matched) {\n    throw invalidPathErr;\n  }\n\n  var _matched$1$split = matched[1].split('/'),\n      _matched$1$split2 = _toArray(_matched$1$split),\n      hash = _matched$1$split2[0],\n      links = _matched$1$split2.slice(1); // check that a CID can be constructed with the hash\n\n\n  if (isIpfs.cid(hash)) {\n    return {\n      hash: hash,\n      links: links\n    };\n  } else {\n    throw invalidPathErr;\n  }\n}\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n * If the received string is not a valid ipfs path, an error will be returned\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\n\n\nvar normalizePath = function normalizePath(pathStr) {\n  if (isIpfs.cid(pathStr)) {\n    return \"/ipfs/\".concat(pathStr);\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw Object.assign(new Error(\"invalid \".concat(pathStr, \" path\")), {\n      code: ERR_BAD_PATH\n    });\n  }\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param  {IPFS}               objectAPI The IPFS object api\n * @param  {Described above}    ipfsPaths A single or collection of ipfs-paths\n * @param  {Function<err, res>} callback res is Array<Buffer(hash)>\n *                              if no callback is passed, returns a Promise\n * @return {Promise|void}\n */\n\n\nvar resolvePath = promisify(function (objectAPI, ipfsPaths, callback) {\n  if (!Array.isArray(ipfsPaths)) {\n    ipfsPaths = [ipfsPaths];\n  }\n\n  map(ipfsPaths, function (path, cb) {\n    if (typeof path !== 'string') {\n      var cid;\n\n      try {\n        cid = new CID(path);\n      } catch (err) {\n        return cb(err);\n      }\n\n      return cb(null, cid.buffer);\n    }\n\n    var parsedPath;\n\n    try {\n      parsedPath = exports.parseIpfsPath(path);\n    } catch (err) {\n      return cb(err);\n    }\n\n    var rootHash = new CID(parsedPath.hash);\n    var rootLinks = parsedPath.links;\n\n    if (!rootLinks.length) {\n      return cb(null, rootHash.buffer);\n    }\n\n    objectAPI.get(rootHash, follow.bind(null, rootHash, rootLinks)); // recursively follow named links to the target node\n\n    function follow(cid, links, err, obj) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (!links.length) {\n        // done tracing, obj is the target node\n        return cb(null, cid.buffer);\n      }\n\n      var linkName = links[0];\n      var nextObj = obj.Links.find(function (link) {\n        return link.Name === linkName;\n      });\n\n      if (!nextObj) {\n        return cb(new Error(\"no link named \\\"\".concat(linkName, \"\\\" under \").concat(cid)));\n      }\n\n      objectAPI.get(nextObj.Hash, follow.bind(null, nextObj.Hash, links.slice(1)));\n    }\n  }, callback);\n});\nexports.normalizePath = normalizePath;\nexports.parseIpfsPath = parseIpfsPath;\nexports.resolvePath = resolvePath;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs/src/core/utils.js"],"names":["promisify","require","map","isIpfs","CID","ERR_BAD_PATH","exports","OFFLINE_ERROR","parseIpfsPath","ipfsPath","invalidPathErr","Error","replace","matched","match","split","hash","links","cid","normalizePath","pathStr","path","Object","assign","code","resolvePath","objectAPI","ipfsPaths","callback","Array","isArray","cb","err","buffer","parsedPath","rootHash","rootLinks","length","get","follow","bind","obj","linkName","nextObj","Links","find","link","Name","Hash","slice"],"mappings":"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","sourcesContent":["'use strict'\n\nconst promisify = require('promisify-es6')\nconst map = require('async/map')\nconst isIpfs = require('is-ipfs')\nconst CID = require('cids')\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH'\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.'\n\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\nfunction parseIpfsPath (ipfsPath) {\n  const invalidPathErr = new Error('invalid ipfs ref path')\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '')\n  const matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/)\n  if (!matched) {\n    throw invalidPathErr\n  }\n\n  const [hash, ...links] = matched[1].split('/')\n\n  // check that a CID can be constructed with the hash\n  if (isIpfs.cid(hash)) {\n    return { hash, links }\n  } else {\n    throw invalidPathErr\n  }\n}\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n * If the received string is not a valid ipfs path, an error will be returned\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\nconst normalizePath = (pathStr) => {\n  if (isIpfs.cid(pathStr)) {\n    return `/ipfs/${pathStr}`\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr\n  } else {\n    throw Object.assign(new Error(`invalid ${pathStr} path`), { code: ERR_BAD_PATH })\n  }\n}\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param  {IPFS}               objectAPI The IPFS object api\n * @param  {Described above}    ipfsPaths A single or collection of ipfs-paths\n * @param  {Function<err, res>} callback res is Array<Buffer(hash)>\n *                              if no callback is passed, returns a Promise\n * @return {Promise|void}\n */\nconst resolvePath = promisify(function (objectAPI, ipfsPaths, callback) {\n  if (!Array.isArray(ipfsPaths)) {\n    ipfsPaths = [ipfsPaths]\n  }\n\n  map(ipfsPaths, (path, cb) => {\n    if (typeof path !== 'string') {\n      let cid\n\n      try {\n        cid = new CID(path)\n      } catch (err) {\n        return cb(err)\n      }\n\n      return cb(null, cid.buffer)\n    }\n\n    let parsedPath\n    try {\n      parsedPath = exports.parseIpfsPath(path)\n    } catch (err) {\n      return cb(err)\n    }\n\n    const rootHash = new CID(parsedPath.hash)\n    const rootLinks = parsedPath.links\n\n    if (!rootLinks.length) {\n      return cb(null, rootHash.buffer)\n    }\n\n    objectAPI.get(rootHash, follow.bind(null, rootHash, rootLinks))\n\n    // recursively follow named links to the target node\n    function follow (cid, links, err, obj) {\n      if (err) {\n        return cb(err)\n      }\n\n      if (!links.length) {\n        // done tracing, obj is the target node\n        return cb(null, cid.buffer)\n      }\n\n      const linkName = links[0]\n      const nextObj = obj.Links.find(link => link.Name === linkName)\n\n      if (!nextObj) {\n        return cb(new Error(`no link named \"${linkName}\" under ${cid}`))\n      }\n\n      objectAPI.get(nextObj.Hash, follow.bind(null, nextObj.Hash, links.slice(1)))\n    }\n  }, callback)\n})\n\nexports.normalizePath = normalizePath\nexports.parseIpfsPath = parseIpfsPath\nexports.resolvePath = resolvePath\n"]},"metadata":{},"sourceType":"script"}