{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar once = require('once');\n\nvar Queue = require('./queue');\n\nvar _require = require('../errors'),\n    DIAL_ABORTED = _require.DIAL_ABORTED;\n\nvar nextTick = require('async/nextTick');\n\nvar retimer = require('retimer');\n\nvar _require2 = require('../constants'),\n    QUARTER_HOUR = _require2.QUARTER_HOUR,\n    PRIORITY_HIGH = _require2.PRIORITY_HIGH;\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:dial:manager');\n\nvar noop = function noop() {};\n\nvar DialQueueManager = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Switch} _switch\n   */\n  function DialQueueManager(_switch) {\n    _classCallCheck(this, DialQueueManager);\n\n    this._queue = new Set();\n    this._coldCallQueue = new Set();\n    this._dialingQueues = new Set();\n    this._queues = {};\n    this.switch = _switch;\n    this._cleanInterval = retimer(this._clean.bind(this), QUARTER_HOUR);\n    this.start();\n  }\n  /**\n   * Runs through all queues, aborts and removes them if they\n   * are no longer valid. A queue that is blacklisted indefinitely,\n   * is considered no longer valid.\n   * @private\n   */\n\n\n  _createClass(DialQueueManager, [{\n    key: \"_clean\",\n    value: function _clean() {\n      var _this = this;\n\n      var queues = Object.values(this._queues);\n      queues.forEach(function (dialQueue) {\n        // Clear if the queue has reached max blacklist\n        if (dialQueue.blackListed === Infinity) {\n          dialQueue.abort();\n          delete _this._queues[dialQueue.id];\n          return;\n        } // Keep track of blacklisted queues\n\n\n        if (dialQueue.blackListed) return; // Clear if peer is no longer active\n        // To avoid reallocating memory, dont delete queues of\n        // connected peers, as these are highly likely to leverage the\n        // queues in the immediate term\n\n        if (!dialQueue.isRunning && dialQueue.length < 1) {\n          var isConnected = false;\n\n          try {\n            var peerInfo = _this.switch._peerBook.get(dialQueue.id);\n\n            isConnected = Boolean(peerInfo.isConnected());\n          } catch (_) {// If we get an error, that means the peerbook doesnt have the peer\n          }\n\n          if (!isConnected) {\n            dialQueue.abort();\n            delete _this._queues[dialQueue.id];\n          }\n        }\n      });\n\n      this._cleanInterval.reschedule(QUARTER_HOUR);\n    }\n    /**\n     * Allows the `DialQueueManager` to execute dials\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.isRunning = true;\n    }\n    /**\n     * Iterates over all items in the DialerQueue\n     * and executes there callback with an error.\n     *\n     * This causes the entire DialerQueue to be drained\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this2 = this;\n\n      this.isRunning = false; // Clear the general queue\n\n      this._queue.clear(); // Clear the cold call queue\n\n\n      this._coldCallQueue.clear();\n\n      this._cleanInterval.clear(); // Abort the individual peer queues\n\n\n      var queues = Object.values(this._queues);\n      queues.forEach(function (dialQueue) {\n        dialQueue.abort();\n        delete _this2._queues[dialQueue.id];\n      });\n    }\n    /**\n     * Adds the `dialRequest` to the queue and ensures queue is running\n     *\n     * @param {DialRequest} dialRequest\n     * @returns {void}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(_ref) {\n      var peerInfo = _ref.peerInfo,\n          protocol = _ref.protocol,\n          options = _ref.options,\n          callback = _ref.callback;\n      callback = callback ? once(callback) : noop; // Add the dial to its respective queue\n\n      var targetQueue = this.getQueue(peerInfo); // Cold Call\n\n      if (options.priority > PRIORITY_HIGH) {\n        // If we have too many cold calls, abort the dial immediately\n        if (this._coldCallQueue.size >= this.switch.dialer.MAX_COLD_CALLS) {\n          return nextTick(callback, DIAL_ABORTED());\n        }\n\n        if (this._queue.has(targetQueue.id)) {\n          return nextTick(callback, DIAL_ABORTED());\n        }\n      }\n\n      targetQueue.add(protocol, options.useFSM, callback); // If we're already connected to the peer, start the queue now\n      // While it might cause queues to go over the max parallel amount,\n      // it avoids blocking peers we're already connected to\n\n      if (peerInfo.isConnected()) {\n        targetQueue.start();\n        return;\n      } // If dialing is not allowed, abort\n\n\n      if (!targetQueue.isDialAllowed()) {\n        return;\n      } // Add the id to its respective queue set if the queue isn't running\n\n\n      if (!targetQueue.isRunning) {\n        if (options.priority <= PRIORITY_HIGH) {\n          this._queue.add(targetQueue.id);\n\n          this._coldCallQueue.delete(targetQueue.id); // Only add it to the cold queue if it's not in the normal queue\n\n        } else {\n          this._coldCallQueue.add(targetQueue.id);\n        }\n      }\n\n      this.run();\n    }\n    /**\n     * Will execute up to `MAX_PARALLEL_DIALS` dials\n     */\n\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (!this.isRunning) return;\n\n      if (this._dialingQueues.size < this.switch.dialer.MAX_PARALLEL_DIALS) {\n        var nextQueue = {\n          done: true\n        }; // Check the queue first and fall back to the cold call queue\n\n        if (this._queue.size > 0) {\n          nextQueue = this._queue.values().next();\n\n          this._queue.delete(nextQueue.value);\n        } else if (this._coldCallQueue.size > 0) {\n          nextQueue = this._coldCallQueue.values().next();\n\n          this._coldCallQueue.delete(nextQueue.value);\n        }\n\n        if (nextQueue.done) {\n          return;\n        }\n\n        var targetQueue = this._queues[nextQueue.value];\n\n        if (!targetQueue) {\n          log('missing queue %s, maybe it was aborted?', nextQueue.value);\n          return;\n        }\n\n        this._dialingQueues.add(targetQueue.id);\n\n        targetQueue.start();\n      }\n    }\n    /**\n     * Will remove the `peerInfo` from the dial blacklist\n     * @param {PeerInfo} peerInfo\n     */\n\n  }, {\n    key: \"clearBlacklist\",\n    value: function clearBlacklist(peerInfo) {\n      var queue = this.getQueue(peerInfo);\n      queue.blackListed = null;\n      queue.blackListCount = 0;\n    }\n    /**\n     * A handler for when dialing queues stop. This will trigger\n     * `run()` in order to keep the queue processing.\n     * @private\n     * @param {string} id peer id of the queue that stopped\n     */\n\n  }, {\n    key: \"_onQueueStopped\",\n    value: function _onQueueStopped(id) {\n      this._dialingQueues.delete(id);\n\n      this.run();\n    }\n    /**\n     * Returns the `Queue` for the given `peerInfo`\n     * @param {PeerInfo} peerInfo\n     * @returns {Queue}\n     */\n\n  }, {\n    key: \"getQueue\",\n    value: function getQueue(peerInfo) {\n      var id = peerInfo.id.toB58String();\n      this._queues[id] = this._queues[id] || new Queue(id, this.switch, this._onQueueStopped.bind(this));\n      return this._queues[id];\n    }\n  }]);\n\n  return DialQueueManager;\n}();\n\nmodule.exports = DialQueueManager;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/libp2p-switch/src/dialer/queueManager.js"],"names":["once","require","Queue","DIAL_ABORTED","nextTick","retimer","QUARTER_HOUR","PRIORITY_HIGH","debug","log","noop","DialQueueManager","_switch","_queue","Set","_coldCallQueue","_dialingQueues","_queues","switch","_cleanInterval","_clean","bind","start","queues","Object","values","forEach","dialQueue","blackListed","Infinity","abort","id","isRunning","length","isConnected","peerInfo","_peerBook","get","Boolean","_","reschedule","clear","protocol","options","callback","targetQueue","getQueue","priority","size","dialer","MAX_COLD_CALLS","has","add","useFSM","isDialAllowed","delete","run","MAX_PARALLEL_DIALS","nextQueue","done","next","value","queue","blackListCount","toB58String","_onQueueStopped","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst once = require('once')\nconst Queue = require('./queue')\nconst { DIAL_ABORTED } = require('../errors')\nconst nextTick = require('async/nextTick')\nconst retimer = require('retimer')\nconst { QUARTER_HOUR, PRIORITY_HIGH } = require('../constants')\nconst debug = require('debug')\nconst log = debug('libp2p:switch:dial:manager')\nconst noop = () => {}\n\nclass DialQueueManager {\n  /**\n   * @constructor\n   * @param {Switch} _switch\n   */\n  constructor (_switch) {\n    this._queue = new Set()\n    this._coldCallQueue = new Set()\n    this._dialingQueues = new Set()\n    this._queues = {}\n    this.switch = _switch\n    this._cleanInterval = retimer(this._clean.bind(this), QUARTER_HOUR)\n    this.start()\n  }\n\n  /**\n   * Runs through all queues, aborts and removes them if they\n   * are no longer valid. A queue that is blacklisted indefinitely,\n   * is considered no longer valid.\n   * @private\n   */\n  _clean () {\n    const queues = Object.values(this._queues)\n    queues.forEach(dialQueue => {\n      // Clear if the queue has reached max blacklist\n      if (dialQueue.blackListed === Infinity) {\n        dialQueue.abort()\n        delete this._queues[dialQueue.id]\n        return\n      }\n\n      // Keep track of blacklisted queues\n      if (dialQueue.blackListed) return\n\n      // Clear if peer is no longer active\n      // To avoid reallocating memory, dont delete queues of\n      // connected peers, as these are highly likely to leverage the\n      // queues in the immediate term\n      if (!dialQueue.isRunning && dialQueue.length < 1) {\n        let isConnected = false\n        try {\n          const peerInfo = this.switch._peerBook.get(dialQueue.id)\n          isConnected = Boolean(peerInfo.isConnected())\n        } catch (_) {\n          // If we get an error, that means the peerbook doesnt have the peer\n        }\n\n        if (!isConnected) {\n          dialQueue.abort()\n          delete this._queues[dialQueue.id]\n        }\n      }\n    })\n\n    this._cleanInterval.reschedule(QUARTER_HOUR)\n  }\n\n  /**\n   * Allows the `DialQueueManager` to execute dials\n   */\n  start () {\n    this.isRunning = true\n  }\n\n  /**\n   * Iterates over all items in the DialerQueue\n   * and executes there callback with an error.\n   *\n   * This causes the entire DialerQueue to be drained\n   */\n  stop () {\n    this.isRunning = false\n    // Clear the general queue\n    this._queue.clear()\n    // Clear the cold call queue\n    this._coldCallQueue.clear()\n\n    this._cleanInterval.clear()\n\n    // Abort the individual peer queues\n    const queues = Object.values(this._queues)\n    queues.forEach(dialQueue => {\n      dialQueue.abort()\n      delete this._queues[dialQueue.id]\n    })\n  }\n\n  /**\n   * Adds the `dialRequest` to the queue and ensures queue is running\n   *\n   * @param {DialRequest} dialRequest\n   * @returns {void}\n   */\n  add ({ peerInfo, protocol, options, callback }) {\n    callback = callback ? once(callback) : noop\n\n    // Add the dial to its respective queue\n    const targetQueue = this.getQueue(peerInfo)\n\n    // Cold Call\n    if (options.priority > PRIORITY_HIGH) {\n      // If we have too many cold calls, abort the dial immediately\n      if (this._coldCallQueue.size >= this.switch.dialer.MAX_COLD_CALLS) {\n        return nextTick(callback, DIAL_ABORTED())\n      }\n\n      if (this._queue.has(targetQueue.id)) {\n        return nextTick(callback, DIAL_ABORTED())\n      }\n    }\n\n    targetQueue.add(protocol, options.useFSM, callback)\n\n    // If we're already connected to the peer, start the queue now\n    // While it might cause queues to go over the max parallel amount,\n    // it avoids blocking peers we're already connected to\n    if (peerInfo.isConnected()) {\n      targetQueue.start()\n      return\n    }\n\n    // If dialing is not allowed, abort\n    if (!targetQueue.isDialAllowed()) {\n      return\n    }\n\n    // Add the id to its respective queue set if the queue isn't running\n    if (!targetQueue.isRunning) {\n      if (options.priority <= PRIORITY_HIGH) {\n        this._queue.add(targetQueue.id)\n        this._coldCallQueue.delete(targetQueue.id)\n      // Only add it to the cold queue if it's not in the normal queue\n      } else {\n        this._coldCallQueue.add(targetQueue.id)\n      }\n    }\n\n    this.run()\n  }\n\n  /**\n   * Will execute up to `MAX_PARALLEL_DIALS` dials\n   */\n  run () {\n    if (!this.isRunning) return\n\n    if (this._dialingQueues.size < this.switch.dialer.MAX_PARALLEL_DIALS) {\n      let nextQueue = { done: true }\n      // Check the queue first and fall back to the cold call queue\n      if (this._queue.size > 0) {\n        nextQueue = this._queue.values().next()\n        this._queue.delete(nextQueue.value)\n      } else if (this._coldCallQueue.size > 0) {\n        nextQueue = this._coldCallQueue.values().next()\n        this._coldCallQueue.delete(nextQueue.value)\n      }\n\n      if (nextQueue.done) {\n        return\n      }\n\n      let targetQueue = this._queues[nextQueue.value]\n\n      if (!targetQueue) {\n        log('missing queue %s, maybe it was aborted?', nextQueue.value)\n        return\n      }\n\n      this._dialingQueues.add(targetQueue.id)\n      targetQueue.start()\n    }\n  }\n\n  /**\n   * Will remove the `peerInfo` from the dial blacklist\n   * @param {PeerInfo} peerInfo\n   */\n  clearBlacklist (peerInfo) {\n    const queue = this.getQueue(peerInfo)\n    queue.blackListed = null\n    queue.blackListCount = 0\n  }\n\n  /**\n   * A handler for when dialing queues stop. This will trigger\n   * `run()` in order to keep the queue processing.\n   * @private\n   * @param {string} id peer id of the queue that stopped\n   */\n  _onQueueStopped (id) {\n    this._dialingQueues.delete(id)\n    this.run()\n  }\n\n  /**\n   * Returns the `Queue` for the given `peerInfo`\n   * @param {PeerInfo} peerInfo\n   * @returns {Queue}\n   */\n  getQueue (peerInfo) {\n    const id = peerInfo.id.toB58String()\n\n    this._queues[id] = this._queues[id] || new Queue(id, this.switch, this._onQueueStopped.bind(this))\n    return this._queues[id]\n  }\n}\n\nmodule.exports = DialQueueManager\n"]},"metadata":{},"sourceType":"script"}