{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar crypto = require('libp2p-crypto');\n\nvar bs58 = require('bs58');\n\nexports = module.exports;\n/**\n * Generatea random sequence number.\n *\n * @returns {Buffer}\n * @private\n */\n\nexports.randomSeqno = function () {\n  return crypto.randomBytes(20);\n};\n/**\n * Generate a message id, based on the `from` and `seqno`.\n *\n * @param {string} from\n * @param {Buffer} seqno\n * @returns {string}\n * @private\n */\n\n\nexports.msgId = function (from, seqno) {\n  return from + seqno.toString('hex');\n};\n/**\n * Check if any member of the first set is also a member\n * of the second set.\n *\n * @param {Set|Array} a\n * @param {Set|Array} b\n * @returns {boolean}\n * @private\n */\n\n\nexports.anyMatch = function (a, b) {\n  var bHas;\n\n  if (Array.isArray(b)) {\n    bHas = function bHas(val) {\n      return b.indexOf(val) > -1;\n    };\n  } else {\n    bHas = function bHas(val) {\n      return b.has(val);\n    };\n  }\n\n  var _iterator = _createForOfIteratorHelper(a),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var val = _step.value;\n\n      if (bHas(val)) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return false;\n};\n/**\n * Make everything an array.\n *\n * @param {any} maybeArray\n * @returns {Array}\n * @private\n */\n\n\nexports.ensureArray = function (maybeArray) {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray];\n  }\n\n  return maybeArray;\n};\n\nexports.normalizeInRpcMessages = function (messages) {\n  if (!messages) {\n    return messages;\n  }\n\n  return messages.map(function (msg) {\n    var m = Object.assign({}, msg);\n\n    if (Buffer.isBuffer(msg.from)) {\n      m.from = bs58.encode(msg.from);\n    }\n\n    return m;\n  });\n};\n\nexports.normalizeOutRpcMessage = function (message) {\n  var m = Object.assign({}, message);\n\n  if (typeof message.from === 'string' || message.from instanceof String) {\n    m.from = bs58.decode(message.from);\n  }\n\n  return m;\n};\n\nexports.normalizeOutRpcMessages = function (messages) {\n  if (!messages) {\n    return messages;\n  }\n\n  return messages.map(exports.normalizeOutRpcMessage);\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-pubsub/src/utils.js"],"names":["crypto","require","bs58","exports","module","randomSeqno","randomBytes","msgId","from","seqno","toString","anyMatch","a","b","bHas","Array","isArray","val","indexOf","has","ensureArray","maybeArray","normalizeInRpcMessages","messages","map","msg","m","Object","assign","Buffer","isBuffer","encode","normalizeOutRpcMessage","message","String","decode","normalizeOutRpcMessages"],"mappings":"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","sourcesContent":["'use strict'\n\nconst crypto = require('libp2p-crypto')\nconst bs58 = require('bs58')\n\nexports = module.exports\n\n/**\n * Generatea random sequence number.\n *\n * @returns {Buffer}\n * @private\n */\nexports.randomSeqno = () => {\n  return crypto.randomBytes(20)\n}\n\n/**\n * Generate a message id, based on the `from` and `seqno`.\n *\n * @param {string} from\n * @param {Buffer} seqno\n * @returns {string}\n * @private\n */\nexports.msgId = (from, seqno) => {\n  return from + seqno.toString('hex')\n}\n\n/**\n * Check if any member of the first set is also a member\n * of the second set.\n *\n * @param {Set|Array} a\n * @param {Set|Array} b\n * @returns {boolean}\n * @private\n */\nexports.anyMatch = (a, b) => {\n  let bHas\n  if (Array.isArray(b)) {\n    bHas = (val) => b.indexOf(val) > -1\n  } else {\n    bHas = (val) => b.has(val)\n  }\n\n  for (let val of a) {\n    if (bHas(val)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Make everything an array.\n *\n * @param {any} maybeArray\n * @returns {Array}\n * @private\n */\nexports.ensureArray = (maybeArray) => {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray]\n  }\n\n  return maybeArray\n}\n\nexports.normalizeInRpcMessages = (messages) => {\n  if (!messages) {\n    return messages\n  }\n  return messages.map((msg) => {\n    const m = Object.assign({}, msg)\n    if (Buffer.isBuffer(msg.from)) {\n      m.from = bs58.encode(msg.from)\n    }\n    return m\n  })\n}\n\nexports.normalizeOutRpcMessage = (message) => {\n  const m = Object.assign({}, message)\n  if (typeof message.from === 'string' || message.from instanceof String) {\n    m.from = bs58.decode(message.from)\n  }\n  return m\n}\n\nexports.normalizeOutRpcMessages = (messages) => {\n  if (!messages) {\n    return messages\n  }\n  return messages.map(exports.normalizeOutRpcMessage)\n}\n"]},"metadata":{},"sourceType":"script"}