{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Connection = require('interface-connection').Connection;\n\nvar pull = require('pull-stream/pull');\n\nvar empty = require('pull-stream/sources/empty');\n\nvar timeout = require('async/timeout');\n\nvar queue = require('async/queue');\n\nvar debug = require('debug');\n\nvar once = require('once');\n\nvar log = debug('libp2p:switch:dialer:queue');\nlog.error = debug('libp2p:switch:dialer:queue:error');\n/**\n * Queue up the amount of dials to a given peer.\n */\n\nvar DialQueue = /*#__PURE__*/function () {\n  /**\n   * Create a new dial queue.\n   *\n   * @param {number} limit\n   * @param {number} dialTimeout\n   */\n  function DialQueue(limit, dialTimeout) {\n    var _this = this;\n\n    _classCallCheck(this, DialQueue);\n\n    this.dialTimeout = dialTimeout;\n    this.queue = queue(function (task, cb) {\n      _this._doWork(task.transport, task.addr, task.token, cb);\n    }, limit);\n  }\n  /**\n   * The actual work done by the queue.\n   *\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {CancelToken} token\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   * @private\n   */\n\n\n  _createClass(DialQueue, [{\n    key: \"_doWork\",\n    value: function _doWork(transport, addr, token, callback) {\n      callback = once(callback);\n      log('work:start');\n\n      this._dialWithTimeout(transport, addr, function (err, conn) {\n        if (err) {\n          log.error(\"\".concat(transport.constructor.name, \":work\"), err);\n          return callback(err);\n        }\n\n        if (token.cancel) {\n          log('work:cancel'); // clean up already done dials\n\n          pull(empty(), conn); // If we can close the connection, do it\n\n          if (typeof conn.close === 'function') {\n            return conn.close(function (_) {\n              return callback(null);\n            });\n          }\n\n          return callback(null);\n        } // one is enough\n\n\n        token.cancel = true;\n        log('work:success');\n        var proxyConn = new Connection();\n        proxyConn.setInnerConn(conn);\n        callback(null, {\n          multiaddr: addr,\n          conn: conn\n        });\n      });\n    }\n    /**\n     * Dial the given transport, timing out with the set timeout.\n     *\n     * @param {SwarmTransport} transport\n     * @param {Multiaddr} addr\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_dialWithTimeout\",\n    value: function _dialWithTimeout(transport, addr, callback) {\n      timeout(function (cb) {\n        var conn = transport.dial(addr, function (err) {\n          if (err) {\n            return cb(err);\n          }\n\n          cb(null, conn);\n        });\n      }, this.dialTimeout)(callback);\n    }\n    /**\n     * Add new work to the queue.\n     *\n     * @param {SwarmTransport} transport\n     * @param {Multiaddr} addr\n     * @param {CancelToken} token\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(transport, addr, token, callback) {\n      this.queue.push({\n        transport: transport,\n        addr: addr,\n        token: token\n      }, callback);\n    }\n  }]);\n\n  return DialQueue;\n}();\n\nmodule.exports = DialQueue;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-switch/src/limit-dialer/queue.js"],"names":["Connection","require","pull","empty","timeout","queue","debug","once","log","error","DialQueue","limit","dialTimeout","task","cb","_doWork","transport","addr","token","callback","_dialWithTimeout","err","conn","constructor","name","cancel","close","_","proxyConn","setInnerConn","multiaddr","dial","push","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Connection = require('interface-connection').Connection\nconst pull = require('pull-stream/pull')\nconst empty = require('pull-stream/sources/empty')\nconst timeout = require('async/timeout')\nconst queue = require('async/queue')\nconst debug = require('debug')\nconst once = require('once')\n\nconst log = debug('libp2p:switch:dialer:queue')\nlog.error = debug('libp2p:switch:dialer:queue:error')\n\n/**\n * Queue up the amount of dials to a given peer.\n */\nclass DialQueue {\n  /**\n   * Create a new dial queue.\n   *\n   * @param {number} limit\n   * @param {number} dialTimeout\n   */\n  constructor (limit, dialTimeout) {\n    this.dialTimeout = dialTimeout\n\n    this.queue = queue((task, cb) => {\n      this._doWork(task.transport, task.addr, task.token, cb)\n    }, limit)\n  }\n\n  /**\n   * The actual work done by the queue.\n   *\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {CancelToken} token\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   * @private\n   */\n  _doWork (transport, addr, token, callback) {\n    callback = once(callback)\n    log('work:start')\n    this._dialWithTimeout(transport, addr, (err, conn) => {\n      if (err) {\n        log.error(`${transport.constructor.name}:work`, err)\n        return callback(err)\n      }\n\n      if (token.cancel) {\n        log('work:cancel')\n        // clean up already done dials\n        pull(empty(), conn)\n        // If we can close the connection, do it\n        if (typeof conn.close === 'function') {\n          return conn.close((_) => callback(null))\n        }\n        return callback(null)\n      }\n\n      // one is enough\n      token.cancel = true\n\n      log('work:success')\n\n      const proxyConn = new Connection()\n      proxyConn.setInnerConn(conn)\n      callback(null, { multiaddr: addr, conn: conn })\n    })\n  }\n\n  /**\n   * Dial the given transport, timing out with the set timeout.\n   *\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _dialWithTimeout (transport, addr, callback) {\n    timeout((cb) => {\n      const conn = transport.dial(addr, (err) => {\n        if (err) {\n          return cb(err)\n        }\n\n        cb(null, conn)\n      })\n    }, this.dialTimeout)(callback)\n  }\n\n  /**\n   * Add new work to the queue.\n   *\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {CancelToken} token\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  push (transport, addr, token, callback) {\n    this.queue.push({ transport, addr, token }, callback)\n  }\n}\n\nmodule.exports = DialQueue\n"]},"metadata":{},"sourceType":"script"}