{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:webrtc-star');\n\nvar multiaddr = require('multiaddr');\n\nvar mafmt = require('mafmt');\n\nvar withIs = require('class-is');\n\nvar io = require('socket.io-client');\n\nvar EE = require('events').EventEmitter;\n\nvar SimplePeer = require('simple-peer');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar Connection = require('interface-connection').Connection;\n\nvar toPull = require('stream-to-pull-stream');\n\nvar once = require('once');\n\nvar setImmediate = require('async/setImmediate');\n\nvar webrtcSupport = require('webrtcsupport');\n\nvar utils = require('./utils');\n\nvar cleanUrlSIO = utils.cleanUrlSIO;\nvar cleanMultiaddr = utils.cleanMultiaddr;\nvar noop = once(function () {});\nvar sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n};\n\nvar WebRTCStar = /*#__PURE__*/function () {\n  function WebRTCStar(options) {\n    var _this = this;\n\n    _classCallCheck(this, WebRTCStar);\n\n    options = options || {};\n    this.maSelf = undefined;\n    this.sioOptions = {\n      transports: ['websocket'],\n      'force new connection': true\n    };\n\n    if (options.wrtc) {\n      this.wrtc = options.wrtc;\n    }\n\n    this.discovery = new EE();\n    this.discovery.tag = 'webRTCStar';\n    this.discovery._isStarted = false;\n\n    this.discovery.start = function (callback) {\n      _this.discovery._isStarted = true;\n      setImmediate(callback);\n    };\n\n    this.discovery.stop = function (callback) {\n      _this.discovery._isStarted = false;\n      setImmediate(callback);\n    };\n\n    this.listenersRefs = {};\n    this._peerDiscovered = this._peerDiscovered.bind(this);\n  }\n\n  _createClass(WebRTCStar, [{\n    key: \"dial\",\n    value: function dial(ma, options, callback) {\n      var _this2 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      callback = callback ? once(callback) : noop;\n      var intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now();\n      var sioClient = this.listenersRefs[Object.keys(this.listenersRefs)[0]].io;\n      var spOptions = {\n        initiator: true,\n        trickle: false\n      }; // Use custom WebRTC implementation\n\n      if (this.wrtc) {\n        spOptions.wrtc = this.wrtc;\n      }\n\n      var channel;\n\n      try {\n        channel = new SimplePeer(spOptions);\n      } catch (err) {\n        log('Could not create connection:', err);\n        return callback(err);\n      }\n\n      var conn = new Connection(toPull.duplex(channel));\n      var connected = false;\n      channel.on('signal', function (signal) {\n        sioClient.emit('ss-handshake', {\n          intentId: intentId,\n          srcMultiaddr: _this2.maSelf.toString(),\n          dstMultiaddr: ma.toString(),\n          signal: signal\n        });\n      });\n      channel.once('timeout', function () {\n        return callback(new Error('timeout'));\n      });\n      channel.once('error', function (err) {\n        if (!connected) {\n          callback(err);\n        }\n      }); // NOTE: aegir segfaults if we do .once on the socket.io event emitter and we\n      // are clueless as to why.\n\n      sioClient.on('ws-handshake', function (offer) {\n        if (offer.intentId === intentId && offer.err) {\n          return callback(new Error(offer.err));\n        }\n\n        if (offer.intentId !== intentId || !offer.answer) {\n          return;\n        }\n\n        channel.once('connect', function () {\n          connected = true;\n          conn.destroy = channel.destroy.bind(channel);\n          channel.once('close', function () {\n            return conn.destroy();\n          });\n\n          conn.getObservedAddrs = function (callback) {\n            return callback(null, [ma]);\n          };\n\n          callback(null, conn);\n        });\n        channel.signal(offer.signal);\n      });\n      return conn;\n    }\n  }, {\n    key: \"createListener\",\n    value: function createListener(options, handler) {\n      var _this3 = this;\n\n      if (typeof options === 'function') {\n        handler = options;\n        options = {};\n      }\n\n      var listener = new EE();\n\n      listener.listen = function (ma, callback) {\n        callback = callback ? once(callback) : noop;\n\n        if (!webrtcSupport.support && !_this3.wrtc) {\n          return setImmediate(function () {\n            return callback(new Error('no WebRTC support'));\n          });\n        }\n\n        _this3.maSelf = ma;\n        var sioUrl = cleanUrlSIO(ma);\n        log('Dialing to Signalling Server on: ' + sioUrl);\n        listener.io = io.connect(sioUrl, sioOptions);\n        listener.io.once('connect_error', callback);\n        listener.io.once('error', function (err) {\n          listener.emit('error', err);\n          listener.emit('close');\n        });\n        listener.io.on('ws-handshake', incommingDial);\n        listener.io.on('ws-peer', _this3._peerDiscovered);\n        listener.io.on('connect', function () {\n          listener.io.emit('ss-join', ma.toString());\n        });\n        listener.io.once('connect', function () {\n          listener.emit('listening');\n          callback();\n        });\n        var self = _this3;\n\n        function incommingDial(offer) {\n          if (offer.answer || offer.err) {\n            return;\n          }\n\n          var spOptions = {\n            trickle: false\n          }; // Use custom WebRTC implementation\n\n          if (self.wrtc) {\n            spOptions.wrtc = self.wrtc;\n          }\n\n          var channel;\n\n          try {\n            channel = new SimplePeer(spOptions);\n          } catch (err) {\n            log('Could not create incoming connection:', err);\n            return callback(err);\n          }\n\n          var conn = new Connection(toPull.duplex(channel));\n          channel.once('connect', function () {\n            conn.getObservedAddrs = function (callback) {\n              return callback(null, [offer.srcMultiaddr]);\n            };\n\n            listener.emit('connection', conn);\n            handler(conn);\n          });\n          channel.once('signal', function (signal) {\n            offer.signal = signal;\n            offer.answer = true;\n            listener.io.emit('ss-handshake', offer);\n          });\n          channel.signal(offer.signal);\n        }\n      };\n\n      listener.close = function (callback) {\n        callback = callback ? once(callback) : noop;\n        listener.io.emit('ss-leave');\n        setImmediate(function () {\n          listener.emit('close');\n          callback();\n        });\n      };\n\n      listener.getAddrs = function (callback) {\n        setImmediate(function () {\n          return callback(null, [_this3.maSelf]);\n        });\n      };\n\n      this.listenersRefs[multiaddr.toString()] = listener;\n      return listener;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(multiaddrs) {\n      if (!Array.isArray(multiaddrs)) {\n        multiaddrs = [multiaddrs];\n      }\n\n      return multiaddrs.filter(function (ma) {\n        if (ma.protoNames().indexOf('p2p-circuit') > -1) {\n          return false;\n        }\n\n        return mafmt.WebRTCStar.matches(ma);\n      });\n    }\n  }, {\n    key: \"_peerDiscovered\",\n    value: function _peerDiscovered(maStr) {\n      if (!this.discovery._isStarted) return;\n      log('Peer Discovered:', maStr);\n      maStr = cleanMultiaddr(maStr);\n      var split = maStr.split('/ipfs/');\n      var peerIdStr = split[split.length - 1];\n      var peerId = PeerId.createFromB58String(peerIdStr);\n      var peerInfo = new PeerInfo(peerId);\n      peerInfo.multiaddrs.add(multiaddr(maStr));\n      this.discovery.emit('peer', peerInfo);\n    }\n  }]);\n\n  return WebRTCStar;\n}();\n\nmodule.exports = withIs(WebRTCStar, {\n  className: 'WebRTCStar',\n  symbolName: '@libp2p/js-libp2p-webrtc-star/webrtcstar'\n});","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/libp2p-webrtc-star/src/index.js"],"names":["debug","require","log","multiaddr","mafmt","withIs","io","EE","EventEmitter","SimplePeer","PeerId","PeerInfo","Connection","toPull","once","setImmediate","webrtcSupport","utils","cleanUrlSIO","cleanMultiaddr","noop","sioOptions","transports","WebRTCStar","options","maSelf","undefined","wrtc","discovery","tag","_isStarted","start","callback","stop","listenersRefs","_peerDiscovered","bind","ma","intentId","Math","random","toString","Date","now","sioClient","Object","keys","spOptions","initiator","trickle","channel","err","conn","duplex","connected","on","signal","emit","srcMultiaddr","dstMultiaddr","Error","offer","answer","destroy","getObservedAddrs","handler","listener","listen","support","sioUrl","connect","incommingDial","self","close","getAddrs","multiaddrs","Array","isArray","filter","protoNames","indexOf","matches","maStr","split","peerIdStr","length","peerId","createFromB58String","peerInfo","add","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:webrtc-star')\nconst multiaddr = require('multiaddr')\nconst mafmt = require('mafmt')\nconst withIs = require('class-is')\nconst io = require('socket.io-client')\nconst EE = require('events').EventEmitter\nconst SimplePeer = require('simple-peer')\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst Connection = require('interface-connection').Connection\nconst toPull = require('stream-to-pull-stream')\nconst once = require('once')\nconst setImmediate = require('async/setImmediate')\nconst webrtcSupport = require('webrtcsupport')\nconst utils = require('./utils')\nconst cleanUrlSIO = utils.cleanUrlSIO\nconst cleanMultiaddr = utils.cleanMultiaddr\n\nconst noop = once(() => {})\n\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n}\n\nclass WebRTCStar {\n  constructor (options) {\n    options = options || {}\n\n    this.maSelf = undefined\n\n    this.sioOptions = {\n      transports: ['websocket'],\n      'force new connection': true\n    }\n\n    if (options.wrtc) {\n      this.wrtc = options.wrtc\n    }\n\n    this.discovery = new EE()\n    this.discovery.tag = 'webRTCStar'\n    this.discovery._isStarted = false\n    this.discovery.start = (callback) => {\n      this.discovery._isStarted = true\n      setImmediate(callback)\n    }\n    this.discovery.stop = (callback) => {\n      this.discovery._isStarted = false\n      setImmediate(callback)\n    }\n\n    this.listenersRefs = {}\n    this._peerDiscovered = this._peerDiscovered.bind(this)\n  }\n\n  dial (ma, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    callback = callback ? once(callback) : noop\n\n    const intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now()\n\n    const sioClient = this\n      .listenersRefs[Object.keys(this.listenersRefs)[0]].io\n\n    const spOptions = { initiator: true, trickle: false }\n\n    // Use custom WebRTC implementation\n    if (this.wrtc) { spOptions.wrtc = this.wrtc }\n\n    let channel\n    try {\n      channel = new SimplePeer(spOptions)\n    } catch (err) {\n      log('Could not create connection:', err)\n      return callback(err)\n    }\n\n    const conn = new Connection(toPull.duplex(channel))\n    let connected = false\n\n    channel.on('signal', (signal) => {\n      sioClient.emit('ss-handshake', {\n        intentId: intentId,\n        srcMultiaddr: this.maSelf.toString(),\n        dstMultiaddr: ma.toString(),\n        signal: signal\n      })\n    })\n\n    channel.once('timeout', () => callback(new Error('timeout')))\n\n    channel.once('error', (err) => {\n      if (!connected) { callback(err) }\n    })\n\n    // NOTE: aegir segfaults if we do .once on the socket.io event emitter and we\n    // are clueless as to why.\n    sioClient.on('ws-handshake', (offer) => {\n      if (offer.intentId === intentId && offer.err) {\n        return callback(new Error(offer.err))\n      }\n\n      if (offer.intentId !== intentId || !offer.answer) {\n        return\n      }\n\n      channel.once('connect', () => {\n        connected = true\n        conn.destroy = channel.destroy.bind(channel)\n\n        channel.once('close', () => conn.destroy())\n\n        conn.getObservedAddrs = (callback) => callback(null, [ma])\n\n        callback(null, conn)\n      })\n\n      channel.signal(offer.signal)\n    })\n\n    return conn\n  }\n\n  createListener (options, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    const listener = new EE()\n\n    listener.listen = (ma, callback) => {\n      callback = callback ? once(callback) : noop\n\n      if (!webrtcSupport.support && !this.wrtc) {\n        return setImmediate(() => callback(new Error('no WebRTC support')))\n      }\n\n      this.maSelf = ma\n\n      const sioUrl = cleanUrlSIO(ma)\n\n      log('Dialing to Signalling Server on: ' + sioUrl)\n\n      listener.io = io.connect(sioUrl, sioOptions)\n\n      listener.io.once('connect_error', callback)\n      listener.io.once('error', (err) => {\n        listener.emit('error', err)\n        listener.emit('close')\n      })\n\n      listener.io.on('ws-handshake', incommingDial)\n      listener.io.on('ws-peer', this._peerDiscovered)\n\n      listener.io.on('connect', () => {\n        listener.io.emit('ss-join', ma.toString())\n      })\n\n      listener.io.once('connect', () => {\n        listener.emit('listening')\n        callback()\n      })\n\n      const self = this\n      function incommingDial (offer) {\n        if (offer.answer || offer.err) {\n          return\n        }\n\n        const spOptions = { trickle: false }\n\n        // Use custom WebRTC implementation\n        if (self.wrtc) { spOptions.wrtc = self.wrtc }\n\n        let channel\n        try {\n          channel = new SimplePeer(spOptions)\n        } catch (err) {\n          log('Could not create incoming connection:', err)\n          return callback(err)\n        }\n\n        const conn = new Connection(toPull.duplex(channel))\n\n        channel.once('connect', () => {\n          conn.getObservedAddrs = (callback) => {\n            return callback(null, [offer.srcMultiaddr])\n          }\n\n          listener.emit('connection', conn)\n          handler(conn)\n        })\n\n        channel.once('signal', (signal) => {\n          offer.signal = signal\n          offer.answer = true\n          listener.io.emit('ss-handshake', offer)\n        })\n\n        channel.signal(offer.signal)\n      }\n    }\n\n    listener.close = (callback) => {\n      callback = callback ? once(callback) : noop\n\n      listener.io.emit('ss-leave')\n\n      setImmediate(() => {\n        listener.emit('close')\n        callback()\n      })\n    }\n\n    listener.getAddrs = (callback) => {\n      setImmediate(() => callback(null, [this.maSelf]))\n    }\n\n    this.listenersRefs[multiaddr.toString()] = listener\n    return listener\n  }\n\n  filter (multiaddrs) {\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs]\n    }\n\n    return multiaddrs.filter((ma) => {\n      if (ma.protoNames().indexOf('p2p-circuit') > -1) {\n        return false\n      }\n\n      return mafmt.WebRTCStar.matches(ma)\n    })\n  }\n\n  _peerDiscovered (maStr) {\n    if (!this.discovery._isStarted) return\n\n    log('Peer Discovered:', maStr)\n    maStr = cleanMultiaddr(maStr)\n\n    const split = maStr.split('/ipfs/')\n    const peerIdStr = split[split.length - 1]\n    const peerId = PeerId.createFromB58String(peerIdStr)\n    const peerInfo = new PeerInfo(peerId)\n    peerInfo.multiaddrs.add(multiaddr(maStr))\n    this.discovery.emit('peer', peerInfo)\n  }\n}\n\nmodule.exports = withIs(WebRTCStar, { className: 'WebRTCStar', symbolName: '@libp2p/js-libp2p-webrtc-star/webrtcstar' })\n"]},"metadata":{},"sourceType":"script"}