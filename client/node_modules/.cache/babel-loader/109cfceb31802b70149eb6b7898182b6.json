{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar pushable = require('pull-pushable');\n\nvar looper = require('looper');\n\nvar nextTick = require('async/nextTick');\n\nvar EE = require('events');\n\nvar debug = require('debug');\n\nvar _require = require('./consts'),\n    Types = _require.Types;\n\nvar _require2 = require('./util'),\n    emitError = _require2.emitError;\n\nvar log = debug('pull-plex:chan');\nlog.err = debug('pull-plex:chan:err');\n/**\n * Creates a pull-stream sink for the given Channel\n * @private\n * @param {Channel} channel\n * @returns {function} The sink function\n */\n\nfunction channelSink(channel) {\n  return function (read) {\n    var next = looper(function () {\n      read(null, function (end, data) {\n        // stream already ended\n        if (channel._endedLocal) {\n          return;\n        }\n\n        channel._endedLocal = end || false; // source ended, close the stream\n\n        if (end === true) {\n          return channel.endChan();\n        } // source errored, destroy stream\n\n\n        if (end || channel._destroy) {\n          channel.destroyChan();\n          channel.emit('error', end || channel._destroy);\n          channel.destroy();\n          return;\n        } // just send\n\n\n        channel.sendMsg(data);\n        next();\n      });\n    });\n    next();\n  };\n}\n/**\n * @fires Channel#close\n * @fires Channel#error\n */\n\n\nvar Channel = /*#__PURE__*/function (_EE) {\n  _inherits(Channel, _EE);\n\n  var _super = _createSuper(Channel);\n\n  /**\n   * @constructor\n   * @param {Object} opts\n   * @param {number} opts.id\n   * @param {boolean} opts.initiator\n   * @param {string} opts.name\n   * @param {boolean} opts.open\n   * @param {Mplex} opts.plex\n   */\n  function Channel(opts) {\n    var _this;\n\n    _classCallCheck(this, Channel);\n\n    _this = _super.call(this);\n    opts = _objectSpread({\n      initiator: false\n    }, opts);\n    _this._id = opts.id;\n    _this._name = opts.name;\n    _this._plex = opts.plex;\n    _this._open = opts.open;\n    _this._initiator = opts.initiator;\n    _this._endedRemote = false; // remote stream ended\n\n    _this._endedLocal = false; // local stream ended\n\n    _this._destroy = false;\n    _this.MSG = _this._initiator ? Types.OUT_MESSAGE : Types.IN_MESSAGE;\n    _this.END = _this._initiator ? Types.OUT_CLOSE : Types.IN_CLOSE;\n    _this.RESET = _this._initiator ? Types.OUT_RESET : Types.IN_RESET;\n\n    _this._log('new channel', _this._name);\n\n    _this._msgs = pushable(function (err) {\n      _this._log('source closed', err);\n\n      if (err && typeof err !== 'boolean') {\n        nextTick(emitError, _assertThisInitialized(_this), err);\n      } // this.endChan() // Do not uncomment this, it will end the channel too early\n\n    });\n    _this._source = _this._msgs;\n    _this.sink = channelSink(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Channel, [{\n    key: \"source\",\n    get: function get() {\n      return this._source;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: \"open\",\n    get: function get() {\n      return this._open;\n    },\n    set: function set(open) {\n      this._open = open;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this._name;\n    }\n  }, {\n    key: \"destroyed\",\n    get: function get() {\n      return this._endedRemote && this._endedLocal;\n    }\n    /**\n     * A convenience wrapper for the log that adds useful metadata to logs\n     * @private\n     * @param {string} name The name of the operation being logged\n     * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`\n     */\n\n  }, {\n    key: \"_log\",\n    value: function _log(name, data) {\n      if (!log.enabled) return;\n      log({\n        op: name,\n        name: this._name,\n        id: this._id,\n        endedLocal: this._endedLocal,\n        endedRemote: this._endedRemote,\n        initiator: this._initiator,\n        data: data && data.toString() || ''\n      });\n    }\n    /**\n     * Pushes `data` into the channel\n     * @param {Buffer} data\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      this._log('push');\n\n      this._msgs.push(data);\n    }\n    /**\n     * Closes the channel for writing\n     * @param {Error} err\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(err) {\n      this._log('close', err);\n\n      if (!this._endedRemote) {\n        this._endedRemote = err || true;\n\n        this._msgs.end(this._endedRemote);\n\n        this.emit('close', err);\n        this.plex = null;\n      }\n    }\n    /**\n     * Closes the channel with the given error\n     * @param {Error} err Default: `'channel destroyed!'`\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(err) {\n      this._log('destroy', err);\n\n      this._destroy = err || 'channel destroyed!';\n      this.close(this._destroy);\n    }\n    /**\n     * Opens the channel if it's not already open. Attempting\n     * to open an already opened channel is ignored.\n     * @param {string} name\n     */\n\n  }, {\n    key: \"openChan\",\n    value: function openChan(name) {\n      if (this.open) {\n        return;\n      } // chan already open\n\n\n      this.open = true;\n\n      this._plex.push([this._id, Types.NEW, name !== this._id.toString() ? name : this._id.toString()]);\n    }\n    /**\n     * Pushes `data` wrapped in a `Message` into the channel.\n     * If the channel is not open, it will be opened automatically.\n     *\n     * @param {Buffer} data\n     */\n\n  }, {\n    key: \"sendMsg\",\n    value: function sendMsg(data) {\n      this._log('sendMsg', data);\n\n      if (!this.open) {\n        this.openChan(this.name);\n      }\n\n      this._plex.push([this._id, this.MSG, data]);\n    }\n    /**\n     * Ends the channel by sending an END `Message`.\n     * If the channel is not open, no action will be taken.\n     */\n\n  }, {\n    key: \"endChan\",\n    value: function endChan() {\n      this._log('endChan');\n\n      if (!this.open) {\n        return;\n      }\n\n      this._plex.push([this._id, this.END]);\n    }\n    /**\n     * Destroys the channel by sending a RESET `Message`.\n     * If the channel is not open, no action will be taken.\n     */\n\n  }, {\n    key: \"destroyChan\",\n    value: function destroyChan() {\n      this._log('destroyChan');\n\n      if (!this.open) {\n        return;\n      }\n\n      this._plex.push([this._id, this.RESET]);\n    }\n  }]);\n\n  return Channel;\n}(EE);\n\nmodule.exports = Channel;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/pull-mplex/src/channel.js"],"names":["pushable","require","looper","nextTick","EE","debug","Types","emitError","log","err","channelSink","channel","read","next","end","data","_endedLocal","endChan","_destroy","destroyChan","emit","destroy","sendMsg","Channel","opts","initiator","_id","id","_name","name","_plex","plex","_open","open","_initiator","_endedRemote","MSG","OUT_MESSAGE","IN_MESSAGE","END","OUT_CLOSE","IN_CLOSE","RESET","OUT_RESET","IN_RESET","_log","_msgs","_source","sink","enabled","op","endedLocal","endedRemote","toString","push","close","NEW","openChan","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;AAEA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,eAAD,CAAxB;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAC,gBAAD,CAAxB;;AACA,IAAMG,EAAE,GAAGH,OAAO,CAAC,QAAD,CAAlB;;AACA,IAAMI,KAAK,GAAGJ,OAAO,CAAC,OAAD,CAArB;;AAEA,eAAkBA,OAAO,CAAC,UAAD,CAAzB;AAAA,IAAQK,KAAR,YAAQA,KAAR;;AACA,gBAAsBL,OAAO,CAAC,QAAD,CAA7B;AAAA,IAAQM,SAAR,aAAQA,SAAR;;AAEA,IAAMC,GAAG,GAAGH,KAAK,CAAC,gBAAD,CAAjB;AACAG,GAAG,CAACC,GAAJ,GAAUJ,KAAK,CAAC,oBAAD,CAAf;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASK,WAAT,CAAsBC,OAAtB,EAA+B;AAC7B,SAAO,UAAUC,IAAV,EAAgB;AACrB,QAAMC,IAAI,GAAGX,MAAM,CAAC,YAAY;AAC9BU,MAAAA,IAAI,CAAC,IAAD,EAAO,UAAUE,GAAV,EAAeC,IAAf,EAAqB;AAC9B;AACA,YAAIJ,OAAO,CAACK,WAAZ,EAAyB;AAAE;AAAQ;;AAEnCL,QAAAA,OAAO,CAACK,WAAR,GAAsBF,GAAG,IAAI,KAA7B,CAJ8B,CAM9B;;AACA,YAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB,iBAAOH,OAAO,CAACM,OAAR,EAAP;AACD,SAT6B,CAW9B;;;AACA,YAAIH,GAAG,IAAIH,OAAO,CAACO,QAAnB,EAA6B;AAC3BP,UAAAA,OAAO,CAACQ,WAAR;AACAR,UAAAA,OAAO,CAACS,IAAR,CAAa,OAAb,EAAsBN,GAAG,IAAIH,OAAO,CAACO,QAArC;AACAP,UAAAA,OAAO,CAACU,OAAR;AACA;AACD,SAjB6B,CAmB9B;;;AACAV,QAAAA,OAAO,CAACW,OAAR,CAAgBP,IAAhB;AACAF,QAAAA,IAAI;AACL,OAtBG,CAAJ;AAuBD,KAxBkB,CAAnB;AA0BAA,IAAAA,IAAI;AACL,GA5BD;AA6BD;AAED;AACA;AACA;AACA;;;IACMU,O;;;;;AACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,mBAAaC,IAAb,EAAmB;AAAA;;AAAA;;AACjB;AAEAA,IAAAA,IAAI;AAAKC,MAAAA,SAAS,EAAE;AAAhB,OAA0BD,IAA1B,CAAJ;AAEA,UAAKE,GAAL,GAAWF,IAAI,CAACG,EAAhB;AACA,UAAKC,KAAL,GAAaJ,IAAI,CAACK,IAAlB;AACA,UAAKC,KAAL,GAAaN,IAAI,CAACO,IAAlB;AACA,UAAKC,KAAL,GAAaR,IAAI,CAACS,IAAlB;AACA,UAAKC,UAAL,GAAkBV,IAAI,CAACC,SAAvB;AACA,UAAKU,YAAL,GAAoB,KAApB,CAViB,CAUS;;AAC1B,UAAKnB,WAAL,GAAmB,KAAnB,CAXiB,CAWQ;;AACzB,UAAKE,QAAL,GAAgB,KAAhB;AAEA,UAAKkB,GAAL,GAAW,MAAKF,UAAL,GACP5B,KAAK,CAAC+B,WADC,GAEP/B,KAAK,CAACgC,UAFV;AAIA,UAAKC,GAAL,GAAW,MAAKL,UAAL,GACP5B,KAAK,CAACkC,SADC,GAEPlC,KAAK,CAACmC,QAFV;AAIA,UAAKC,KAAL,GAAa,MAAKR,UAAL,GACT5B,KAAK,CAACqC,SADG,GAETrC,KAAK,CAACsC,QAFV;;AAIA,UAAKC,IAAL,CAAU,aAAV,EAAyB,MAAKjB,KAA9B;;AAEA,UAAKkB,KAAL,GAAa9C,QAAQ,CAAC,UAACS,GAAD,EAAS;AAC7B,YAAKoC,IAAL,CAAU,eAAV,EAA2BpC,GAA3B;;AACA,UAAIA,GAAG,IAAI,OAAOA,GAAP,KAAe,SAA1B,EAAqC;AACnCN,QAAAA,QAAQ,CAACI,SAAD,iCAAkBE,GAAlB,CAAR;AACD,OAJ4B,CAK7B;;AACD,KANoB,CAArB;AAQA,UAAKsC,OAAL,GAAe,MAAKD,KAApB;AACA,UAAKE,IAAL,GAAYtC,WAAW,+BAAvB;AArCiB;AAsClB;;;;SAED,eAAc;AACZ,aAAO,KAAKqC,OAAZ;AACD;;;SAED,eAAU;AACR,aAAO,KAAKrB,GAAZ;AACD;;;SAED,eAAY;AACV,aAAO,KAAKM,KAAZ;AACD,K;SAED,aAAUC,IAAV,EAAgB;AACd,WAAKD,KAAL,GAAaC,IAAb;AACD;;;SAED,eAAY;AACV,aAAO,KAAKL,KAAZ;AACD;;;SAED,eAAiB;AACf,aAAO,KAAKO,YAAL,IAAqB,KAAKnB,WAAjC;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,cAAMa,IAAN,EAAYd,IAAZ,EAAkB;AAChB,UAAI,CAACP,GAAG,CAACyC,OAAT,EAAkB;AAClBzC,MAAAA,GAAG,CAAC;AACF0C,QAAAA,EAAE,EAAErB,IADF;AAEFA,QAAAA,IAAI,EAAE,KAAKD,KAFT;AAGFD,QAAAA,EAAE,EAAE,KAAKD,GAHP;AAIFyB,QAAAA,UAAU,EAAE,KAAKnC,WAJf;AAKFoC,QAAAA,WAAW,EAAE,KAAKjB,YALhB;AAMFV,QAAAA,SAAS,EAAE,KAAKS,UANd;AAOFnB,QAAAA,IAAI,EAAGA,IAAI,IAAIA,IAAI,CAACsC,QAAL,EAAT,IAA6B;AAPjC,OAAD,CAAH;AASD;AAED;AACF;AACA;AACA;;;;WACE,cAAMtC,IAAN,EAAY;AACV,WAAK8B,IAAL,CAAU,MAAV;;AACA,WAAKC,KAAL,CAAWQ,IAAX,CAAgBvC,IAAhB;AACD;AAED;AACF;AACA;AACA;;;;WACE,eAAON,GAAP,EAAY;AACV,WAAKoC,IAAL,CAAU,OAAV,EAAmBpC,GAAnB;;AACA,UAAI,CAAC,KAAK0B,YAAV,EAAwB;AACtB,aAAKA,YAAL,GAAoB1B,GAAG,IAAI,IAA3B;;AACA,aAAKqC,KAAL,CAAWhC,GAAX,CAAe,KAAKqB,YAApB;;AACA,aAAKf,IAAL,CAAU,OAAV,EAAmBX,GAAnB;AACA,aAAKsB,IAAL,GAAY,IAAZ;AACD;AACF;AAED;AACF;AACA;AACA;;;;WACE,iBAAStB,GAAT,EAAc;AACZ,WAAKoC,IAAL,CAAU,SAAV,EAAqBpC,GAArB;;AACA,WAAKS,QAAL,GAAgBT,GAAG,IAAI,oBAAvB;AACA,WAAK8C,KAAL,CAAW,KAAKrC,QAAhB;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,kBAAUW,IAAV,EAAgB;AACd,UAAI,KAAKI,IAAT,EAAe;AAAE;AAAQ,OADX,CACY;;;AAE1B,WAAKA,IAAL,GAAY,IAAZ;;AACA,WAAKH,KAAL,CAAWwB,IAAX,CAAgB,CACd,KAAK5B,GADS,EAEdpB,KAAK,CAACkD,GAFQ,EAGd3B,IAAI,KAAK,KAAKH,GAAL,CAAS2B,QAAT,EAAT,GAA+BxB,IAA/B,GAAsC,KAAKH,GAAL,CAAS2B,QAAT,EAHxB,CAAhB;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,iBAAStC,IAAT,EAAe;AACb,WAAK8B,IAAL,CAAU,SAAV,EAAqB9B,IAArB;;AAEA,UAAI,CAAC,KAAKkB,IAAV,EAAgB;AACd,aAAKwB,QAAL,CAAc,KAAK5B,IAAnB;AACD;;AAED,WAAKC,KAAL,CAAWwB,IAAX,CAAgB,CACd,KAAK5B,GADS,EAEd,KAAKU,GAFS,EAGdrB,IAHc,CAAhB;AAKD;AAED;AACF;AACA;AACA;;;;WACE,mBAAW;AACT,WAAK8B,IAAL,CAAU,SAAV;;AAEA,UAAI,CAAC,KAAKZ,IAAV,EAAgB;AACd;AACD;;AAED,WAAKH,KAAL,CAAWwB,IAAX,CAAgB,CACd,KAAK5B,GADS,EAEd,KAAKa,GAFS,CAAhB;AAID;AAED;AACF;AACA;AACA;;;;WACE,uBAAe;AACb,WAAKM,IAAL,CAAU,aAAV;;AAEA,UAAI,CAAC,KAAKZ,IAAV,EAAgB;AACd;AACD;;AAED,WAAKH,KAAL,CAAWwB,IAAX,CAAgB,CACd,KAAK5B,GADS,EAEd,KAAKgB,KAFS,CAAhB;AAID;;;;EAlMmBtC,E;;AAqMtBsD,MAAM,CAACC,OAAP,GAAiBpC,OAAjB","sourcesContent":["'use strict'\n\nconst pushable = require('pull-pushable')\nconst looper = require('looper')\nconst nextTick = require('async/nextTick')\nconst EE = require('events')\nconst debug = require('debug')\n\nconst { Types } = require('./consts')\nconst { emitError } = require('./util')\n\nconst log = debug('pull-plex:chan')\nlog.err = debug('pull-plex:chan:err')\n\n/**\n * Creates a pull-stream sink for the given Channel\n * @private\n * @param {Channel} channel\n * @returns {function} The sink function\n */\nfunction channelSink (channel) {\n  return function (read) {\n    const next = looper(function () {\n      read(null, function (end, data) {\n        // stream already ended\n        if (channel._endedLocal) { return }\n\n        channel._endedLocal = end || false\n\n        // source ended, close the stream\n        if (end === true) {\n          return channel.endChan()\n        }\n\n        // source errored, destroy stream\n        if (end || channel._destroy) {\n          channel.destroyChan()\n          channel.emit('error', end || channel._destroy)\n          channel.destroy()\n          return\n        }\n\n        // just send\n        channel.sendMsg(data)\n        next()\n      })\n    })\n\n    next()\n  }\n}\n\n/**\n * @fires Channel#close\n * @fires Channel#error\n */\nclass Channel extends EE {\n  /**\n   * @constructor\n   * @param {Object} opts\n   * @param {number} opts.id\n   * @param {boolean} opts.initiator\n   * @param {string} opts.name\n   * @param {boolean} opts.open\n   * @param {Mplex} opts.plex\n   */\n  constructor (opts) {\n    super()\n\n    opts = { initiator: false, ...opts }\n\n    this._id = opts.id\n    this._name = opts.name\n    this._plex = opts.plex\n    this._open = opts.open\n    this._initiator = opts.initiator\n    this._endedRemote = false // remote stream ended\n    this._endedLocal = false // local stream ended\n    this._destroy = false\n\n    this.MSG = this._initiator\n      ? Types.OUT_MESSAGE\n      : Types.IN_MESSAGE\n\n    this.END = this._initiator\n      ? Types.OUT_CLOSE\n      : Types.IN_CLOSE\n\n    this.RESET = this._initiator\n      ? Types.OUT_RESET\n      : Types.IN_RESET\n\n    this._log('new channel', this._name)\n\n    this._msgs = pushable((err) => {\n      this._log('source closed', err)\n      if (err && typeof err !== 'boolean') {\n        nextTick(emitError, this, err)\n      }\n      // this.endChan() // Do not uncomment this, it will end the channel too early\n    })\n\n    this._source = this._msgs\n    this.sink = channelSink(this)\n  }\n\n  get source () {\n    return this._source\n  }\n\n  get id () {\n    return this._id\n  }\n\n  get open () {\n    return this._open\n  }\n\n  set open (open) {\n    this._open = open\n  }\n\n  get name () {\n    return this._name\n  }\n\n  get destroyed () {\n    return this._endedRemote && this._endedLocal\n  }\n\n  /**\n   * A convenience wrapper for the log that adds useful metadata to logs\n   * @private\n   * @param {string} name The name of the operation being logged\n   * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`\n   */\n  _log (name, data) {\n    if (!log.enabled) return\n    log({\n      op: name,\n      name: this._name,\n      id: this._id,\n      endedLocal: this._endedLocal,\n      endedRemote: this._endedRemote,\n      initiator: this._initiator,\n      data: (data && data.toString()) || ''\n    })\n  }\n\n  /**\n   * Pushes `data` into the channel\n   * @param {Buffer} data\n   */\n  push (data) {\n    this._log('push')\n    this._msgs.push(data)\n  }\n\n  /**\n   * Closes the channel for writing\n   * @param {Error} err\n   */\n  close (err) {\n    this._log('close', err)\n    if (!this._endedRemote) {\n      this._endedRemote = err || true\n      this._msgs.end(this._endedRemote)\n      this.emit('close', err)\n      this.plex = null\n    }\n  }\n\n  /**\n   * Closes the channel with the given error\n   * @param {Error} err Default: `'channel destroyed!'`\n   */\n  destroy (err) {\n    this._log('destroy', err)\n    this._destroy = err || 'channel destroyed!'\n    this.close(this._destroy)\n  }\n\n  /**\n   * Opens the channel if it's not already open. Attempting\n   * to open an already opened channel is ignored.\n   * @param {string} name\n   */\n  openChan (name) {\n    if (this.open) { return } // chan already open\n\n    this.open = true\n    this._plex.push([\n      this._id,\n      Types.NEW,\n      name !== this._id.toString() ? name : this._id.toString()\n    ])\n  }\n\n  /**\n   * Pushes `data` wrapped in a `Message` into the channel.\n   * If the channel is not open, it will be opened automatically.\n   *\n   * @param {Buffer} data\n   */\n  sendMsg (data) {\n    this._log('sendMsg', data)\n\n    if (!this.open) {\n      this.openChan(this.name)\n    }\n\n    this._plex.push([\n      this._id,\n      this.MSG,\n      data\n    ])\n  }\n\n  /**\n   * Ends the channel by sending an END `Message`.\n   * If the channel is not open, no action will be taken.\n   */\n  endChan () {\n    this._log('endChan')\n\n    if (!this.open) {\n      return\n    }\n\n    this._plex.push([\n      this._id,\n      this.END\n    ])\n  }\n\n  /**\n   * Destroys the channel by sending a RESET `Message`.\n   * If the channel is not open, no action will be taken.\n   */\n  destroyChan () {\n    this._log('destroyChan')\n\n    if (!this.open) {\n      return\n    }\n\n    this._plex.push([\n      this._id,\n      this.RESET\n    ])\n  }\n}\n\nmodule.exports = Channel\n"]},"metadata":{},"sourceType":"script"}