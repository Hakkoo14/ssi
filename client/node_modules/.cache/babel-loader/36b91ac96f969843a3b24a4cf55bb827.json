{"ast":null,"code":"'use strict';\n\nvar pull = require('pull-stream/pull');\n\nvar map = require('pull-stream/throughs/map');\n\nvar asyncMap = require('pull-stream/throughs/async-map');\n\nvar lp = require('pull-length-prefixed');\n\nvar lpOpts = {\n  fixed: true,\n  bytes: 4\n};\n\nexports.createBoxStream = function (cipher, mac) {\n  return pull(ensureBuffer(), asyncMap(function (chunk, cb) {\n    cipher.encrypt(chunk, function (err, data) {\n      if (err) {\n        return cb(err);\n      }\n\n      mac.digest(data, function (err, digest) {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(null, Buffer.concat([data, digest]));\n      });\n    });\n  }), lp.encode(lpOpts));\n};\n\nexports.createUnboxStream = function (decipher, mac) {\n  return pull(ensureBuffer(), lp.decode(lpOpts), asyncMap(function (chunk, cb) {\n    var l = chunk.length;\n    var macSize = mac.length;\n\n    if (l < macSize) {\n      return cb(new Error(\"buffer (\".concat(l, \") shorter than MAC size (\").concat(macSize, \")\")));\n    }\n\n    var mark = l - macSize;\n    var data = chunk.slice(0, mark);\n    var macd = chunk.slice(mark);\n    mac.digest(data, function (err, expected) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (!macd.equals(expected)) {\n        return cb(new Error(\"MAC Invalid: \".concat(macd.toString('hex'), \" != \").concat(expected.toString('hex'))));\n      } // all good, decrypt\n\n\n      decipher.decrypt(data, function (err, decrypted) {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(null, decrypted);\n      });\n    });\n  }));\n};\n\nfunction ensureBuffer() {\n  return map(function (c) {\n    if (typeof c === 'string') {\n      return Buffer.from(c, 'utf-8');\n    }\n\n    return c;\n  });\n}","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-secio/src/etm.js"],"names":["pull","require","map","asyncMap","lp","lpOpts","fixed","bytes","exports","createBoxStream","cipher","mac","ensureBuffer","chunk","cb","encrypt","err","data","digest","Buffer","concat","encode","createUnboxStream","decipher","decode","l","length","macSize","Error","mark","slice","macd","expected","equals","toString","decrypt","decrypted","c","from"],"mappings":"AAAA;;AAEA,IAAMA,IAAI,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,IAAMC,GAAG,GAAGD,OAAO,CAAC,0BAAD,CAAnB;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAC,gCAAD,CAAxB;;AACA,IAAMG,EAAE,GAAGH,OAAO,CAAC,sBAAD,CAAlB;;AAEA,IAAMI,MAAM,GAAG;AACbC,EAAAA,KAAK,EAAE,IADM;AAEbC,EAAAA,KAAK,EAAE;AAFM,CAAf;;AAKAC,OAAO,CAACC,eAAR,GAA0B,UAACC,MAAD,EAASC,GAAT,EAAiB;AACzC,SAAOX,IAAI,CACTY,YAAY,EADH,EAETT,QAAQ,CAAC,UAACU,KAAD,EAAQC,EAAR,EAAe;AACtBJ,IAAAA,MAAM,CAACK,OAAP,CAAeF,KAAf,EAAsB,UAACG,GAAD,EAAMC,IAAN,EAAe;AACnC,UAAID,GAAJ,EAAS;AACP,eAAOF,EAAE,CAACE,GAAD,CAAT;AACD;;AAEDL,MAAAA,GAAG,CAACO,MAAJ,CAAWD,IAAX,EAAiB,UAACD,GAAD,EAAME,MAAN,EAAiB;AAChC,YAAIF,GAAJ,EAAS;AACP,iBAAOF,EAAE,CAACE,GAAD,CAAT;AACD;;AAEDF,QAAAA,EAAE,CAAC,IAAD,EAAOK,MAAM,CAACC,MAAP,CAAc,CAACH,IAAD,EAAOC,MAAP,CAAd,CAAP,CAAF;AACD,OAND;AAOD,KAZD;AAaD,GAdO,CAFC,EAiBTd,EAAE,CAACiB,MAAH,CAAUhB,MAAV,CAjBS,CAAX;AAmBD,CApBD;;AAsBAG,OAAO,CAACc,iBAAR,GAA4B,UAACC,QAAD,EAAWZ,GAAX,EAAmB;AAC7C,SAAOX,IAAI,CACTY,YAAY,EADH,EAETR,EAAE,CAACoB,MAAH,CAAUnB,MAAV,CAFS,EAGTF,QAAQ,CAAC,UAACU,KAAD,EAAQC,EAAR,EAAe;AACtB,QAAMW,CAAC,GAAGZ,KAAK,CAACa,MAAhB;AACA,QAAMC,OAAO,GAAGhB,GAAG,CAACe,MAApB;;AAEA,QAAID,CAAC,GAAGE,OAAR,EAAiB;AACf,aAAOb,EAAE,CAAC,IAAIc,KAAJ,mBAAqBH,CAArB,sCAAkDE,OAAlD,OAAD,CAAT;AACD;;AAED,QAAME,IAAI,GAAGJ,CAAC,GAAGE,OAAjB;AACA,QAAMV,IAAI,GAAGJ,KAAK,CAACiB,KAAN,CAAY,CAAZ,EAAeD,IAAf,CAAb;AACA,QAAME,IAAI,GAAGlB,KAAK,CAACiB,KAAN,CAAYD,IAAZ,CAAb;AAEAlB,IAAAA,GAAG,CAACO,MAAJ,CAAWD,IAAX,EAAiB,UAACD,GAAD,EAAMgB,QAAN,EAAmB;AAClC,UAAIhB,GAAJ,EAAS;AACP,eAAOF,EAAE,CAACE,GAAD,CAAT;AACD;;AAED,UAAI,CAACe,IAAI,CAACE,MAAL,CAAYD,QAAZ,CAAL,EAA4B;AAC1B,eAAOlB,EAAE,CAAC,IAAIc,KAAJ,wBAA0BG,IAAI,CAACG,QAAL,CAAc,KAAd,CAA1B,iBAAqDF,QAAQ,CAACE,QAAT,CAAkB,KAAlB,CAArD,EAAD,CAAT;AACD,OAPiC,CASlC;;;AACAX,MAAAA,QAAQ,CAACY,OAAT,CAAiBlB,IAAjB,EAAuB,UAACD,GAAD,EAAMoB,SAAN,EAAoB;AACzC,YAAIpB,GAAJ,EAAS;AACP,iBAAOF,EAAE,CAACE,GAAD,CAAT;AACD;;AAEDF,QAAAA,EAAE,CAAC,IAAD,EAAOsB,SAAP,CAAF;AACD,OAND;AAOD,KAjBD;AAkBD,GA9BO,CAHC,CAAX;AAmCD,CApCD;;AAsCA,SAASxB,YAAT,GAAyB;AACvB,SAAOV,GAAG,CAAC,UAACmC,CAAD,EAAO;AAChB,QAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AACzB,aAAOlB,MAAM,CAACmB,IAAP,CAAYD,CAAZ,EAAe,OAAf,CAAP;AACD;;AAED,WAAOA,CAAP;AACD,GANS,CAAV;AAOD","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream/pull')\nconst map = require('pull-stream/throughs/map')\nconst asyncMap = require('pull-stream/throughs/async-map')\nconst lp = require('pull-length-prefixed')\n\nconst lpOpts = {\n  fixed: true,\n  bytes: 4\n}\n\nexports.createBoxStream = (cipher, mac) => {\n  return pull(\n    ensureBuffer(),\n    asyncMap((chunk, cb) => {\n      cipher.encrypt(chunk, (err, data) => {\n        if (err) {\n          return cb(err)\n        }\n\n        mac.digest(data, (err, digest) => {\n          if (err) {\n            return cb(err)\n          }\n\n          cb(null, Buffer.concat([data, digest]))\n        })\n      })\n    }),\n    lp.encode(lpOpts)\n  )\n}\n\nexports.createUnboxStream = (decipher, mac) => {\n  return pull(\n    ensureBuffer(),\n    lp.decode(lpOpts),\n    asyncMap((chunk, cb) => {\n      const l = chunk.length\n      const macSize = mac.length\n\n      if (l < macSize) {\n        return cb(new Error(`buffer (${l}) shorter than MAC size (${macSize})`))\n      }\n\n      const mark = l - macSize\n      const data = chunk.slice(0, mark)\n      const macd = chunk.slice(mark)\n\n      mac.digest(data, (err, expected) => {\n        if (err) {\n          return cb(err)\n        }\n\n        if (!macd.equals(expected)) {\n          return cb(new Error(`MAC Invalid: ${macd.toString('hex')} != ${expected.toString('hex')}`))\n        }\n\n        // all good, decrypt\n        decipher.decrypt(data, (err, decrypted) => {\n          if (err) {\n            return cb(err)\n          }\n\n          cb(null, decrypted)\n        })\n      })\n    })\n  )\n}\n\nfunction ensureBuffer () {\n  return map((c) => {\n    if (typeof c === 'string') {\n      return Buffer.from(c, 'utf-8')\n    }\n\n    return c\n  })\n}\n"]},"metadata":{},"sourceType":"script"}