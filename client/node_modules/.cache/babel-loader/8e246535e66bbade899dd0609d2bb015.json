{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar FSM = require('fsm-event');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar debug = require('debug');\n\nvar log = debug('libp2p');\nlog.error = debug('libp2p:error');\n\nvar errCode = require('err-code');\n\nvar each = require('async/each');\n\nvar series = require('async/series');\n\nvar parallel = require('async/parallel');\n\nvar nextTick = require('async/nextTick');\n\nvar PeerBook = require('peer-book');\n\nvar PeerInfo = require('peer-info');\n\nvar Switch = require('libp2p-switch');\n\nvar Ping = require('libp2p-ping');\n\nvar WebSockets = require('libp2p-websockets');\n\nvar ConnectionManager = require('libp2p-connection-manager');\n\nvar _require = require('./util'),\n    emitFirst = _require.emitFirst;\n\nvar peerRouting = require('./peer-routing');\n\nvar contentRouting = require('./content-routing');\n\nvar dht = require('./dht');\n\nvar pubsub = require('./pubsub');\n\nvar getPeerInfo = require('./get-peer-info');\n\nvar validateConfig = require('./config').validate;\n\nvar _require2 = require('./errors'),\n    codes = _require2.codes;\n\nvar notStarted = function notStarted(action, state) {\n  return errCode(new Error(\"libp2p cannot \".concat(action, \" when not started; state is \").concat(state)), codes.ERR_NODE_NOT_STARTED);\n};\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n * @fires Libp2p#start Emitted when the node and its services has started\n * @fires Libp2p#stop Emitted when the node and its services has stopped\n */\n\n\nvar Libp2p = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Libp2p, _EventEmitter);\n\n  var _super = _createSuper(Libp2p);\n\n  function Libp2p(_options) {\n    var _this;\n\n    _classCallCheck(this, Libp2p);\n\n    _this = _super.call(this); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    _this._options = validateConfig(_options);\n    _this.datastore = _this._options.datastore;\n    _this.peerInfo = _this._options.peerInfo;\n    _this.peerBook = _this._options.peerBook || new PeerBook();\n    _this._modules = _this._options.modules;\n    _this._config = _this._options.config;\n    _this._transport = []; // Transport instances/references\n\n    _this._discovery = []; // Discovery service instances/references\n    // create the switch, and listen for errors\n\n    _this._switch = new Switch(_this.peerInfo, _this.peerBook, _this._options.switch);\n\n    _this._switch.on('error', function () {\n      var _this2;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_this2 = _this).emit.apply(_this2, ['error'].concat(args));\n    });\n\n    _this.stats = _this._switch.stats;\n    _this.connectionManager = new ConnectionManager(_assertThisInitialized(_this), _this._options.connectionManager); // Attach stream multiplexers\n\n    if (_this._modules.streamMuxer) {\n      var muxers = _this._modules.streamMuxer;\n      muxers.forEach(function (muxer) {\n        return _this._switch.connection.addStreamMuxer(muxer);\n      }); // If muxer exists\n      //   we can use Identify\n\n      _this._switch.connection.reuse(); //   we can use Relay for listening/dialing\n\n\n      _this._switch.connection.enableCircuitRelay(_this._config.relay); // Received incomming dial and muxer upgrade happened,\n      // reuse this muxed connection\n\n\n      _this._switch.on('peer-mux-established', function (peerInfo) {\n        _this.emit('peer:connect', peerInfo);\n      });\n\n      _this._switch.on('peer-mux-closed', function (peerInfo) {\n        _this.emit('peer:disconnect', peerInfo);\n      });\n    } // Events for anytime connections are created/removed\n\n\n    _this._switch.on('connection:start', function (peerInfo) {\n      _this.emit('connection:start', peerInfo);\n    });\n\n    _this._switch.on('connection:end', function (peerInfo) {\n      _this.emit('connection:end', peerInfo);\n    }); // Attach crypto channels\n\n\n    if (_this._modules.connEncryption) {\n      var cryptos = _this._modules.connEncryption;\n      cryptos.forEach(function (crypto) {\n        _this._switch.connection.crypto(crypto.tag, crypto.encrypt);\n      });\n    } // Attach private network protector\n\n\n    if (_this._modules.connProtector) {\n      _this._switch.protector = _this._modules.connProtector;\n    } else if (process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (_this._config.dht.enabled) {\n      var DHT = _this._modules.dht;\n      _this._dht = new DHT(_this._switch, _objectSpread({\n        datastore: _this.datastore\n      }, _this._config.dht));\n    } // enable/disable pubsub\n\n\n    if (_this._config.EXPERIMENTAL.pubsub) {\n      _this.pubsub = pubsub(_assertThisInitialized(_this));\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    _this.peerRouting = peerRouting(_assertThisInitialized(_this));\n    _this.contentRouting = contentRouting(_assertThisInitialized(_this));\n    _this.dht = dht(_assertThisInitialized(_this));\n    _this._getPeerInfo = getPeerInfo(_assertThisInitialized(_this)); // Mount default protocols\n\n    Ping.mount(_this._switch);\n    _this.state = new FSM('STOPPED', {\n      STOPPED: {\n        start: 'STARTING',\n        stop: 'STOPPED'\n      },\n      STARTING: {\n        done: 'STARTED',\n        abort: 'STOPPED',\n        stop: 'STOPPING'\n      },\n      STARTED: {\n        stop: 'STOPPING',\n        start: 'STARTED'\n      },\n      STOPPING: {\n        stop: 'STOPPING',\n        done: 'STOPPED'\n      }\n    });\n\n    _this.state.on('STARTING', function () {\n      log('libp2p is starting');\n\n      _this._onStarting();\n    });\n\n    _this.state.on('STOPPING', function () {\n      log('libp2p is stopping');\n\n      _this._onStopping();\n    });\n\n    _this.state.on('STARTED', function () {\n      log('libp2p has started');\n\n      _this.emit('start');\n    });\n\n    _this.state.on('STOPPED', function () {\n      log('libp2p has stopped');\n\n      _this.emit('stop');\n    });\n\n    _this.state.on('error', function (err) {\n      log.error(err);\n\n      _this.emit('error', err);\n    }); // Once we start, emit and dial any peers we may have already discovered\n\n\n    _this.state.on('STARTED', function () {\n      _this.peerBook.getAllArray().forEach(function (peerInfo) {\n        _this.emit('peer:discovery', peerInfo);\n\n        _this._maybeConnect(peerInfo);\n      });\n    });\n\n    _this._peerDiscovered = _this._peerDiscovered.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n\n\n  _createClass(Libp2p, [{\n    key: \"emit\",\n    value: function emit(eventName) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      if (eventName === 'error' && !this._events.error) {\n        log.error.apply(log, args);\n      } else {\n        var _get2;\n\n        (_get2 = _get(_getPrototypeOf(Libp2p.prototype), \"emit\", this)).call.apply(_get2, [this, eventName].concat(args));\n      }\n    }\n    /**\n     * Starts the libp2p node and all sub services\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      emitFirst(this, ['error', 'start'], callback);\n      this.state('start');\n    }\n    /**\n     * Stop the libp2p node by closing its listeners and open connections\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      emitFirst(this, ['error', 'stop'], callback);\n      this.state('stop');\n    }\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.state ? this.state._state === 'STARTED' : false;\n    }\n    /**\n     * Dials to the provided peer. If successful, the `PeerInfo` of the\n     * peer will be added to the nodes `PeerBook`\n     *\n     * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dial\",\n    value: function dial(peer, callback) {\n      this.dialProtocol(peer, null, callback);\n    }\n    /**\n     * Dials to the provided peer and handshakes with the given protocol.\n     * If successful, the `PeerInfo` of the peer will be added to the nodes `PeerBook`,\n     * and the `Connection` will be sent in the callback\n     *\n     * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n     * @param {string} protocol\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dialProtocol\",\n    value: function dialProtocol(peer, protocol, callback) {\n      var _this3 = this;\n\n      if (!this.isStarted()) {\n        return callback(notStarted('dial', this.state._state));\n      }\n\n      if (typeof protocol === 'function') {\n        callback = protocol;\n        protocol = undefined;\n      }\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this3._switch.dial(peerInfo, protocol, callback);\n      });\n    }\n    /**\n     * Similar to `dial` and `dialProtocol`, but the callback will contain a\n     * Connection State Machine.\n     *\n     * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n     * @param {string} protocol\n     * @param {function(Error, ConnectionFSM)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dialFSM\",\n    value: function dialFSM(peer, protocol, callback) {\n      var _this4 = this;\n\n      if (!this.isStarted()) {\n        return callback(notStarted('dial', this.state._state));\n      }\n\n      if (typeof protocol === 'function') {\n        callback = protocol;\n        protocol = undefined;\n      }\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this4._switch.dialFSM(peerInfo, protocol, callback);\n      });\n    }\n  }, {\n    key: \"hangUp\",\n    value: function hangUp(peer, callback) {\n      var _this5 = this;\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this5._switch.hangUp(peerInfo, callback);\n      });\n    }\n  }, {\n    key: \"ping\",\n    value: function ping(peer, callback) {\n      var _this6 = this;\n\n      if (!this.isStarted()) {\n        return callback(notStarted('ping', this.state._state));\n      }\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, new Ping(_this6._switch, peerInfo));\n      });\n    }\n  }, {\n    key: \"handle\",\n    value: function handle(protocol, handlerFunc, matchFunc) {\n      this._switch.handle(protocol, handlerFunc, matchFunc);\n    }\n  }, {\n    key: \"unhandle\",\n    value: function unhandle(protocol) {\n      this._switch.unhandle(protocol);\n    }\n  }, {\n    key: \"_onStarting\",\n    value: function _onStarting() {\n      var _this7 = this;\n\n      if (!this._modules.transport) {\n        this.emit('error', new Error('no transports were present'));\n        return this.state('abort');\n      }\n\n      var ws; // so that we can have webrtc-star addrs without adding manually the id\n\n      var maOld = [];\n      var maNew = [];\n      this.peerInfo.multiaddrs.toArray().forEach(function (ma) {\n        if (!ma.getPeerId()) {\n          maOld.push(ma);\n          maNew.push(ma.encapsulate('/p2p/' + _this7.peerInfo.id.toB58String()));\n        }\n      });\n      this.peerInfo.multiaddrs.replace(maOld, maNew);\n      var multiaddrs = this.peerInfo.multiaddrs.toArray();\n\n      this._modules.transport.forEach(function (Transport) {\n        var t;\n\n        if (typeof Transport === 'function') {\n          t = new Transport({\n            libp2p: _this7\n          });\n        } else {\n          t = Transport;\n        }\n\n        if (t.filter(multiaddrs).length > 0) {\n          _this7._switch.transport.add(t.tag || t[Symbol.toStringTag], t);\n        } else if (WebSockets.isWebSockets(t)) {\n          // TODO find a cleaner way to signal that a transport is always used\n          // for dialing, even if no listener\n          ws = t;\n        }\n\n        _this7._transport.push(t);\n      });\n\n      series([function (cb) {\n        _this7.connectionManager.start();\n\n        _this7._switch.start(cb);\n      }, function (cb) {\n        if (ws) {\n          // always add dialing on websockets\n          _this7._switch.transport.add(ws.tag || ws.constructor.name, ws);\n        } // detect which multiaddrs we don't have a transport for and remove them\n\n\n        var multiaddrs = _this7.peerInfo.multiaddrs.toArray();\n\n        multiaddrs.forEach(function (multiaddr) {\n          if (!multiaddr.toString().match(/\\/p2p-circuit($|\\/)/) && !_this7._transport.find(function (transport) {\n            return transport.filter(multiaddr).length > 0;\n          })) {\n            _this7.peerInfo.multiaddrs.delete(multiaddr);\n          }\n        });\n        cb();\n      }, function (cb) {\n        if (_this7._dht) {\n          _this7._dht.start(function () {\n            _this7._dht.on('peer', _this7._peerDiscovered);\n\n            cb();\n          });\n        } else {\n          cb();\n        }\n      }, function (cb) {\n        if (_this7._floodSub) {\n          return _this7._floodSub.start(cb);\n        }\n\n        cb();\n      }, // Peer Discovery\n      function (cb) {\n        if (_this7._modules.peerDiscovery) {\n          _this7._setupPeerDiscovery(cb);\n        } else {\n          cb();\n        }\n      }], function (err) {\n        if (err) {\n          log.error(err);\n\n          _this7.emit('error', err);\n\n          return _this7.state('stop');\n        }\n\n        _this7.state('done');\n      });\n    }\n  }, {\n    key: \"_onStopping\",\n    value: function _onStopping() {\n      var _this8 = this;\n\n      series([function (cb) {\n        // stop all discoveries before continuing with shutdown\n        parallel(_this8._discovery.map(function (d) {\n          d.removeListener('peer', _this8._peerDiscovered);\n          return function (_cb) {\n            return d.stop(function (err) {\n              log.error('an error occurred stopping the discovery service', err);\n\n              _cb();\n            });\n          };\n        }), cb);\n      }, function (cb) {\n        if (_this8._floodSub) {\n          return _this8._floodSub.stop(cb);\n        }\n\n        cb();\n      }, function (cb) {\n        if (_this8._dht) {\n          _this8._dht.removeListener('peer', _this8._peerDiscovered);\n\n          return _this8._dht.stop(cb);\n        }\n\n        cb();\n      }, function (cb) {\n        _this8.connectionManager.stop();\n\n        _this8._switch.stop(cb);\n      }, function (cb) {\n        // Ensures idempotent restarts, ignore any errors\n        // from removeAll, they're not useful at this point\n        _this8._switch.transport.removeAll(function () {\n          return cb();\n        });\n      }], function (err) {\n        if (err) {\n          log.error(err);\n\n          _this8.emit('error', err);\n        }\n\n        _this8.state('done');\n      });\n    }\n    /**\n     * Handles discovered peers. Each discovered peer will be emitted via\n     * the `peer:discovery` event. If auto dial is enabled for libp2p\n     * and the current connection count is under the low watermark, the\n     * peer will be dialed.\n     *\n     * TODO: If `peerBook.put` becomes centralized, https://github.com/libp2p/js-libp2p/issues/345,\n     * it would be ideal if only new peers were emitted. Currently, with\n     * other modules adding peers to the `PeerBook` we have no way of knowing\n     * if a peer is new or not, so it has to be emitted.\n     *\n     * @private\n     * @param {PeerInfo} peerInfo\n     */\n\n  }, {\n    key: \"_peerDiscovered\",\n    value: function _peerDiscovered(peerInfo) {\n      if (peerInfo.id.toB58String() === this.peerInfo.id.toB58String()) {\n        log.error(new Error(codes.ERR_DISCOVERED_SELF));\n        return;\n      }\n\n      peerInfo = this.peerBook.put(peerInfo);\n      if (!this.isStarted()) return;\n      this.emit('peer:discovery', peerInfo);\n\n      this._maybeConnect(peerInfo);\n    }\n    /**\n     * Will dial to the given `peerInfo` if the current number of\n     * connected peers is less than the configured `ConnectionManager`\n     * minPeers.\n     * @private\n     * @param {PeerInfo} peerInfo\n     */\n\n  }, {\n    key: \"_maybeConnect\",\n    value: function _maybeConnect(peerInfo) {\n      // If auto dialing is on, check if we should dial\n      if (this._config.peerDiscovery.autoDial === true && !peerInfo.isConnected()) {\n        var minPeers = this._options.connectionManager.minPeers || 0;\n\n        if (minPeers > Object.keys(this._switch.connection.connections).length) {\n          log('connecting to discovered peer');\n\n          this._switch.dialer.connect(peerInfo, function (err) {\n            err && log.error('could not connect to discovered peer', err);\n          });\n        }\n      }\n    }\n    /**\n     * Initializes and starts peer discovery services\n     *\n     * @private\n     * @param {function(Error)} callback\n     */\n\n  }, {\n    key: \"_setupPeerDiscovery\",\n    value: function _setupPeerDiscovery(callback) {\n      var _iterator = _createForOfIteratorHelper(this._modules.peerDiscovery),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var DiscoveryService = _step.value;\n          var config = {\n            enabled: true // on by default\n\n          };\n\n          if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {\n            config = _objectSpread(_objectSpread({}, config), this._config.peerDiscovery[DiscoveryService.tag]);\n          }\n\n          if (config.enabled) {\n            var discoveryService = void 0;\n\n            if (typeof DiscoveryService === 'function') {\n              discoveryService = new DiscoveryService(Object.assign({}, config, {\n                peerInfo: this.peerInfo\n              }));\n            } else {\n              discoveryService = DiscoveryService;\n            }\n\n            discoveryService.on('peer', this._peerDiscovered);\n\n            this._discovery.push(discoveryService);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      each(this._discovery, function (d, cb) {\n        d.start(cb);\n      }, callback);\n    }\n  }]);\n\n  return Libp2p;\n}(EventEmitter);\n\nmodule.exports = Libp2p;\n/**\n * Like `new Libp2p(options)` except it will create a `PeerInfo`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @param {function(Error, Libp2p)} callback\n * @returns {void}\n */\n\nmodule.exports.createLibp2p = function (options, callback) {\n  if (options.peerInfo) {\n    return nextTick(callback, null, new Libp2p(options));\n  }\n\n  PeerInfo.create(function (err, peerInfo) {\n    if (err) return callback(err);\n    options.peerInfo = peerInfo;\n    callback(null, new Libp2p(options));\n  });\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/libp2p/src/index.js"],"names":["FSM","require","EventEmitter","debug","log","error","errCode","each","series","parallel","nextTick","PeerBook","PeerInfo","Switch","Ping","WebSockets","ConnectionManager","emitFirst","peerRouting","contentRouting","dht","pubsub","getPeerInfo","validateConfig","validate","codes","notStarted","action","state","Error","ERR_NODE_NOT_STARTED","Libp2p","_options","datastore","peerInfo","peerBook","_modules","modules","_config","config","_transport","_discovery","_switch","switch","on","args","emit","stats","connectionManager","streamMuxer","muxers","forEach","muxer","connection","addStreamMuxer","reuse","enableCircuitRelay","relay","connEncryption","cryptos","crypto","tag","encrypt","connProtector","protector","process","env","LIBP2P_FORCE_PNET","enabled","DHT","_dht","EXPERIMENTAL","_getPeerInfo","mount","STOPPED","start","stop","STARTING","done","abort","STARTED","STOPPING","_onStarting","_onStopping","err","getAllArray","_maybeConnect","_peerDiscovered","bind","eventName","_events","callback","_state","peer","dialProtocol","protocol","isStarted","undefined","dial","dialFSM","hangUp","handlerFunc","matchFunc","handle","unhandle","transport","ws","maOld","maNew","multiaddrs","toArray","ma","getPeerId","push","encapsulate","id","toB58String","replace","Transport","t","libp2p","filter","length","add","Symbol","toStringTag","isWebSockets","cb","constructor","name","multiaddr","toString","match","find","delete","_floodSub","peerDiscovery","_setupPeerDiscovery","map","d","removeListener","_cb","removeAll","ERR_DISCOVERED_SELF","put","autoDial","isConnected","minPeers","Object","keys","connections","dialer","connect","DiscoveryService","discoveryService","assign","module","exports","createLibp2p","options","create"],"mappings":"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","sourcesContent":["'use strict'\n\nconst FSM = require('fsm-event')\nconst EventEmitter = require('events').EventEmitter\nconst debug = require('debug')\nconst log = debug('libp2p')\nlog.error = debug('libp2p:error')\nconst errCode = require('err-code')\n\nconst each = require('async/each')\nconst series = require('async/series')\nconst parallel = require('async/parallel')\nconst nextTick = require('async/nextTick')\n\nconst PeerBook = require('peer-book')\nconst PeerInfo = require('peer-info')\nconst Switch = require('libp2p-switch')\nconst Ping = require('libp2p-ping')\nconst WebSockets = require('libp2p-websockets')\nconst ConnectionManager = require('libp2p-connection-manager')\n\nconst { emitFirst } = require('./util')\nconst peerRouting = require('./peer-routing')\nconst contentRouting = require('./content-routing')\nconst dht = require('./dht')\nconst pubsub = require('./pubsub')\nconst getPeerInfo = require('./get-peer-info')\nconst validateConfig = require('./config').validate\nconst { codes } = require('./errors')\n\nconst notStarted = (action, state) => {\n  return errCode(\n    new Error(`libp2p cannot ${action} when not started; state is ${state}`),\n    codes.ERR_NODE_NOT_STARTED\n  )\n}\n\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n * @fires Libp2p#start Emitted when the node and its services has started\n * @fires Libp2p#stop Emitted when the node and its services has stopped\n */\nclass Libp2p extends EventEmitter {\n  constructor (_options) {\n    super()\n    // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n    this._options = validateConfig(_options)\n\n    this.datastore = this._options.datastore\n    this.peerInfo = this._options.peerInfo\n    this.peerBook = this._options.peerBook || new PeerBook()\n\n    this._modules = this._options.modules\n    this._config = this._options.config\n    this._transport = [] // Transport instances/references\n    this._discovery = [] // Discovery service instances/references\n\n    // create the switch, and listen for errors\n    this._switch = new Switch(this.peerInfo, this.peerBook, this._options.switch)\n    this._switch.on('error', (...args) => this.emit('error', ...args))\n\n    this.stats = this._switch.stats\n    this.connectionManager = new ConnectionManager(this, this._options.connectionManager)\n\n    // Attach stream multiplexers\n    if (this._modules.streamMuxer) {\n      let muxers = this._modules.streamMuxer\n      muxers.forEach((muxer) => this._switch.connection.addStreamMuxer(muxer))\n\n      // If muxer exists\n      //   we can use Identify\n      this._switch.connection.reuse()\n      //   we can use Relay for listening/dialing\n      this._switch.connection.enableCircuitRelay(this._config.relay)\n\n      // Received incomming dial and muxer upgrade happened,\n      // reuse this muxed connection\n      this._switch.on('peer-mux-established', (peerInfo) => {\n        this.emit('peer:connect', peerInfo)\n      })\n\n      this._switch.on('peer-mux-closed', (peerInfo) => {\n        this.emit('peer:disconnect', peerInfo)\n      })\n    }\n\n    // Events for anytime connections are created/removed\n    this._switch.on('connection:start', (peerInfo) => {\n      this.emit('connection:start', peerInfo)\n    })\n    this._switch.on('connection:end', (peerInfo) => {\n      this.emit('connection:end', peerInfo)\n    })\n\n    // Attach crypto channels\n    if (this._modules.connEncryption) {\n      let cryptos = this._modules.connEncryption\n      cryptos.forEach((crypto) => {\n        this._switch.connection.crypto(crypto.tag, crypto.encrypt)\n      })\n    }\n\n    // Attach private network protector\n    if (this._modules.connProtector) {\n      this._switch.protector = this._modules.connProtector\n    } else if (process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided')\n    }\n\n    // dht provided components (peerRouting, contentRouting, dht)\n    if (this._config.dht.enabled) {\n      const DHT = this._modules.dht\n\n      this._dht = new DHT(this._switch, {\n        datastore: this.datastore,\n        ...this._config.dht\n      })\n    }\n\n    // enable/disable pubsub\n    if (this._config.EXPERIMENTAL.pubsub) {\n      this.pubsub = pubsub(this)\n    }\n\n    // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n    this.peerRouting = peerRouting(this)\n    this.contentRouting = contentRouting(this)\n    this.dht = dht(this)\n\n    this._getPeerInfo = getPeerInfo(this)\n\n    // Mount default protocols\n    Ping.mount(this._switch)\n\n    this.state = new FSM('STOPPED', {\n      STOPPED: {\n        start: 'STARTING',\n        stop: 'STOPPED'\n      },\n      STARTING: {\n        done: 'STARTED',\n        abort: 'STOPPED',\n        stop: 'STOPPING'\n      },\n      STARTED: {\n        stop: 'STOPPING',\n        start: 'STARTED'\n      },\n      STOPPING: {\n        stop: 'STOPPING',\n        done: 'STOPPED'\n      }\n    })\n    this.state.on('STARTING', () => {\n      log('libp2p is starting')\n      this._onStarting()\n    })\n    this.state.on('STOPPING', () => {\n      log('libp2p is stopping')\n      this._onStopping()\n    })\n    this.state.on('STARTED', () => {\n      log('libp2p has started')\n      this.emit('start')\n    })\n    this.state.on('STOPPED', () => {\n      log('libp2p has stopped')\n      this.emit('stop')\n    })\n    this.state.on('error', (err) => {\n      log.error(err)\n      this.emit('error', err)\n    })\n\n    // Once we start, emit and dial any peers we may have already discovered\n    this.state.on('STARTED', () => {\n      this.peerBook.getAllArray().forEach((peerInfo) => {\n        this.emit('peer:discovery', peerInfo)\n        this._maybeConnect(peerInfo)\n      })\n    })\n\n    this._peerDiscovered = this._peerDiscovered.bind(this)\n  }\n\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n  emit (eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      log.error(...args)\n    } else {\n      super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Starts the libp2p node and all sub services\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  start (callback = () => {}) {\n    emitFirst(this, ['error', 'start'], callback)\n    this.state('start')\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  stop (callback = () => {}) {\n    emitFirst(this, ['error', 'stop'], callback)\n    this.state('stop')\n  }\n\n  isStarted () {\n    return this.state ? this.state._state === 'STARTED' : false\n  }\n\n  /**\n   * Dials to the provided peer. If successful, the `PeerInfo` of the\n   * peer will be added to the nodes `PeerBook`\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  dial (peer, callback) {\n    this.dialProtocol(peer, null, callback)\n  }\n\n  /**\n   * Dials to the provided peer and handshakes with the given protocol.\n   * If successful, the `PeerInfo` of the peer will be added to the nodes `PeerBook`,\n   * and the `Connection` will be sent in the callback\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string} protocol\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  dialProtocol (peer, protocol, callback) {\n    if (!this.isStarted()) {\n      return callback(notStarted('dial', this.state._state))\n    }\n\n    if (typeof protocol === 'function') {\n      callback = protocol\n      protocol = undefined\n    }\n\n    this._getPeerInfo(peer, (err, peerInfo) => {\n      if (err) { return callback(err) }\n\n      this._switch.dial(peerInfo, protocol, callback)\n    })\n  }\n\n  /**\n   * Similar to `dial` and `dialProtocol`, but the callback will contain a\n   * Connection State Machine.\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string} protocol\n   * @param {function(Error, ConnectionFSM)} callback\n   * @returns {void}\n   */\n  dialFSM (peer, protocol, callback) {\n    if (!this.isStarted()) {\n      return callback(notStarted('dial', this.state._state))\n    }\n\n    if (typeof protocol === 'function') {\n      callback = protocol\n      protocol = undefined\n    }\n\n    this._getPeerInfo(peer, (err, peerInfo) => {\n      if (err) { return callback(err) }\n\n      this._switch.dialFSM(peerInfo, protocol, callback)\n    })\n  }\n\n  hangUp (peer, callback) {\n    this._getPeerInfo(peer, (err, peerInfo) => {\n      if (err) { return callback(err) }\n\n      this._switch.hangUp(peerInfo, callback)\n    })\n  }\n\n  ping (peer, callback) {\n    if (!this.isStarted()) {\n      return callback(notStarted('ping', this.state._state))\n    }\n\n    this._getPeerInfo(peer, (err, peerInfo) => {\n      if (err) { return callback(err) }\n\n      callback(null, new Ping(this._switch, peerInfo))\n    })\n  }\n\n  handle (protocol, handlerFunc, matchFunc) {\n    this._switch.handle(protocol, handlerFunc, matchFunc)\n  }\n\n  unhandle (protocol) {\n    this._switch.unhandle(protocol)\n  }\n\n  _onStarting () {\n    if (!this._modules.transport) {\n      this.emit('error', new Error('no transports were present'))\n      return this.state('abort')\n    }\n\n    let ws\n\n    // so that we can have webrtc-star addrs without adding manually the id\n    const maOld = []\n    const maNew = []\n    this.peerInfo.multiaddrs.toArray().forEach((ma) => {\n      if (!ma.getPeerId()) {\n        maOld.push(ma)\n        maNew.push(ma.encapsulate('/p2p/' + this.peerInfo.id.toB58String()))\n      }\n    })\n    this.peerInfo.multiaddrs.replace(maOld, maNew)\n\n    const multiaddrs = this.peerInfo.multiaddrs.toArray()\n\n    this._modules.transport.forEach((Transport) => {\n      let t\n\n      if (typeof Transport === 'function') {\n        t = new Transport({ libp2p: this })\n      } else {\n        t = Transport\n      }\n\n      if (t.filter(multiaddrs).length > 0) {\n        this._switch.transport.add(t.tag || t[Symbol.toStringTag], t)\n      } else if (WebSockets.isWebSockets(t)) {\n        // TODO find a cleaner way to signal that a transport is always used\n        // for dialing, even if no listener\n        ws = t\n      }\n      this._transport.push(t)\n    })\n\n    series([\n      (cb) => {\n        this.connectionManager.start()\n        this._switch.start(cb)\n      },\n      (cb) => {\n        if (ws) {\n          // always add dialing on websockets\n          this._switch.transport.add(ws.tag || ws.constructor.name, ws)\n        }\n\n        // detect which multiaddrs we don't have a transport for and remove them\n        const multiaddrs = this.peerInfo.multiaddrs.toArray()\n\n        multiaddrs.forEach((multiaddr) => {\n          if (!multiaddr.toString().match(/\\/p2p-circuit($|\\/)/) &&\n              !this._transport.find((transport) => transport.filter(multiaddr).length > 0)) {\n            this.peerInfo.multiaddrs.delete(multiaddr)\n          }\n        })\n        cb()\n      },\n      (cb) => {\n        if (this._dht) {\n          this._dht.start(() => {\n            this._dht.on('peer', this._peerDiscovered)\n            cb()\n          })\n        } else {\n          cb()\n        }\n      },\n      (cb) => {\n        if (this._floodSub) {\n          return this._floodSub.start(cb)\n        }\n        cb()\n      },\n      // Peer Discovery\n      (cb) => {\n        if (this._modules.peerDiscovery) {\n          this._setupPeerDiscovery(cb)\n        } else {\n          cb()\n        }\n      }\n    ], (err) => {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n        return this.state('stop')\n      }\n      this.state('done')\n    })\n  }\n\n  _onStopping () {\n    series([\n      (cb) => {\n        // stop all discoveries before continuing with shutdown\n        parallel(\n          this._discovery.map((d) => {\n            d.removeListener('peer', this._peerDiscovered)\n            return (_cb) => d.stop((err) => {\n              log.error('an error occurred stopping the discovery service', err)\n              _cb()\n            })\n          }),\n          cb\n        )\n      },\n      (cb) => {\n        if (this._floodSub) {\n          return this._floodSub.stop(cb)\n        }\n        cb()\n      },\n      (cb) => {\n        if (this._dht) {\n          this._dht.removeListener('peer', this._peerDiscovered)\n          return this._dht.stop(cb)\n        }\n        cb()\n      },\n      (cb) => {\n        this.connectionManager.stop()\n        this._switch.stop(cb)\n      },\n      (cb) => {\n        // Ensures idempotent restarts, ignore any errors\n        // from removeAll, they're not useful at this point\n        this._switch.transport.removeAll(() => cb())\n      }\n    ], (err) => {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n      }\n      this.state('done')\n    })\n  }\n\n  /**\n   * Handles discovered peers. Each discovered peer will be emitted via\n   * the `peer:discovery` event. If auto dial is enabled for libp2p\n   * and the current connection count is under the low watermark, the\n   * peer will be dialed.\n   *\n   * TODO: If `peerBook.put` becomes centralized, https://github.com/libp2p/js-libp2p/issues/345,\n   * it would be ideal if only new peers were emitted. Currently, with\n   * other modules adding peers to the `PeerBook` we have no way of knowing\n   * if a peer is new or not, so it has to be emitted.\n   *\n   * @private\n   * @param {PeerInfo} peerInfo\n   */\n  _peerDiscovered (peerInfo) {\n    if (peerInfo.id.toB58String() === this.peerInfo.id.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n    peerInfo = this.peerBook.put(peerInfo)\n\n    if (!this.isStarted()) return\n\n    this.emit('peer:discovery', peerInfo)\n    this._maybeConnect(peerInfo)\n  }\n\n  /**\n   * Will dial to the given `peerInfo` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minPeers.\n   * @private\n   * @param {PeerInfo} peerInfo\n   */\n  _maybeConnect (peerInfo) {\n    // If auto dialing is on, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !peerInfo.isConnected()) {\n      const minPeers = this._options.connectionManager.minPeers || 0\n      if (minPeers > Object.keys(this._switch.connection.connections).length) {\n        log('connecting to discovered peer')\n        this._switch.dialer.connect(peerInfo, (err) => {\n          err && log.error('could not connect to discovered peer', err)\n        })\n      }\n    }\n  }\n\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @private\n   * @param {function(Error)} callback\n   */\n  _setupPeerDiscovery (callback) {\n    for (const DiscoveryService of this._modules.peerDiscovery) {\n      let config = {\n        enabled: true // on by default\n      }\n\n      if (DiscoveryService.tag &&\n        this._config.peerDiscovery &&\n        this._config.peerDiscovery[DiscoveryService.tag]) {\n        config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] }\n      }\n\n      if (config.enabled) {\n        let discoveryService\n\n        if (typeof DiscoveryService === 'function') {\n          discoveryService = new DiscoveryService(Object.assign({}, config, { peerInfo: this.peerInfo }))\n        } else {\n          discoveryService = DiscoveryService\n        }\n\n        discoveryService.on('peer', this._peerDiscovered)\n        this._discovery.push(discoveryService)\n      }\n    }\n\n    each(this._discovery, (d, cb) => {\n      d.start(cb)\n    }, callback)\n  }\n}\n\nmodule.exports = Libp2p\n/**\n * Like `new Libp2p(options)` except it will create a `PeerInfo`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @param {function(Error, Libp2p)} callback\n * @returns {void}\n */\nmodule.exports.createLibp2p = (options, callback) => {\n  if (options.peerInfo) {\n    return nextTick(callback, null, new Libp2p(options))\n  }\n  PeerInfo.create((err, peerInfo) => {\n    if (err) return callback(err)\n    options.peerInfo = peerInfo\n    callback(null, new Libp2p(options))\n  })\n}\n"]},"metadata":{},"sourceType":"script"}