{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar toSources = require('./utils/to-sources');\n\nvar cp = require('./cp');\n\nvar rm = require('./rm');\n\nvar defaultOptions = {\n  parents: false,\n  recursive: false,\n  flush: true,\n  format: 'dag-pb',\n  hashAlg: 'sha2-256',\n  shardSplitThreshold: 1000\n};\n\nmodule.exports = function (context) {\n  return /*#__PURE__*/function () {\n    var _mfsMv = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _len,\n          args,\n          _key,\n          _yield$toSources,\n          sources,\n          options,\n          cpArgs,\n          rmArgs,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = _args[_key];\n              }\n\n              if (Array.isArray(args[0])) {\n                args = args[0].concat(args.slice(1));\n              }\n\n              _context.next = 4;\n              return toSources(context, args);\n\n            case 4:\n              _yield$toSources = _context.sent;\n              sources = _yield$toSources.sources;\n              options = applyDefaultOptions(args, defaultOptions);\n              cpArgs = sources.map(function (source) {\n                return source.path;\n              }).concat(options); // remove the last source as it'll be the destination\n\n              rmArgs = sources.slice(0, -1).map(function (source) {\n                return source.path;\n              }).concat(Object.assign(options, {\n                recursive: true\n              }));\n              _context.next = 11;\n              return cp(context).apply(null, cpArgs);\n\n            case 11:\n              _context.next = 13;\n              return rm(context).apply(null, rmArgs);\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function mfsMv() {\n      return _mfsMv.apply(this, arguments);\n    }\n\n    return mfsMv;\n  }();\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs-mfs/src/core/mv.js"],"names":["applyDefaultOptions","require","toSources","cp","rm","defaultOptions","parents","recursive","flush","format","hashAlg","shardSplitThreshold","module","exports","context","args","Array","isArray","concat","slice","sources","options","cpArgs","map","source","path","rmArgs","Object","assign","apply","mfsMv"],"mappings":"AAAA;;;;;;AAEA,IAAMA,mBAAmB,GAAGC,OAAO,CAAC,+BAAD,CAAnC;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,oBAAD,CAAzB;;AACA,IAAME,EAAE,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAMG,EAAE,GAAGH,OAAO,CAAC,MAAD,CAAlB;;AAEA,IAAMI,cAAc,GAAG;AACrBC,EAAAA,OAAO,EAAE,KADY;AAErBC,EAAAA,SAAS,EAAE,KAFU;AAGrBC,EAAAA,KAAK,EAAE,IAHc;AAIrBC,EAAAA,MAAM,EAAE,QAJa;AAKrBC,EAAAA,OAAO,EAAE,UALY;AAMrBC,EAAAA,mBAAmB,EAAE;AANA,CAAvB;;AASAC,MAAM,CAACC,OAAP,GAAiB,UAACC,OAAD,EAAa;AAC5B;AAAA,0EAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,wCAAyBC,IAAzB;AAAyBA,gBAAAA,IAAzB;AAAA;;AACL,kBAAIC,KAAK,CAACC,OAAN,CAAcF,IAAI,CAAC,CAAD,CAAlB,CAAJ,EAA4B;AAC1BA,gBAAAA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAJ,CAAQG,MAAR,CAAeH,IAAI,CAACI,KAAL,CAAW,CAAX,CAAf,CAAP;AACD;;AAHI;AAAA,qBAOKjB,SAAS,CAACY,OAAD,EAAUC,IAAV,CAPd;;AAAA;AAAA;AAMHK,cAAAA,OANG,oBAMHA,OANG;AAQCC,cAAAA,OARD,GAQWrB,mBAAmB,CAACe,IAAD,EAAOV,cAAP,CAR9B;AAUCiB,cAAAA,MAVD,GAUUF,OAAO,CACnBG,GADY,CACR,UAAAC,MAAM;AAAA,uBAAIA,MAAM,CAACC,IAAX;AAAA,eADE,EACeP,MADf,CACsBG,OADtB,CAVV,EAaL;;AACMK,cAAAA,MAdD,GAcUN,OAAO,CACnBD,KADY,CACN,CADM,EACH,CAAC,CADE,EAEZI,GAFY,CAER,UAAAC,MAAM;AAAA,uBAAIA,MAAM,CAACC,IAAX;AAAA,eAFE,EAGZP,MAHY,CAGLS,MAAM,CAACC,MAAP,CAAcP,OAAd,EAAuB;AAC7Bd,gBAAAA,SAAS,EAAE;AADkB,eAAvB,CAHK,CAdV;AAAA;AAAA,qBAqBCJ,EAAE,CAACW,OAAD,CAAF,CAAYe,KAAZ,CAAkB,IAAlB,EAAwBP,MAAxB,CArBD;;AAAA;AAAA;AAAA,qBAsBClB,EAAE,CAACU,OAAD,CAAF,CAAYe,KAAZ,CAAkB,IAAlB,EAAwBH,MAAxB,CAtBD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAP;;AAAA,aAAsBI,KAAtB;AAAA;AAAA;;AAAA,WAAsBA,KAAtB;AAAA;AAwBD,CAzBD","sourcesContent":["'use strict'\n\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst toSources = require('./utils/to-sources')\nconst cp = require('./cp')\nconst rm = require('./rm')\n\nconst defaultOptions = {\n  parents: false,\n  recursive: false,\n  flush: true,\n  format: 'dag-pb',\n  hashAlg: 'sha2-256',\n  shardSplitThreshold: 1000\n}\n\nmodule.exports = (context) => {\n  return async function mfsMv (...args) {\n    if (Array.isArray(args[0])) {\n      args = args[0].concat(args.slice(1))\n    }\n\n    const {\n      sources\n    } = await toSources(context, args)\n    const options = applyDefaultOptions(args, defaultOptions)\n\n    const cpArgs = sources\n      .map(source => source.path).concat(options)\n\n    // remove the last source as it'll be the destination\n    const rmArgs = sources\n      .slice(0, -1)\n      .map(source => source.path)\n      .concat(Object.assign(options, {\n        recursive: true\n      }))\n\n    await cp(context).apply(null, cpArgs)\n    await rm(context).apply(null, rmArgs)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}