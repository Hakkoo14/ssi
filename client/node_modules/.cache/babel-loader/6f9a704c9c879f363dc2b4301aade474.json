{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar each = require('async/each');\n\nvar many = require('pull-many');\n\nvar pull = require('pull-stream');\n\nvar Key = require('interface-datastore').Key;\n\nvar Errors = require('interface-datastore').Errors;\n\nvar utils = require('interface-datastore').utils;\n\nvar asyncFilter = utils.asyncFilter;\nvar asyncSort = utils.asyncSort;\nvar replaceStartWith = utils.replaceStartWith;\n\nvar Keytransform = require('./keytransform');\n/* ::\nimport type {Datastore, Callback, Batch, Query, QueryResult} from 'interface-datastore'\n\ntype Mount<Value> = {\n  prefix: Key,\n  datastore: Datastore<Value>\n}\n*/\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixs.\n */\n\n\nvar MountDatastore\n/* :: <Value> */\n= /*#__PURE__*/function () {\n  /* :: mounts: Array<Mount<Value>> */\n  function MountDatastore(mounts\n  /* : Array<Mount<Value>> */\n  ) {\n    _classCallCheck(this, MountDatastore);\n\n    this.mounts = mounts.slice();\n  }\n\n  _createClass(MountDatastore, [{\n    key: \"open\",\n    value: function open(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.mounts, function (m, cb) {\n        m.datastore.open(cb);\n      }, callback);\n    }\n    /**\n     * Lookup the matching datastore for the given key.\n     *\n     * @private\n     * @param {Key} key\n     * @returns {{Datastore, Key, Key}}\n     */\n\n  }, {\n    key: \"_lookup\",\n    value: function _lookup(key\n    /* : Key */\n    )\n    /* : ?{datastore: Datastore<Value>, mountpoint: Key, rest: Key} */\n    {\n      var _iterator = _createForOfIteratorHelper(this.mounts),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var mount = _step.value;\n\n          if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n            var s = replaceStartWith(key.toString(), mount.prefix.toString());\n            return {\n              datastore: mount.datastore,\n              mountpoint: mount.prefix,\n              rest: new Key(s)\n            };\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"put\",\n    value: function put(key\n    /* : Key */\n    , value\n    /* : Value */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        return callback(Errors.dbWriteFailedError(new Error('No datastore mounted for this key')));\n      }\n\n      match.datastore.put(match.rest, value, callback);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key\n    /* : Key */\n    , callback\n    /* : Callback<Value> */\n    )\n    /* : void */\n    {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        return callback(Errors.notFoundError(new Error('No datastore mounted for this key')));\n      }\n\n      match.datastore.get(match.rest, callback);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key\n    /* : Key */\n    , callback\n    /* : Callback<bool> */\n    )\n    /* : void */\n    {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        callback(null, false);\n        return;\n      }\n\n      match.datastore.has(match.rest, callback);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key\n    /* : Key */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        return callback(Errors.dbDeleteFailedError(new Error('No datastore mounted for this key')));\n      }\n\n      match.datastore.delete(match.rest, callback);\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.mounts, function (m, cb) {\n        m.datastore.close(cb);\n      }, callback);\n    }\n  }, {\n    key: \"batch\",\n    value: function batch()\n    /* : Batch<Value> */\n    {\n      var _this = this;\n\n      var batchMounts = {};\n\n      var lookup = function lookup(key\n      /* : Key */\n      )\n      /* : {batch: Batch<Value>, rest: Key} */\n      {\n        var match = _this._lookup(key);\n\n        if (match == null) {\n          throw new Error('No datastore mounted for this key');\n        }\n\n        var m = match.mountpoint.toString();\n\n        if (batchMounts[m] == null) {\n          batchMounts[m] = match.datastore.batch();\n        }\n\n        return {\n          batch: batchMounts[m],\n          rest: match.rest\n        };\n      };\n\n      return {\n        put: function put(key\n        /* : Key */\n        , value\n        /* : Value */\n        )\n        /* : void */\n        {\n          var match = lookup(key);\n          match.batch.put(match.rest, value);\n        },\n        delete: function _delete(key\n        /* : Key */\n        )\n        /* : void */\n        {\n          var match = lookup(key);\n          match.batch.delete(match.rest);\n        },\n        commit: function commit(callback\n        /* : Callback<void> */\n        )\n        /* : void */\n        {\n          each(Object.keys(batchMounts), function (p, cb) {\n            batchMounts[p].commit(cb);\n          }, callback);\n        }\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q\n    /* : Query<Value> */\n    )\n    /* : QueryResult<Value> */\n    {\n      var qs = this.mounts.map(function (m) {\n        var ks = new Keytransform(m.datastore, {\n          convert: function convert(key\n          /* : Key */\n          )\n          /* : Key */\n          {\n            throw new Error('should never be called');\n          },\n          invert: function invert(key\n          /* : Key */\n          )\n          /* : Key */\n          {\n            return m.prefix.child(key);\n          }\n        });\n        var prefix;\n\n        if (q.prefix != null) {\n          prefix = replaceStartWith(q.prefix, m.prefix.toString());\n        }\n\n        return ks.query({\n          prefix: prefix,\n          filters: q.filters,\n          keysOnly: q.keysOnly\n        });\n      });\n      var tasks = [many(qs)];\n\n      if (q.filters != null) {\n        tasks = tasks.concat(q.filters.map(function (f) {\n          return asyncFilter(f);\n        }));\n      }\n\n      if (q.orders != null) {\n        tasks = tasks.concat(q.orders.map(function (o) {\n          return asyncSort(o);\n        }));\n      }\n\n      if (q.offset != null) {\n        var i = 0;\n        tasks.push(pull.filter(function () {\n          return i++ >= q.offset;\n        }));\n      }\n\n      if (q.limit != null) {\n        tasks.push(pull.take(q.limit));\n      }\n\n      return pull.apply(null, tasks);\n    }\n  }]);\n\n  return MountDatastore;\n}();\n\nmodule.exports = MountDatastore;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/datastore-core/src/mount.js"],"names":["each","require","many","pull","Key","Errors","utils","asyncFilter","asyncSort","replaceStartWith","Keytransform","MountDatastore","mounts","slice","callback","m","cb","datastore","open","key","mount","prefix","toString","isAncestorOf","s","mountpoint","rest","value","match","_lookup","dbWriteFailedError","Error","put","notFoundError","get","has","dbDeleteFailedError","delete","close","batchMounts","lookup","batch","commit","Object","keys","p","q","qs","map","ks","convert","invert","child","query","filters","keysOnly","tasks","concat","f","orders","o","offset","i","push","filter","limit","take","apply","module","exports"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\nconst each = require('async/each')\nconst many = require('pull-many')\nconst pull = require('pull-stream')\n\nconst Key = require('interface-datastore').Key\nconst Errors = require('interface-datastore').Errors\nconst utils = require('interface-datastore').utils\nconst asyncFilter = utils.asyncFilter\nconst asyncSort = utils.asyncSort\nconst replaceStartWith = utils.replaceStartWith\n\nconst Keytransform = require('./keytransform')\n\n/* ::\nimport type {Datastore, Callback, Batch, Query, QueryResult} from 'interface-datastore'\n\ntype Mount<Value> = {\n  prefix: Key,\n  datastore: Datastore<Value>\n}\n*/\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixs.\n */\nclass MountDatastore /* :: <Value> */ {\n  /* :: mounts: Array<Mount<Value>> */\n\n  constructor (mounts /* : Array<Mount<Value>> */) {\n    this.mounts = mounts.slice()\n  }\n\n  open (callback /* : Callback<void> */) /* : void */ {\n    each(this.mounts, (m, cb) => {\n      m.datastore.open(cb)\n    }, callback)\n  }\n\n  /**\n   * Lookup the matching datastore for the given key.\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{Datastore, Key, Key}}\n   */\n  _lookup (key /* : Key */) /* : ?{datastore: Datastore<Value>, mountpoint: Key, rest: Key} */ {\n    for (let mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        const s = replaceStartWith(key.toString(), mount.prefix.toString())\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix,\n          rest: new Key(s)\n        }\n      }\n    }\n  }\n\n  put (key /* : Key */, value /* : Value */, callback /* : Callback<void> */) /* : void */ {\n    const match = this._lookup(key)\n    if (match == null) {\n      return callback(\n        Errors.dbWriteFailedError(new Error('No datastore mounted for this key'))\n      )\n    }\n\n    match.datastore.put(match.rest, value, callback)\n  }\n\n  get (key /* : Key */, callback /* : Callback<Value> */) /* : void */ {\n    const match = this._lookup(key)\n    if (match == null) {\n      return callback(\n        Errors.notFoundError(new Error('No datastore mounted for this key'))\n      )\n    }\n\n    match.datastore.get(match.rest, callback)\n  }\n\n  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {\n    const match = this._lookup(key)\n    if (match == null) {\n      callback(null, false)\n      return\n    }\n\n    match.datastore.has(match.rest, callback)\n  }\n\n  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {\n    const match = this._lookup(key)\n    if (match == null) {\n      return callback(\n        Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'))\n      )\n    }\n\n    match.datastore.delete(match.rest, callback)\n  }\n\n  close (callback /* : Callback<void> */) /* : void */ {\n    each(this.mounts, (m, cb) => {\n      m.datastore.close(cb)\n    }, callback)\n  }\n\n  batch () /* : Batch<Value> */ {\n    const batchMounts = {}\n    const lookup = (key /* : Key */) /* : {batch: Batch<Value>, rest: Key} */ => {\n      const match = this._lookup(key)\n      if (match == null) {\n        throw new Error('No datastore mounted for this key')\n      }\n\n      const m = match.mountpoint.toString()\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch()\n      }\n\n      return {\n        batch: batchMounts[m],\n        rest: match.rest\n      }\n    }\n\n    return {\n      put: (key /* : Key */, value /* : Value */) /* : void */ => {\n        const match = lookup(key)\n        match.batch.put(match.rest, value)\n      },\n      delete: (key /* : Key */) /* : void */ => {\n        const match = lookup(key)\n        match.batch.delete(match.rest)\n      },\n      commit: (callback /* : Callback<void> */) /* : void */ => {\n        each(Object.keys(batchMounts), (p, cb) => {\n          batchMounts[p].commit(cb)\n        }, callback)\n      }\n    }\n  }\n\n  query (q /* : Query<Value> */) /* : QueryResult<Value> */ {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: (key /* : Key */) /* : Key */ => {\n          throw new Error('should never be called')\n        },\n        invert: (key /* : Key */) /* : Key */ => {\n          return m.prefix.child(key)\n        }\n      })\n\n      let prefix\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString())\n      }\n\n      return ks.query({\n        prefix: prefix,\n        filters: q.filters,\n        keysOnly: q.keysOnly\n      })\n    })\n\n    let tasks = [many(qs)]\n\n    if (q.filters != null) {\n      tasks = tasks.concat(q.filters.map(f => asyncFilter(f)))\n    }\n\n    if (q.orders != null) {\n      tasks = tasks.concat(q.orders.map(o => asyncSort(o)))\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      tasks.push(pull.filter(() => i++ >= q.offset))\n    }\n\n    if (q.limit != null) {\n      tasks.push(pull.take(q.limit))\n    }\n\n    return pull.apply(null, tasks)\n  }\n}\n\nmodule.exports = MountDatastore\n"]},"metadata":{},"sourceType":"script"}