{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar promisify = require('promisify-es6');\n\nvar createLock = require('./utils/create-lock'); // These operations are read-locked at the function level and will execute simultaneously\n\n\nvar readOperations = {\n  stat: require('./stat')\n}; // These operations are locked at the function level and will execute in series\n\nvar writeOperations = {\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm')\n}; // These operations are asynchronous and manage their own locking\n\nvar unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n\nvar wrap = function wrap(_ref) {\n  var options = _ref.options,\n      mfs = _ref.mfs,\n      operations = _ref.operations,\n      lock = _ref.lock;\n  Object.keys(operations).forEach(function (key) {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nvar defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n};\n\nmodule.exports = function (options) {\n  var _Object$assign = Object.assign({}, defaultOptions || {}, options),\n      repoOwner = _Object$assign.repoOwner;\n\n  assert(options.ipld, 'MFS requires an IPLD instance');\n  assert(options.blocks, 'MFS requires an BlockStore instance');\n  assert(options.datastore, 'MFS requires a DataStore instance'); // should be able to remove this when async/await PRs are in for datastore, blockstore & repo\n\n  options.repo = {\n    blocks: {\n      get: promisify(options.blocks.get, {\n        context: options.blocks\n      })\n    },\n    datastore: {\n      open: promisify(options.datastore.open, {\n        context: options.datastore\n      }),\n      get: promisify(options.datastore.get, {\n        context: options.datastore\n      }),\n      put: promisify(options.datastore.put, {\n        context: options.datastore\n      })\n    }\n  };\n  var lock = createLock(repoOwner);\n\n  var readLock = function readLock(operation) {\n    return lock.readLock(operation);\n  };\n\n  var writeLock = function writeLock(operation) {\n    return lock.writeLock(operation);\n  };\n\n  var mfs = {};\n  wrap({\n    options: options,\n    mfs: mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options: options,\n    mfs: mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(function (key) {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs-mfs/src/core/index.js"],"names":["assert","require","promisify","createLock","readOperations","stat","writeOperations","cp","flush","mkdir","mv","rm","unwrappedOperations","write","read","ls","wrap","options","mfs","operations","lock","Object","keys","forEach","key","defaultOptions","repoOwner","ipld","repo","module","exports","assign","blocks","datastore","get","context","open","put","readLock","operation","writeLock"],"mappings":"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","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst promisify = require('promisify-es6')\nconst createLock = require('./utils/create-lock')\n\n// These operations are read-locked at the function level and will execute simultaneously\nconst readOperations = {\n  stat: require('./stat')\n}\n\n// These operations are locked at the function level and will execute in series\nconst writeOperations = {\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm')\n}\n\n// These operations are asynchronous and manage their own locking\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n}\n\nconst wrap = ({\n  options, mfs, operations, lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options))\n  })\n}\n\nconst defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n}\n\nmodule.exports = (options) => {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options)\n\n  assert(options.ipld, 'MFS requires an IPLD instance')\n  assert(options.blocks, 'MFS requires an BlockStore instance')\n  assert(options.datastore, 'MFS requires a DataStore instance')\n\n  // should be able to remove this when async/await PRs are in for datastore, blockstore & repo\n  options.repo = {\n    blocks: {\n      get: promisify(options.blocks.get, {\n        context: options.blocks\n      })\n    },\n    datastore: {\n      open: promisify(options.datastore.open, {\n        context: options.datastore\n      }),\n      get: promisify(options.datastore.get, {\n        context: options.datastore\n      }),\n      put: promisify(options.datastore.put, {\n        context: options.datastore\n      })\n    }\n  }\n\n  const lock = createLock(repoOwner)\n\n  const readLock = (operation) => {\n    return lock.readLock(operation)\n  }\n\n  const writeLock = (operation) => {\n    return lock.writeLock(operation)\n  }\n\n  const mfs = {}\n\n  wrap({\n    options, mfs, operations: readOperations, lock: readLock\n  })\n  wrap({\n    options, mfs, operations: writeOperations, lock: writeLock\n  })\n\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options)\n  })\n\n  return mfs\n}\n"]},"metadata":{},"sourceType":"script"}