{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar once = require('once');\n\nvar PeerId = require('peer-id');\n\nvar waterfall = require('async/waterfall');\n\nvar setImmediate = require('async/setImmediate');\n\nvar multiaddr = require('multiaddr');\n\nvar Connection = require('interface-connection').Connection;\n\nvar utilsFactory = require('./utils');\n\nvar StreamHandler = require('./stream-handler');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:circuit:dialer');\nlog.err = debug('libp2p:circuit:error:dialer');\n\nvar multicodec = require('../multicodec');\n\nvar proto = require('../protocol');\n\nvar Dialer = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of Dialer.\n   * @param {Swarm} swarm - the swarm\n   * @param {any} options - config options\n   *\n   * @memberOf Dialer\n   */\n  function Dialer(swarm, options) {\n    _classCallCheck(this, Dialer);\n\n    this.swarm = swarm;\n    this.relayPeers = new Map();\n    this.relayConns = new Map();\n    this.options = options;\n    this.utils = utilsFactory(swarm);\n  }\n  /**\n   * Helper that returns a relay connection\n   *\n   * @param {*} relay\n   * @param {*} callback\n   * @returns {Function} - callback\n   */\n\n\n  _createClass(Dialer, [{\n    key: \"_dialRelayHelper\",\n    value: function _dialRelayHelper(relay, callback) {\n      if (this.relayConns.has(relay.id.toB58String())) {\n        return callback(null, this.relayConns.get(relay.id.toB58String()));\n      }\n\n      return this._dialRelay(relay, callback);\n    }\n    /**\n     * Dial a peer over a relay\n     *\n     * @param {multiaddr} ma - the multiaddr of the peer to dial\n     * @param {Function} cb - a callback called once dialed\n     * @returns {Connection} - the connection\n     *\n     */\n\n  }, {\n    key: \"dial\",\n    value: function dial(ma, cb) {\n      cb = cb || function () {};\n\n      var strMa = ma.toString();\n\n      if (!strMa.includes('/p2p-circuit')) {\n        log.err('invalid circuit address');\n        return cb(new Error('invalid circuit address'));\n      }\n\n      var addr = strMa.split('p2p-circuit'); // extract relay address if any\n\n      var relay = addr[0] === '/' ? null : multiaddr(addr[0]);\n      var peer = multiaddr(addr[1] || addr[0]);\n      var dstConn = new Connection();\n      setImmediate(this._dialPeer.bind(this), peer, relay, function (err, conn) {\n        if (err) {\n          log.err(err);\n          return cb(err);\n        }\n\n        dstConn.setInnerConn(conn);\n        cb(null, dstConn);\n      });\n      return dstConn;\n    }\n    /**\n     * Does the peer support the HOP protocol\n     *\n     * @param {PeerInfo} peer\n     * @param {Function} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"canHop\",\n    value: function canHop(peer, callback) {\n      var _this = this;\n\n      callback = once(callback || function () {});\n\n      this._dialRelayHelper(peer, function (err, conn) {\n        if (err) {\n          return callback(err);\n        }\n\n        var sh = new StreamHandler(conn);\n        waterfall([function (cb) {\n          return sh.write(proto.CircuitRelay.encode({\n            type: proto.CircuitRelay.Type.CAN_HOP\n          }), cb);\n        }, function (cb) {\n          return sh.read(cb);\n        }], function (err, msg) {\n          if (err) {\n            return callback(err);\n          }\n\n          var response = proto.CircuitRelay.decode(msg);\n\n          if (response.code !== proto.CircuitRelay.Status.SUCCESS) {\n            var _err = new Error(\"HOP not supported, skipping - \".concat(_this.utils.getB58String(peer)));\n\n            log(_err);\n            return callback(_err);\n          }\n\n          log('HOP supported adding as relay - %s', _this.utils.getB58String(peer));\n\n          _this.relayPeers.set(_this.utils.getB58String(peer), peer);\n\n          sh.close();\n          callback();\n        });\n      });\n    }\n    /**\n     * Dial the destination peer over a relay\n     *\n     * @param {multiaddr} dstMa\n     * @param {Connection|PeerInfo} relay\n     * @param {Function} cb\n     * @return {Function|void}\n     * @private\n     */\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(dstMa, relay, cb) {\n      var _this2 = this;\n\n      if (typeof relay === 'function') {\n        cb = relay;\n        relay = null;\n      }\n\n      if (!cb) {\n        cb = function cb() {};\n      }\n\n      dstMa = multiaddr(dstMa); // if no relay provided, dial on all available relays until one succeeds\n\n      if (!relay) {\n        var relays = Array.from(this.relayPeers.values());\n\n        var next = function next(nextRelay) {\n          if (!nextRelay) {\n            var err = \"no relay peers were found or all relays failed to dial\";\n            log.err(err);\n            return cb(err);\n          }\n\n          return _this2._negotiateRelay(nextRelay, dstMa, function (err, conn) {\n            if (err) {\n              log.err(err);\n              return next(relays.shift());\n            }\n\n            cb(null, conn);\n          });\n        };\n\n        next(relays.shift());\n      } else {\n        return this._negotiateRelay(relay, dstMa, function (err, conn) {\n          if (err) {\n            log.err('An error has occurred negotiating the relay connection', err);\n            return cb(err);\n          }\n\n          return cb(null, conn);\n        });\n      }\n    }\n    /**\n     * Negotiate the relay connection\n     *\n     * @param {Multiaddr|PeerInfo|Connection} relay - the Connection or PeerInfo of the relay\n     * @param {multiaddr} dstMa - the multiaddr of the peer to relay the connection for\n     * @param {Function} callback - a callback which gets the negotiated relay connection\n     * @returns {void}\n     * @private\n     *\n     * @memberOf Dialer\n     */\n\n  }, {\n    key: \"_negotiateRelay\",\n    value: function _negotiateRelay(relay, dstMa, callback) {\n      var _this3 = this;\n\n      dstMa = multiaddr(dstMa);\n      relay = this.utils.peerInfoFromMa(relay);\n\n      var srcMas = this.swarm._peerInfo.multiaddrs.toArray();\n\n      this._dialRelayHelper(relay, function (err, conn) {\n        if (err) {\n          log.err(err);\n          return callback(err);\n        }\n\n        var sh = new StreamHandler(conn);\n        waterfall([function (cb) {\n          log('negotiating relay for peer %s', dstMa.getPeerId());\n          var dstPeerId;\n\n          try {\n            dstPeerId = PeerId.createFromB58String(dstMa.getPeerId()).id;\n          } catch (err) {\n            return cb(err);\n          }\n\n          sh.write(proto.CircuitRelay.encode({\n            type: proto.CircuitRelay.Type.HOP,\n            srcPeer: {\n              id: _this3.swarm._peerInfo.id.id,\n              addrs: srcMas.map(function (addr) {\n                return addr.buffer;\n              })\n            },\n            dstPeer: {\n              id: dstPeerId,\n              addrs: [dstMa.buffer]\n            }\n          }), cb);\n        }, function (cb) {\n          return sh.read(cb);\n        }], function (err, msg) {\n          if (err) {\n            return callback(err);\n          }\n\n          var message = proto.CircuitRelay.decode(msg);\n\n          if (message.type !== proto.CircuitRelay.Type.STATUS) {\n            return callback(new Error(\"Got invalid message type - \" + \"expected \".concat(proto.CircuitRelay.Type.STATUS, \" got \").concat(message.type)));\n          }\n\n          if (message.code !== proto.CircuitRelay.Status.SUCCESS) {\n            return callback(new Error(\"Got \".concat(message.code, \" error code trying to dial over relay\")));\n          }\n\n          callback(null, new Connection(sh.rest()));\n        });\n      });\n    }\n    /**\n     * Dial a relay peer by its PeerInfo\n     *\n     * @param {PeerInfo} peer - the PeerInfo of the relay peer\n     * @param {Function} cb - a callback with the connection to the relay peer\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_dialRelay\",\n    value: function _dialRelay(peer, cb) {\n      cb = once(cb || function () {});\n      this.swarm.dial(peer, multicodec.relay, once(function (err, conn) {\n        if (err) {\n          log.err(err);\n          return cb(err);\n        }\n\n        cb(null, conn);\n      }));\n    }\n  }]);\n\n  return Dialer;\n}();\n\nmodule.exports = Dialer;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-circuit/src/circuit/dialer.js"],"names":["once","require","PeerId","waterfall","setImmediate","multiaddr","Connection","utilsFactory","StreamHandler","debug","log","err","multicodec","proto","Dialer","swarm","options","relayPeers","Map","relayConns","utils","relay","callback","has","id","toB58String","get","_dialRelay","ma","cb","strMa","toString","includes","Error","addr","split","peer","dstConn","_dialPeer","bind","conn","setInnerConn","_dialRelayHelper","sh","write","CircuitRelay","encode","type","Type","CAN_HOP","read","msg","response","decode","code","Status","SUCCESS","getB58String","set","close","dstMa","relays","Array","from","values","next","nextRelay","_negotiateRelay","shift","peerInfoFromMa","srcMas","_peerInfo","multiaddrs","toArray","getPeerId","dstPeerId","createFromB58String","HOP","srcPeer","addrs","map","buffer","dstPeer","message","STATUS","rest","dial","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst once = require('once')\nconst PeerId = require('peer-id')\nconst waterfall = require('async/waterfall')\nconst setImmediate = require('async/setImmediate')\nconst multiaddr = require('multiaddr')\n\nconst Connection = require('interface-connection').Connection\n\nconst utilsFactory = require('./utils')\nconst StreamHandler = require('./stream-handler')\n\nconst debug = require('debug')\nconst log = debug('libp2p:circuit:dialer')\nlog.err = debug('libp2p:circuit:error:dialer')\n\nconst multicodec = require('../multicodec')\nconst proto = require('../protocol')\n\nclass Dialer {\n  /**\n   * Creates an instance of Dialer.\n   * @param {Swarm} swarm - the swarm\n   * @param {any} options - config options\n   *\n   * @memberOf Dialer\n   */\n  constructor (swarm, options) {\n    this.swarm = swarm\n    this.relayPeers = new Map()\n    this.relayConns = new Map()\n    this.options = options\n    this.utils = utilsFactory(swarm)\n  }\n\n  /**\n   * Helper that returns a relay connection\n   *\n   * @param {*} relay\n   * @param {*} callback\n   * @returns {Function} - callback\n   */\n  _dialRelayHelper (relay, callback) {\n    if (this.relayConns.has(relay.id.toB58String())) {\n      return callback(null, this.relayConns.get(relay.id.toB58String()))\n    }\n\n    return this._dialRelay(relay, callback)\n  }\n\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Function} cb - a callback called once dialed\n   * @returns {Connection} - the connection\n   *\n   */\n  dial (ma, cb) {\n    cb = cb || (() => { })\n    const strMa = ma.toString()\n    if (!strMa.includes('/p2p-circuit')) {\n      log.err('invalid circuit address')\n      return cb(new Error('invalid circuit address'))\n    }\n\n    const addr = strMa.split('p2p-circuit') // extract relay address if any\n    const relay = addr[0] === '/' ? null : multiaddr(addr[0])\n    const peer = multiaddr(addr[1] || addr[0])\n\n    const dstConn = new Connection()\n    setImmediate(\n      this._dialPeer.bind(this),\n      peer,\n      relay,\n      (err, conn) => {\n        if (err) {\n          log.err(err)\n          return cb(err)\n        }\n\n        dstConn.setInnerConn(conn)\n        cb(null, dstConn)\n      })\n\n    return dstConn\n  }\n\n  /**\n   * Does the peer support the HOP protocol\n   *\n   * @param {PeerInfo} peer\n   * @param {Function} callback\n   * @returns {void}\n   */\n  canHop (peer, callback) {\n    callback = once(callback || (() => { }))\n\n    this._dialRelayHelper(peer, (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const sh = new StreamHandler(conn)\n      waterfall([\n        (cb) => sh.write(proto.CircuitRelay.encode({\n          type: proto.CircuitRelay.Type.CAN_HOP\n        }), cb),\n        (cb) => sh.read(cb)\n      ], (err, msg) => {\n        if (err) {\n          return callback(err)\n        }\n        const response = proto.CircuitRelay.decode(msg)\n\n        if (response.code !== proto.CircuitRelay.Status.SUCCESS) {\n          const err = new Error(`HOP not supported, skipping - ${this.utils.getB58String(peer)}`)\n          log(err)\n          return callback(err)\n        }\n\n        log('HOP supported adding as relay - %s', this.utils.getB58String(peer))\n        this.relayPeers.set(this.utils.getB58String(peer), peer)\n        sh.close()\n        callback()\n      })\n    })\n  }\n\n  /**\n   * Dial the destination peer over a relay\n   *\n   * @param {multiaddr} dstMa\n   * @param {Connection|PeerInfo} relay\n   * @param {Function} cb\n   * @return {Function|void}\n   * @private\n   */\n  _dialPeer (dstMa, relay, cb) {\n    if (typeof relay === 'function') {\n      cb = relay\n      relay = null\n    }\n\n    if (!cb) {\n      cb = () => {}\n    }\n\n    dstMa = multiaddr(dstMa)\n    // if no relay provided, dial on all available relays until one succeeds\n    if (!relay) {\n      const relays = Array.from(this.relayPeers.values())\n      let next = (nextRelay) => {\n        if (!nextRelay) {\n          let err = `no relay peers were found or all relays failed to dial`\n          log.err(err)\n          return cb(err)\n        }\n\n        return this._negotiateRelay(\n          nextRelay,\n          dstMa,\n          (err, conn) => {\n            if (err) {\n              log.err(err)\n              return next(relays.shift())\n            }\n            cb(null, conn)\n          })\n      }\n      next(relays.shift())\n    } else {\n      return this._negotiateRelay(\n        relay,\n        dstMa,\n        (err, conn) => {\n          if (err) {\n            log.err('An error has occurred negotiating the relay connection', err)\n            return cb(err)\n          }\n\n          return cb(null, conn)\n        })\n    }\n  }\n\n  /**\n   * Negotiate the relay connection\n   *\n   * @param {Multiaddr|PeerInfo|Connection} relay - the Connection or PeerInfo of the relay\n   * @param {multiaddr} dstMa - the multiaddr of the peer to relay the connection for\n   * @param {Function} callback - a callback which gets the negotiated relay connection\n   * @returns {void}\n   * @private\n   *\n   * @memberOf Dialer\n   */\n  _negotiateRelay (relay, dstMa, callback) {\n    dstMa = multiaddr(dstMa)\n    relay = this.utils.peerInfoFromMa(relay)\n    const srcMas = this.swarm._peerInfo.multiaddrs.toArray()\n    this._dialRelayHelper(relay, (err, conn) => {\n      if (err) {\n        log.err(err)\n        return callback(err)\n      }\n      let sh = new StreamHandler(conn)\n      waterfall([\n        (cb) => {\n          log('negotiating relay for peer %s', dstMa.getPeerId())\n          let dstPeerId\n          try {\n            dstPeerId = PeerId.createFromB58String(dstMa.getPeerId()).id\n          } catch (err) {\n            return cb(err)\n          }\n          sh.write(\n            proto.CircuitRelay.encode({\n              type: proto.CircuitRelay.Type.HOP,\n              srcPeer: {\n                id: this.swarm._peerInfo.id.id,\n                addrs: srcMas.map((addr) => addr.buffer)\n              },\n              dstPeer: {\n                id: dstPeerId,\n                addrs: [dstMa.buffer]\n              }\n            }), cb)\n        },\n        (cb) => sh.read(cb)\n      ], (err, msg) => {\n        if (err) {\n          return callback(err)\n        }\n        const message = proto.CircuitRelay.decode(msg)\n        if (message.type !== proto.CircuitRelay.Type.STATUS) {\n          return callback(new Error(`Got invalid message type - ` +\n            `expected ${proto.CircuitRelay.Type.STATUS} got ${message.type}`))\n        }\n\n        if (message.code !== proto.CircuitRelay.Status.SUCCESS) {\n          return callback(new Error(`Got ${message.code} error code trying to dial over relay`))\n        }\n\n        callback(null, new Connection(sh.rest()))\n      })\n    })\n  }\n\n  /**\n   * Dial a relay peer by its PeerInfo\n   *\n   * @param {PeerInfo} peer - the PeerInfo of the relay peer\n   * @param {Function} cb - a callback with the connection to the relay peer\n   * @returns {void}\n   * @private\n   */\n  _dialRelay (peer, cb) {\n    cb = once(cb || (() => { }))\n\n    this.swarm.dial(\n      peer,\n      multicodec.relay,\n      once((err, conn) => {\n        if (err) {\n          log.err(err)\n          return cb(err)\n        }\n        cb(null, conn)\n      }))\n  }\n}\n\nmodule.exports = Dialer\n"]},"metadata":{},"sourceType":"script"}