{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar uuid = require('uuid/v4');\n\nvar withIs = require('class-is');\n\nvar pathSepS = '/';\nvar pathSepB = Buffer.from(pathSepS);\nvar pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\n\nvar Key = /*#__PURE__*/function () {\n  /* :: _buf: Buffer */\n  function Key(s\n  /* : string|Buffer */\n  , clean\n  /* : ?bool */\n  ) {\n    _classCallCheck(this, Key);\n\n    if (typeof s === 'string') {\n      this._buf = Buffer.from(s);\n    } else if (Buffer.isBuffer(s)) {\n      this._buf = s;\n    }\n\n    if (clean == null) {\n      clean = true;\n    }\n\n    if (clean) {\n      this.clean();\n    }\n\n    if (this._buf.length === 0 || this._buf[0] !== pathSep) {\n      throw new Error(\"Invalid key: \".concat(this.toString()));\n    }\n  }\n  /**\n   * Convert to the string representation\n   *\n   * @param {string} [encoding='utf8']\n   * @returns {string}\n   */\n\n\n  _createClass(Key, [{\n    key: \"toString\",\n    value: function toString(encoding\n    /* : ?buffer$Encoding */\n    )\n    /* : string */\n    {\n      return this._buf.toString(encoding || 'utf8');\n    }\n    /**\n     * Return the buffer representation of the key\n     *\n     * @returns {Buffer}\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer()\n    /* : Buffer */\n    {\n      return this._buf;\n    } // waiting on https://github.com/facebook/flow/issues/2286\n    // $FlowFixMe\n\n  }, {\n    key: Symbol.toStringTag,\n    get: function get()\n    /* : string */\n    {\n      return \"[Key \".concat(this.toString(), \"]\");\n    }\n    /**\n     * Constructs a key out of a namespace array.\n     *\n     * @param {Array<string>} list\n     * @returns {Key}\n     *\n     * @example\n     * Key.withNamespaces(['one', 'two'])\n     * // => Key('/one/two')\n     *\n     */\n\n  }, {\n    key: \"clean\",\n    value:\n    /**\n     * Cleanup the current key\n     *\n     * @returns {void}\n     */\n    function clean() {\n      if (!this._buf || this._buf.length === 0) {\n        this._buf = Buffer.from(pathSepS);\n      }\n\n      if (this._buf[0] !== pathSep) {\n        this._buf = Buffer.concat([pathSepB, this._buf]);\n      } // normalize does not remove trailing slashes\n\n\n      while (this._buf.length > 1 && this._buf[this._buf.length - 1] === pathSep) {\n        this._buf = this._buf.slice(0, -1);\n      }\n    }\n    /**\n     * Check if the given key is sorted lower than ourself.\n     *\n     * @param {Key} key\n     * @returns {bool}\n     */\n\n  }, {\n    key: \"less\",\n    value: function less(key\n    /* : Key */\n    )\n    /* : bool */\n    {\n      var list1 = this.list();\n      var list2 = key.list();\n\n      for (var i = 0; i < list1.length; i++) {\n        if (list2.length < i + 1) {\n          return false;\n        }\n\n        var c1 = list1[i];\n        var c2 = list2[i];\n\n        if (c1 < c2) {\n          return true;\n        } else if (c1 > c2) {\n          return false;\n        }\n      }\n\n      return list1.length < list2.length;\n    }\n    /**\n     * Returns the key with all parts in reversed order.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n     */\n\n  }, {\n    key: \"reverse\",\n    value: function reverse()\n    /* : Key */\n    {\n      return Key.withNamespaces(this.list().slice().reverse());\n    }\n    /**\n     * Returns the `namespaces` making up this Key.\n     *\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"namespaces\",\n    value: function namespaces()\n    /* : Array<string> */\n    {\n      return this.list();\n    }\n    /** Returns the \"base\" namespace of this key.\n     *\n     * @returns {string}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n     * // => 'Actor:JohnCleese'\n     *\n     */\n\n  }, {\n    key: \"baseNamespace\",\n    value: function baseNamespace()\n    /* : string */\n    {\n      var ns = this.namespaces();\n      return ns[ns.length - 1];\n    }\n    /**\n     * Returns the `list` representation of this key.\n     *\n     * @returns {Array<string>}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n     *\n     */\n\n  }, {\n    key: \"list\",\n    value: function list()\n    /* : Array<string> */\n    {\n      return this.toString().split(pathSepS).slice(1);\n    }\n    /**\n     * Returns the \"type\" of this key (value of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n     * // => 'Actor'\n     *\n     */\n\n  }, {\n    key: \"type\",\n    value: function type()\n    /* : string */\n    {\n      return namespaceType(this.baseNamespace());\n    }\n    /**\n     * Returns the \"name\" of this key (field of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n     * // => 'JohnCleese'\n     */\n\n  }, {\n    key: \"name\",\n    value: function name()\n    /* : string */\n    {\n      return namespaceValue(this.baseNamespace());\n    }\n    /**\n     * Returns an \"instance\" of this type key (appends value to namespace).\n     *\n     * @param {string} s\n     * @returns {Key}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     */\n\n  }, {\n    key: \"instance\",\n    value: function instance(s\n    /* : string */\n    )\n    /* : Key */\n    {\n      return new _Key(this.toString() + ':' + s);\n    }\n    /**\n     * Returns the \"path\" of this key (parent + type).\n     *\n     * @returns {Key}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n     * // => Key('/Comedy/MontyPython/Actor')\n     *\n     */\n\n  }, {\n    key: \"path\",\n    value: function path()\n    /* : Key */\n    {\n      var p = this.parent().toString();\n\n      if (!p.endsWith(pathSepS)) {\n        p += pathSepS;\n      }\n\n      p += this.type();\n      return new _Key(p);\n    }\n    /**\n     * Returns the `parent` Key of this Key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n     * // => Key(\"/Comedy/MontyPython\")\n     *\n     */\n\n  }, {\n    key: \"parent\",\n    value: function parent()\n    /* : Key */\n    {\n      var list = this.list();\n\n      if (list.length === 1) {\n        return new _Key(pathSepS);\n      }\n\n      return new _Key(list.slice(0, -1).join(pathSepS));\n    }\n    /**\n     * Returns the `child` Key of this Key.\n     *\n     * @param {Key} key\n     * @returns {Key}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     *\n     */\n\n  }, {\n    key: \"child\",\n    value: function child(key\n    /* : Key */\n    )\n    /* : Key */\n    {\n      if (this.toString() === pathSepS) {\n        return key;\n      } else if (key.toString() === pathSepS) {\n        return this;\n      }\n\n      return new _Key(this.toString() + key.toString(), false);\n    }\n    /**\n     * Returns whether this key is a prefix of `other`\n     *\n     * @param {Key} other\n     * @returns {bool}\n     *\n     * @example\n     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n     * // => true\n     *\n     */\n\n  }, {\n    key: \"isAncestorOf\",\n    value: function isAncestorOf(other\n    /* : Key */\n    )\n    /* : bool */\n    {\n      if (other.toString() === this.toString()) {\n        return false;\n      }\n\n      return other.toString().startsWith(this.toString());\n    }\n    /**\n     * Returns whether this key is a contains another as prefix.\n     *\n     * @param {Key} other\n     * @returns {bool}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n     * // => true\n     *\n     */\n\n  }, {\n    key: \"isDecendantOf\",\n    value: function isDecendantOf(other\n    /* : Key */\n    )\n    /* : bool */\n    {\n      if (other.toString() === this.toString()) {\n        return false;\n      }\n\n      return this.toString().startsWith(other.toString());\n    }\n    /**\n     * Returns wether this key has only one namespace.\n     *\n     * @returns {bool}\n     *\n     */\n\n  }, {\n    key: \"isTopLevel\",\n    value: function isTopLevel()\n    /* : bool */\n    {\n      return this.list().length === 1;\n    }\n  }], [{\n    key: \"withNamespaces\",\n    value: function withNamespaces(list\n    /* : Array<string> */\n    )\n    /* : Key */\n    {\n      return new _Key(list.join(pathSepS));\n    }\n    /**\n     * Returns a randomly (uuid) generated key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * Key.random()\n     * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n     *\n     */\n\n  }, {\n    key: \"random\",\n    value: function random()\n    /* : Key */\n    {\n      return new _Key(uuid().replace(/-/g, ''));\n    }\n  }]);\n\n  return Key;\n}();\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\n\n\nfunction namespaceType(ns\n/* : string */\n)\n/* : string */\n{\n  var parts = ns.split(':');\n\n  if (parts.length < 2) {\n    return '';\n  }\n\n  return parts.slice(0, -1).join(':');\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\n\n\nfunction namespaceValue(ns\n/* : string */\n)\n/* : string */\n{\n  var parts = ns.split(':');\n  return parts[parts.length - 1];\n}\n\nvar _Key = withIs(Key, {\n  className: 'Key',\n  symbolName: '@ipfs/interface-datastore/key'\n});\n\nmodule.exports = _Key;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/interface-datastore/src/key.js"],"names":["uuid","require","withIs","pathSepS","pathSepB","Buffer","from","pathSep","Key","s","clean","_buf","isBuffer","length","Error","toString","encoding","Symbol","toStringTag","concat","slice","key","list1","list","list2","i","c1","c2","withNamespaces","reverse","ns","namespaces","split","namespaceType","baseNamespace","namespaceValue","_Key","p","parent","endsWith","type","join","other","startsWith","replace","parts","className","symbolName","module","exports"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\nconst uuid = require('uuid/v4')\nconst withIs = require('class-is')\n\nconst pathSepS = '/'\nconst pathSepB = Buffer.from(pathSepS)\nconst pathSep = pathSepB[0]\n\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nclass Key {\n  /* :: _buf: Buffer */\n\n  constructor (s /* : string|Buffer */, clean /* : ?bool */) {\n    if (typeof s === 'string') {\n      this._buf = Buffer.from(s)\n    } else if (Buffer.isBuffer(s)) {\n      this._buf = s\n    }\n\n    if (clean == null) {\n      clean = true\n    }\n\n    if (clean) {\n      this.clean()\n    }\n\n    if (this._buf.length === 0 || this._buf[0] !== pathSep) {\n      throw new Error(`Invalid key: ${this.toString()}`)\n    }\n  }\n\n  /**\n   * Convert to the string representation\n   *\n   * @param {string} [encoding='utf8']\n   * @returns {string}\n   */\n  toString (encoding/* : ?buffer$Encoding */)/* : string */ {\n    return this._buf.toString(encoding || 'utf8')\n  }\n\n  /**\n   * Return the buffer representation of the key\n   *\n   * @returns {Buffer}\n   */\n  toBuffer () /* : Buffer */ {\n    return this._buf\n  }\n\n  // waiting on https://github.com/facebook/flow/issues/2286\n  // $FlowFixMe\n  get [Symbol.toStringTag] () /* : string */ {\n    return `[Key ${this.toString()}]`\n  }\n\n  /**\n   * Constructs a key out of a namespace array.\n   *\n   * @param {Array<string>} list\n   * @returns {Key}\n   *\n   * @example\n   * Key.withNamespaces(['one', 'two'])\n   * // => Key('/one/two')\n   *\n   */\n  static withNamespaces (list /* : Array<string> */) /* : Key */ {\n    return new _Key(list.join(pathSepS))\n  }\n\n  /**\n   * Returns a randomly (uuid) generated key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * Key.random()\n   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n   *\n   */\n  static random () /* : Key */ {\n    return new _Key(uuid().replace(/-/g, ''))\n  }\n\n  /**\n   * Cleanup the current key\n   *\n   * @returns {void}\n   */\n  clean () {\n    if (!this._buf || this._buf.length === 0) {\n      this._buf = Buffer.from(pathSepS)\n    }\n\n    if (this._buf[0] !== pathSep) {\n      this._buf = Buffer.concat([pathSepB, this._buf])\n    }\n\n    // normalize does not remove trailing slashes\n    while (this._buf.length > 1 && this._buf[this._buf.length - 1] === pathSep) {\n      this._buf = this._buf.slice(0, -1)\n    }\n  }\n\n  /**\n   * Check if the given key is sorted lower than ourself.\n   *\n   * @param {Key} key\n   * @returns {bool}\n   */\n  less (key /* : Key */) /* : bool */ {\n    const list1 = this.list()\n    const list2 = key.list()\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false\n      }\n\n      const c1 = list1[i]\n      const c2 = list2[i]\n\n      if (c1 < c2) {\n        return true\n      } else if (c1 > c2) {\n        return false\n      }\n    }\n\n    return list1.length < list2.length\n  }\n\n  /**\n   * Returns the key with all parts in reversed order.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n   */\n  reverse () /* : Key */ {\n    return Key.withNamespaces(this.list().slice().reverse())\n  }\n\n  /**\n   * Returns the `namespaces` making up this Key.\n   *\n   * @returns {Array<string>}\n   */\n  namespaces () /* : Array<string> */ {\n    return this.list()\n  }\n\n  /** Returns the \"base\" namespace of this key.\n   *\n   * @returns {string}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n   * // => 'Actor:JohnCleese'\n   *\n   */\n  baseNamespace () /* : string */ {\n    const ns = this.namespaces()\n    return ns[ns.length - 1]\n  }\n\n  /**\n   * Returns the `list` representation of this key.\n   *\n   * @returns {Array<string>}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n   *\n   */\n  list () /* : Array<string> */ {\n    return this.toString().split(pathSepS).slice(1)\n  }\n\n  /**\n   * Returns the \"type\" of this key (value of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n   * // => 'Actor'\n   *\n   */\n  type () /* : string */ {\n    return namespaceType(this.baseNamespace())\n  }\n\n  /**\n   * Returns the \"name\" of this key (field of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n   * // => 'JohnCleese'\n   */\n  name () /* : string */ {\n    return namespaceValue(this.baseNamespace())\n  }\n\n  /**\n   * Returns an \"instance\" of this type key (appends value to namespace).\n   *\n   * @param {string} s\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   */\n  instance (s /* : string */) /* : Key */ {\n    return new _Key(this.toString() + ':' + s)\n  }\n\n  /**\n   * Returns the \"path\" of this key (parent + type).\n   *\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n   * // => Key('/Comedy/MontyPython/Actor')\n   *\n   */\n  path () /* : Key */ {\n    let p = this.parent().toString()\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS\n    }\n    p += this.type()\n    return new _Key(p)\n  }\n\n  /**\n   * Returns the `parent` Key of this Key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n   * // => Key(\"/Comedy/MontyPython\")\n   *\n   */\n  parent () /* : Key */ {\n    const list = this.list()\n    if (list.length === 1) {\n      return new _Key(pathSepS)\n    }\n\n    return new _Key(list.slice(0, -1).join(pathSepS))\n  }\n\n  /**\n   * Returns the `child` Key of this Key.\n   *\n   * @param {Key} key\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   *\n   */\n  child (key /* : Key */) /* : Key */ {\n    if (this.toString() === pathSepS) {\n      return key\n    } else if (key.toString() === pathSepS) {\n      return this\n    }\n\n    return new _Key(this.toString() + key.toString(), false)\n  }\n\n  /**\n   * Returns whether this key is a prefix of `other`\n   *\n   * @param {Key} other\n   * @returns {bool}\n   *\n   * @example\n   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n   * // => true\n   *\n   */\n  isAncestorOf (other /* : Key */) /* : bool */ {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return other.toString().startsWith(this.toString())\n  }\n\n  /**\n   * Returns whether this key is a contains another as prefix.\n   *\n   * @param {Key} other\n   * @returns {bool}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n   * // => true\n   *\n   */\n  isDecendantOf (other /* : Key */) /* : bool */ {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return this.toString().startsWith(other.toString())\n  }\n\n  /**\n   * Returns wether this key has only one namespace.\n   *\n   * @returns {bool}\n   *\n   */\n  isTopLevel () /* : bool */ {\n    return this.list().length === 1\n  }\n}\n\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType (ns /* : string */) /* : string */ {\n  const parts = ns.split(':')\n  if (parts.length < 2) {\n    return ''\n  }\n  return parts.slice(0, -1).join(':')\n}\n\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue (ns /* : string */) /* : string */ {\n  const parts = ns.split(':')\n  return parts[parts.length - 1]\n}\n\nconst _Key = withIs(Key, { className: 'Key', symbolName: '@ipfs/interface-datastore/key' })\n\nmodule.exports = _Key\n"]},"metadata":{},"sourceType":"script"}