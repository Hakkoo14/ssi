{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:websocket-star:listener');\n\nvar multiaddr = require('multiaddr');\n\nvar io = require('socket.io-client');\n\nvar sp = require('socket.io-pull-stream');\n\nvar uuid = require('uuid');\n\nvar series = require('async/series');\n\nvar EE = require('events').EventEmitter;\n\nvar Connection = require('interface-connection').Connection;\n\nvar once = require('once');\n\nvar setImmediate = require('async/setImmediate');\n\nvar utils = require('./utils');\n\nvar cleanUrlSIO = utils.cleanUrlSIO;\n\nvar crypto = require('libp2p-crypto');\n\nvar pull = require('pull-stream/pull');\n\nvar through = require('pull-stream/throughs/through');\n\nvar ERRORS = require('./errors');\n\nvar noop = once(function () {});\nvar sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n};\n/**\n  * Listener for signalling server\n  * @class\n  * @param {Object} options - Options for the listener\n  * @param {PeerId} options.id - Id for the crypto challenge\n  * @param {function} options.handler - Incomming connection handler\n  */\n\nvar Listener = /*#__PURE__*/function (_EE) {\n  _inherits(Listener, _EE);\n\n  var _super = _createSuper(Listener);\n\n  function Listener(options) {\n    var _this;\n\n    _classCallCheck(this, Listener);\n\n    _this = _super.call(this);\n    _this.id = options.id;\n    _this.log = log.bind(log, 'listener#offline');\n    _this.canCrypto = Boolean(options.id);\n    _this._handler = options.handler || noop;\n    _this.listeners_list = options.listeners || {};\n    _this.flag = options.flag;\n    _this.conns = [];\n    _this.connected = false;\n    return _this;\n  } // \"private\" functions\n\n  /**\n    * Connects to the signalling server\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n\n\n  _createClass(Listener, [{\n    key: \"_up\",\n    value: function _up(cb) {\n      var _this2 = this;\n\n      cb = cb ? once(cb) : noop;\n\n      if (this.io) {\n        return cb();\n      }\n\n      this.log = log.bind(log, 'listener#' + this.server);\n      this.log('dialing to signalling server');\n\n      var _io = this.io = io.connect(this.server, sioOptions);\n\n      sp(_io, {\n        codec: 'buffer'\n      });\n\n      _io.once('error', cb);\n\n      _io.once('connect_error', cb);\n\n      _io.once('connect', cb);\n\n      var proto = new utils.Protocol(this.log);\n      proto.addRequest('ws-peer', ['multiaddr'], function (socket, peer) {\n        return _this2.emit('peer', peer);\n      });\n      proto.addRequest('ss-incomming', ['string', 'multiaddr', 'function'], this._incommingDial.bind(this));\n      proto.handleSocket(_io);\n    }\n    /**\n      * Disconnects from signalling server\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_down\",\n    value: function _down() {\n      if (!this.io) {\n        return;\n      }\n\n      this.io.disconnect();\n      this.emit('close');\n      delete this.io;\n    }\n    /**\n      * Performs a cryptoChallenge\n      * @param {function} callback - callback\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_cryptoChallenge\",\n    value: function _cryptoChallenge(callback) {\n      var _this3 = this;\n\n      if (!this.io) {\n        return callback(new Error('Not connected'));\n      }\n\n      var pubKeyStr = this.canCrypto ? crypto.keys.marshalPublicKey(this.id.pubKey).toString('hex') : '';\n      var maStr = this.ma.toString();\n      this.io.emit('ss-join', maStr, pubKeyStr, function (err, sig, peers) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (sig) {\n          if (!_this3.canCrypto) {\n            _this3._down();\n\n            return callback(new Error(\"Can't sign cryptoChallenge: No id provided\"));\n          }\n\n          _this3.log('performing cryptoChallenge');\n\n          _this3.id.privKey.sign(Buffer.from(sig), function (err, signature) {\n            if (err) {\n              return callback(err);\n            }\n\n            _this3.signature = signature.toString('hex');\n\n            _this3._join(callback);\n          });\n        } else {\n          if (!_this3.flag) {\n            _this3._down();\n\n            return callback(new Error('Tried to listen on a server with crypto challenge disabled!\\n    This is prohibited by default and can lead to security issues!\\n    Please set \"allowJoinWithDisabledChallenge\" to true in the constructor options (but only if you know what you are doing)!'));\n          }\n\n          _this3.signature = '_';\n          callback(null, null, peers);\n        }\n      });\n    }\n    /**\n      * Performs a cryptoChallenge when no signature is found\n      * @param {function} cb - callback\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_crypto\",\n    value: function _crypto(cb) {\n      cb = cb ? once(cb) : noop;\n      this.log('joining');\n\n      if (!this.io) {\n        return cb(new Error('Not connected'));\n      }\n\n      if (this.signature) {\n        this._join(cb);\n      } else {\n        this._cryptoChallenge(cb);\n      }\n    }\n    /**\n      * Emits ss-join with the multiaddr and signature\n      *\n      * @param {function} cb - callback\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_join\",\n    value: function _join(cb) {\n      this.io.emit('ss-join', this.ma.toString(), this.signature, cb);\n    }\n    /**\n      * Handles incomming dials\n      * @listens ss-incomming\n      * @param {socket.io_client} socket\n      * @param {string} dialId - Unique id for this dial\n      * @param {string} dialFrom - Multiaddr as string\n      * @param {function} cb - callback\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_incommingDial\",\n    value: function _incommingDial(socket, dialId, dialFrom, cb) {\n      this.log('dial#' + dialId + ' incomming from', dialFrom);\n      var ma = multiaddr(dialFrom);\n      var source = this.io.createSource(dialId + '.dialer');\n      var sink = this.io.createSink(dialId + '.listener');\n      cb();\n      var conn = new Connection({\n        sink: sink,\n        source: source\n      }, {\n        getObservedAddrs: function getObservedAddrs(cb) {\n          return cb(null, [ma]);\n        }\n      });\n      this.emit('connection', conn);\n\n      this._handler(conn);\n    } // public functions\n\n    /**\n      * Listens on a multiaddr\n      * @param {Multiaddr} ma\n      * @param {function} callback\n      * @returns {undefined}\n      */\n\n  }, {\n    key: \"listen\",\n    value: function listen(ma, callback) {\n      var _this4 = this;\n\n      this.ma = ma;\n      this.server = cleanUrlSIO(ma);\n      this.listeners_list[this.server] = this;\n      callback = callback ? once(callback) : noop;\n\n      if (this.connected) {\n        // listener was .close()'d yet not all conns disconnected. we're still connected, so don't do anything\n        this.closing = false;\n        return setImmediate(function () {\n          return callback();\n        });\n      }\n\n      series([function (cb) {\n        return _this4._up(cb);\n      }, function (cb) {\n        return _this4._crypto(function (err, ignore, peers) {\n          return cb(err, peers);\n        });\n      }], function (err, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            ignore = _ref2[0],\n            peers = _ref2[1];\n\n        if (err) {\n          // Error connecting to WebSocket\n          if (err.description && err.description.code === 'ENOTFOUND') {\n            var hostname = err.description.hostname;\n            err = Object.assign(new Error(\"WebSocket connection failed on \".concat(hostname)), {\n              code: ERRORS.ERR_WS_STAR_WEBSOCKET_CONNECTION\n            });\n          }\n\n          _this4.log('error', err);\n\n          if (!(err instanceof Error)) err = new Error(err);\n\n          _this4._down();\n\n          _this4.emit('error', err);\n\n          _this4.emit('close');\n\n          return callback(err);\n        }\n\n        _this4.log('success');\n\n        _this4.connected = true;\n\n        _this4.io.on('reconnect', function () {\n          // force to get a new signature\n          _this4.signature = null;\n\n          _this4._crypto(function (err, ignore, reconnectPeers) {\n            if (err) {\n              _this4.log('reconnect error', err);\n\n              _this4.emit('error', err);\n            } else {\n              _this4.log('reconnected');\n\n              var _iterator = _createForOfIteratorHelper(reconnectPeers || []),\n                  _step;\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var p = _step.value;\n\n                  _this4.emit('peer', p);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            }\n          });\n        });\n\n        _this4.emit('listening');\n\n        var _iterator2 = _createForOfIteratorHelper(peers || []),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var p = _step2.value;\n\n            _this4.emit('peer', p);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        callback();\n      });\n    }\n    /**\n      * Gets the addresses the listener listens on\n      * @param {function} callback\n      * @returns {undefined}\n      */\n\n  }, {\n    key: \"getAddrs\",\n    value: function getAddrs(callback) {\n      var _this5 = this;\n\n      setImmediate(function () {\n        return callback(null, _this5.ma ? [_this5.ma] : []);\n      });\n    }\n  }, {\n    key: \"activeConnections\",\n    get: function get() {\n      this.conns = this.conns.filter(function (c) {\n        return c.sink || c.source;\n      });\n      return Boolean(this.conns.length);\n    }\n  }, {\n    key: \"maybeClose\",\n    value: function maybeClose() {\n      if (!this.activeConnections && this.closing) {\n        this.connected = false;\n        this.closing = false;\n        this.log('no more connections and listener is offline - closing');\n\n        this._down();\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      callback = callback ? once(callback) : noop;\n      this.closing = true; // will close once the last connection quits\n\n      this.maybeClose();\n      callback();\n    }\n  }, {\n    key: \"stateWatch\",\n    value: function stateWatch(sink, source) {\n      var _this6 = this;\n\n      var cstate = {\n        sink: true,\n        source: true\n      };\n\n      var watch = function watch(name) {\n        return through(function (v) {\n          return v;\n        }, function (e) {\n          cstate[name] = false;\n\n          if (!cstate.sink && !cstate.source) {\n            _this6.maybeClose();\n          }\n        });\n      };\n\n      this.conns.push(cstate);\n      return {\n        sink: pull(watch('sink'), sink),\n        source: pull(source, watch('source'))\n      };\n    } // called from transport\n\n    /**\n      * Dials a peer\n      * @param {Multiaddr} ma - Multiaddr to dial to\n      * @param {Object} options\n      * @param {function} callback\n      * @returns {undefined}\n      */\n\n  }, {\n    key: \"dial\",\n    value: function dial(ma, options, callback) {\n      var _this7 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      var _ma = multiaddr(ma);\n\n      var conn = new Connection(null);\n      var dialId = uuid();\n      var dlog = this.log.bind(log, 'dial#' + dialId);\n      callback = callback ? once(callback) : noop;\n      var io = this.io;\n\n      if (!io) {\n        return callback(new Error('Not listening'));\n      }\n\n      var sink = io.createSink(dialId + '.dialer');\n      dlog('dialing', ma.toString()); // \"multiaddr\", \"multiaddr\", \"string\", \"function\" - dialFrom, dialTo, dialId, cb\n\n      io.emit('ss-dial', this.ma.toString(), ma.toString(), dialId, function (err) {\n        if (err) return callback(err instanceof Error ? err : new Error(err));\n        dlog(err ? 'error: ' + err.toString() : 'success');\n        var source = io.createSource(dialId + '.listener');\n        conn.setInnerConn(_this7.stateWatch(sink, source), {\n          getObservedAddrs: function getObservedAddrs(cb) {\n            return cb(null, [_ma]);\n          }\n        });\n        callback(null, conn);\n      });\n      return conn;\n    }\n  }]);\n\n  return Listener;\n}(EE);\n\nmodule.exports = Listener;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-websocket-star/src/listener.js"],"names":["debug","require","log","multiaddr","io","sp","uuid","series","EE","EventEmitter","Connection","once","setImmediate","utils","cleanUrlSIO","crypto","pull","through","ERRORS","noop","sioOptions","transports","Listener","options","id","bind","canCrypto","Boolean","_handler","handler","listeners_list","listeners","flag","conns","connected","cb","server","_io","connect","codec","proto","Protocol","addRequest","socket","peer","emit","_incommingDial","handleSocket","disconnect","callback","Error","pubKeyStr","keys","marshalPublicKey","pubKey","toString","maStr","ma","err","sig","peers","_down","privKey","sign","Buffer","from","signature","_join","_cryptoChallenge","dialId","dialFrom","source","createSource","sink","createSink","conn","getObservedAddrs","closing","_up","_crypto","ignore","description","code","hostname","Object","assign","ERR_WS_STAR_WEBSOCKET_CONNECTION","on","reconnectPeers","p","filter","c","length","activeConnections","maybeClose","cstate","watch","name","v","e","push","_ma","dlog","setInnerConn","stateWatch","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:websocket-star:listener')\nconst multiaddr = require('multiaddr')\nconst io = require('socket.io-client')\nconst sp = require('socket.io-pull-stream')\nconst uuid = require('uuid')\nconst series = require('async/series')\nconst EE = require('events').EventEmitter\nconst Connection = require('interface-connection').Connection\nconst once = require('once')\nconst setImmediate = require('async/setImmediate')\nconst utils = require('./utils')\nconst cleanUrlSIO = utils.cleanUrlSIO\nconst crypto = require('libp2p-crypto')\nconst pull = require('pull-stream/pull')\nconst through = require('pull-stream/throughs/through')\nconst ERRORS = require('./errors')\n\nconst noop = once(() => {})\n\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n}\n\n/**\n  * Listener for signalling server\n  * @class\n  * @param {Object} options - Options for the listener\n  * @param {PeerId} options.id - Id for the crypto challenge\n  * @param {function} options.handler - Incomming connection handler\n  */\nclass Listener extends EE {\n  constructor (options) {\n    super()\n    this.id = options.id\n    this.log = log.bind(log, 'listener#offline')\n    this.canCrypto = Boolean(options.id)\n    this._handler = options.handler || noop\n    this.listeners_list = options.listeners || {}\n    this.flag = options.flag\n    this.conns = []\n    this.connected = false\n  }\n\n  // \"private\" functions\n  /**\n    * Connects to the signalling server\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n  _up (cb) {\n    cb = cb ? once(cb) : noop\n    if (this.io) {\n      return cb()\n    }\n\n    this.log = log.bind(log, 'listener#' + this.server)\n    this.log('dialing to signalling server')\n    const _io = this.io = io.connect(this.server, sioOptions)\n\n    sp(_io, { codec: 'buffer' })\n    _io.once('error', cb)\n    _io.once('connect_error', cb)\n    _io.once('connect', cb)\n\n    const proto = new utils.Protocol(this.log)\n\n    proto.addRequest('ws-peer', ['multiaddr'], (socket, peer) => this.emit('peer', peer))\n    proto.addRequest('ss-incomming', ['string', 'multiaddr', 'function'], this._incommingDial.bind(this))\n    proto.handleSocket(_io)\n  }\n\n  /**\n    * Disconnects from signalling server\n    * @returns {undefined}\n    * @private\n    */\n  _down () {\n    if (!this.io) {\n      return\n    }\n\n    this.io.disconnect()\n    this.emit('close')\n    delete this.io\n  }\n\n  /**\n    * Performs a cryptoChallenge\n    * @param {function} callback - callback\n    * @returns {undefined}\n    * @private\n    */\n  _cryptoChallenge (callback) {\n    if (!this.io) {\n      return callback(new Error('Not connected'))\n    }\n\n    const pubKeyStr = this.canCrypto ? crypto.keys.marshalPublicKey(this.id.pubKey).toString('hex') : ''\n\n    const maStr = this.ma.toString()\n\n    this.io.emit('ss-join', maStr, pubKeyStr, (err, sig, peers) => {\n      if (err) { return callback(err) }\n\n      if (sig) {\n        if (!this.canCrypto) {\n          this._down()\n          return callback(new Error(\"Can't sign cryptoChallenge: No id provided\"))\n        }\n\n        this.log('performing cryptoChallenge')\n\n        this.id.privKey.sign(Buffer.from(sig), (err, signature) => {\n          if (err) {\n            return callback(err)\n          }\n          this.signature = signature.toString('hex')\n          this._join(callback)\n        })\n      } else {\n        if (!this.flag) {\n          this._down()\n          return callback(new Error('Tried to listen on a server with crypto challenge disabled!\\n    This is prohibited by default and can lead to security issues!\\n    Please set \"allowJoinWithDisabledChallenge\" to true in the constructor options (but only if you know what you are doing)!'))\n        }\n        this.signature = '_'\n        callback(null, null, peers)\n      }\n    })\n  }\n\n  /**\n    * Performs a cryptoChallenge when no signature is found\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n  _crypto (cb) {\n    cb = cb ? once(cb) : noop\n\n    this.log('joining')\n\n    if (!this.io) {\n      return cb(new Error('Not connected'))\n    }\n\n    if (this.signature) {\n      this._join(cb)\n    } else {\n      this._cryptoChallenge(cb)\n    }\n  }\n\n  /**\n    * Emits ss-join with the multiaddr and signature\n    *\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n  _join (cb) {\n    this.io.emit('ss-join', this.ma.toString(), this.signature, cb)\n  }\n\n  /**\n    * Handles incomming dials\n    * @listens ss-incomming\n    * @param {socket.io_client} socket\n    * @param {string} dialId - Unique id for this dial\n    * @param {string} dialFrom - Multiaddr as string\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n  _incommingDial (socket, dialId, dialFrom, cb) {\n    this.log('dial#' + dialId + ' incomming from', dialFrom)\n    const ma = multiaddr(dialFrom)\n    const source = this.io.createSource(dialId + '.dialer')\n    const sink = this.io.createSink(dialId + '.listener')\n\n    cb()\n\n    const conn = new Connection(\n      {\n        sink: sink,\n        source: source\n      }, {\n        getObservedAddrs: (cb) => cb(null, [ma])\n      }\n    )\n    this.emit('connection', conn)\n    this._handler(conn)\n  }\n\n  // public functions\n  /**\n    * Listens on a multiaddr\n    * @param {Multiaddr} ma\n    * @param {function} callback\n    * @returns {undefined}\n    */\n  listen (ma, callback) {\n    this.ma = ma\n    this.server = cleanUrlSIO(ma)\n    this.listeners_list[this.server] = this\n    callback = callback ? once(callback) : noop\n\n    if (this.connected) { // listener was .close()'d yet not all conns disconnected. we're still connected, so don't do anything\n      this.closing = false\n      return setImmediate(() => callback())\n    }\n\n    series([\n      (cb) => this._up(cb),\n      (cb) => this._crypto((err, ignore, peers) => cb(err, peers))\n    ], (err, [ignore, peers]) => {\n      if (err) {\n        // Error connecting to WebSocket\n        if (err.description && err.description.code === 'ENOTFOUND') {\n          const hostname = err.description.hostname\n\n          err = Object.assign(new Error(`WebSocket connection failed on ${hostname}`), {\n            code: ERRORS.ERR_WS_STAR_WEBSOCKET_CONNECTION\n          })\n        }\n\n        this.log('error', err)\n        if (!(err instanceof Error)) err = new Error(err)\n        this._down()\n        this.emit('error', err)\n        this.emit('close')\n        return callback(err)\n      }\n\n      this.log('success')\n      this.connected = true\n\n      this.io.on('reconnect', () => {\n        // force to get a new signature\n        this.signature = null\n        this._crypto((err, ignore, reconnectPeers) => {\n          if (err) {\n            this.log('reconnect error', err)\n            this.emit('error', err)\n          } else {\n            this.log('reconnected')\n            for (const p of (reconnectPeers || [])) {\n              this.emit('peer', p)\n            }\n          }\n        })\n      })\n\n      this.emit('listening')\n      for (const p of (peers || [])) {\n        this.emit('peer', p)\n      }\n      callback()\n    })\n  }\n\n  /**\n    * Gets the addresses the listener listens on\n    * @param {function} callback\n    * @returns {undefined}\n    */\n  getAddrs (callback) {\n    setImmediate(() => callback(null, this.ma ? [this.ma] : []))\n  }\n\n  get activeConnections () {\n    this.conns = this.conns.filter(c => c.sink || c.source)\n    return Boolean(this.conns.length)\n  }\n\n  maybeClose () {\n    if (!this.activeConnections && this.closing) {\n      this.connected = false\n      this.closing = false\n      this.log('no more connections and listener is offline - closing')\n      this._down()\n    }\n  }\n\n  close (callback) {\n    callback = callback ? once(callback) : noop\n\n    this.closing = true // will close once the last connection quits\n    this.maybeClose()\n\n    callback()\n  }\n\n  stateWatch (sink, source) {\n    let cstate = { sink: true, source: true }\n    const watch = (name) => through(v => v, e => {\n      cstate[name] = false\n      if (!cstate.sink && !cstate.source) {\n        this.maybeClose()\n      }\n    })\n\n    this.conns.push(cstate)\n\n    return {\n      sink: pull(\n        watch('sink'),\n        sink\n      ),\n      source: pull(\n        source,\n        watch('source')\n      )\n    }\n  }\n\n  // called from transport\n  /**\n    * Dials a peer\n    * @param {Multiaddr} ma - Multiaddr to dial to\n    * @param {Object} options\n    * @param {function} callback\n    * @returns {undefined}\n    */\n  dial (ma, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    const _ma = multiaddr(ma)\n\n    const conn = new Connection(null)\n\n    const dialId = uuid()\n    const dlog = this.log.bind(log, 'dial#' + dialId)\n\n    callback = callback ? once(callback) : noop\n\n    let io = this.io\n\n    if (!io) {\n      return callback(new Error('Not listening'))\n    }\n\n    const sink = io.createSink(dialId + '.dialer')\n\n    dlog('dialing', ma.toString())\n\n    // \"multiaddr\", \"multiaddr\", \"string\", \"function\" - dialFrom, dialTo, dialId, cb\n    io.emit('ss-dial', this.ma.toString(), ma.toString(), dialId, err => {\n      if (err) return callback(err instanceof Error ? err : new Error(err))\n      dlog(err ? 'error: ' + err.toString() : 'success')\n      const source = io.createSource(dialId + '.listener')\n\n      conn.setInnerConn(this.stateWatch(sink, source), { getObservedAddrs: (cb) => cb(null, [_ma]) })\n      callback(null, conn)\n    })\n\n    return conn\n  }\n}\n\nmodule.exports = Listener\n"]},"metadata":{},"sourceType":"script"}