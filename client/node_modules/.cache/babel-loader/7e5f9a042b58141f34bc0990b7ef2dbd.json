{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar PeerId = require('peer-id');\n\nvar libp2pRecord = require('libp2p-record');\n\nvar timeout = require('async/timeout');\n\nvar PeerInfo = require('peer-info');\n\nvar promisify = require('promisify-es6');\n\nvar promiseToCallback = require('promise-to-callback');\n\nvar errcode = require('err-code');\n\nvar utils = require('./utils');\n\nvar Message = require('./message');\n\nvar c = require('./constants');\n\nvar Query = require('./query');\n\nvar LimitedPeerList = require('./limited-peer-list');\n\nvar Record = libp2pRecord.Record;\n\nmodule.exports = function (dht) {\n  return {\n    /**\n     * Returns the routing tables closest peers, for the key of\n     * the message.\n     *\n     * @param {Message} msg\n     * @param {function(Error, Array<PeerInfo>)} callback\n     * @returns {undefined}\n     * @private\n     */\n    _nearestPeersToQuery: function _nearestPeersToQuery(msg, callback) {\n      promiseToCallback(this._nearestPeersToQueryAsync(msg))(callback);\n    },\n    _nearestPeersToQueryAsync: function _nearestPeersToQueryAsync(msg) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var key, ids;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return promisify(utils.convertBuffer)(msg.key);\n\n              case 2:\n                key = _context.sent;\n                ids = dht.routingTable.closestPeers(key, dht.kBucketSize);\n                return _context.abrupt(\"return\", ids.map(function (p) {\n                  if (dht.peerBook.has(p)) {\n                    return dht.peerBook.get(p);\n                  }\n\n                  return dht.peerBook.put(new PeerInfo(p));\n                }));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n\n    /**\n     * Get the nearest peers to the given query, but iff closer\n     * than self.\n     *\n     * @param {Message} msg\n     * @param {PeerInfo} peer\n     * @param {function(Error, Array<PeerInfo>)} callback\n     * @returns {undefined}\n     * @private\n     */\n    _betterPeersToQuery: function _betterPeersToQuery(msg, peer, callback) {\n      promiseToCallback(this._betterPeersToQueryAsync(msg, peer))(callback);\n    },\n    _betterPeersToQueryAsync: function _betterPeersToQueryAsync(msg, peer) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var closer;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                dht._log('betterPeersToQuery');\n\n                _context2.next = 3;\n                return dht._nearestPeersToQueryAsync(msg);\n\n              case 3:\n                closer = _context2.sent;\n                return _context2.abrupt(\"return\", closer.filter(function (closer) {\n                  if (dht._isSelf(closer.id)) {\n                    // Should bail, not sure\n                    dht._log.error('trying to return self as closer');\n\n                    return false;\n                  }\n\n                  return !closer.id.isEqual(peer.id);\n                }));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n\n    /**\n     * Try to fetch a given record by from the local datastore.\n     * Returns the record iff it is still valid, meaning\n     * - it was either authored by this node, or\n     * - it was received less than `MAX_RECORD_AGE` ago.\n     *\n     * @param {Buffer} key\n     * @param {function(Error, Record)} callback\n     * @returns {undefined}\n     *\n     *@private\n     */\n    _checkLocalDatastore: function _checkLocalDatastore(key, callback) {\n      promiseToCallback(this._checkLocalDatastoreAsync(key))(callback);\n    },\n    _checkLocalDatastoreAsync: function _checkLocalDatastoreAsync(key) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var dsKey, rawRecord, record;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                dht._log('checkLocalDatastore: %b', key);\n\n                dsKey = utils.bufferToKey(key); // Fetch value from ds\n\n                _context3.prev = 2;\n                _context3.next = 5;\n                return promisify(function (cb) {\n                  return dht.datastore.get(dsKey, cb);\n                })();\n\n              case 5:\n                rawRecord = _context3.sent;\n                _context3.next = 13;\n                break;\n\n              case 8:\n                _context3.prev = 8;\n                _context3.t0 = _context3[\"catch\"](2);\n\n                if (!(_context3.t0.code === 'ERR_NOT_FOUND')) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", undefined);\n\n              case 12:\n                throw _context3.t0;\n\n              case 13:\n                // Create record from the returned bytes\n                record = Record.deserialize(rawRecord);\n\n                if (record) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                throw errcode('Invalid record', 'ERR_INVALID_RECORD');\n\n              case 16:\n                if (!(record.timeReceived == null || utils.now() - record.timeReceived > c.MAX_RECORD_AGE)) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                _context3.next = 19;\n                return promisify(function (cb) {\n                  return dht.datastore.delete(dsKey, cb);\n                })();\n\n              case 19:\n                return _context3.abrupt(\"return\", undefined);\n\n              case 20:\n                return _context3.abrupt(\"return\", record);\n\n              case 21:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[2, 8]]);\n      }))();\n    },\n\n    /**\n     * Add the peer to the routing table and update it in the peerbook.\n     *\n     * @param {PeerInfo} peer\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     *\n     * @private\n     */\n    _add: function _add(peer, callback) {\n      promiseToCallback(this._addAsync(peer))(function (err) {\n        return callback(err);\n      });\n    },\n    _addAsync: function _addAsync(peer) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                peer = dht.peerBook.put(peer);\n                _context4.next = 3;\n                return promisify(function (cb) {\n                  return dht.routingTable.add(peer.id, cb);\n                })();\n\n              case 3:\n                return _context4.abrupt(\"return\", undefined);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    },\n\n    /**\n     * Verify a record without searching the DHT.\n     *\n     * @param {Record} record\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     *\n     * @private\n     */\n    _verifyRecordLocally: function _verifyRecordLocally(record, callback) {\n      promiseToCallback(this._verifyRecordLocallyAsync(record))(function (err) {\n        return callback(err);\n      });\n    },\n    _verifyRecordLocallyAsync: function _verifyRecordLocallyAsync(record) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                dht._log('verifyRecordLocally');\n\n                _context5.next = 3;\n                return promisify(function (cb) {\n                  return libp2pRecord.validator.verifyRecord(dht.validators, record, cb);\n                })();\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n\n    /**\n     * Find close peers for a given peer\n     *\n     * @param {Buffer} key\n     * @param {PeerId} peer\n     * @param {function(Error, Array<PeerInfo>)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _closerPeersSingle: function _closerPeersSingle(key, peer, callback) {\n      promiseToCallback(this._closerPeersSingleAsync(key, peer))(callback);\n    },\n    _closerPeersSingleAsync: function _closerPeersSingleAsync(key, peer) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var msg;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                dht._log('_closerPeersSingle %b from %s', key, peer.toB58String());\n\n                _context6.next = 3;\n                return dht._findPeerSingleAsync(peer, new PeerId(key));\n\n              case 3:\n                msg = _context6.sent;\n                return _context6.abrupt(\"return\", msg.closerPeers.filter(function (pInfo) {\n                  return !dht._isSelf(pInfo.id);\n                }).map(function (pInfo) {\n                  return dht.peerBook.put(pInfo);\n                }));\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }))();\n    },\n\n    /**\n     * Is the given peer id our PeerId?\n     *\n     * @param {PeerId} other\n     * @returns {bool}\n     *\n     * @private\n     */\n    _isSelf: function _isSelf(other) {\n      return other && dht.peerInfo.id.id.equals(other.id);\n    },\n\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     *\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @param {function(Error, Message)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _findPeerSingle: function _findPeerSingle(peer, target, callback) {\n      promiseToCallback(this._findPeerSingleAsync(peer, target))(callback);\n    },\n    _findPeerSingleAsync: function _findPeerSingleAsync(peer, target) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var msg;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                dht._log('_findPeerSingle %s', peer.toB58String());\n\n                msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n                return _context7.abrupt(\"return\", promisify(function (callback) {\n                  return dht.network.sendRequest(peer, msg, callback);\n                })());\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }))();\n    },\n\n    /**\n     * Store the given key/value pair at the peer `target`.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} rec - encoded record\n     * @param {PeerId} target\n     * @param {function(Error)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _putValueToPeer: function _putValueToPeer(key, rec, target, callback) {\n      promiseToCallback(this._putValueToPeerAsync(key, rec, target))(callback);\n    },\n    _putValueToPeerAsync: function _putValueToPeerAsync(key, rec, target) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var msg, resp;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                msg = new Message(Message.TYPES.PUT_VALUE, key, 0);\n                msg.record = rec;\n                _context8.next = 4;\n                return promisify(function (cb) {\n                  return dht.network.sendRequest(target, msg, cb);\n                })();\n\n              case 4:\n                resp = _context8.sent;\n\n                if (resp.record.value.equals(Record.deserialize(rec).value)) {\n                  _context8.next = 7;\n                  break;\n                }\n\n                throw errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID');\n\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }))();\n    },\n\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     * @param {Buffer} key\n     * @param {Buffer} rec - encoded record\n     * @param {function(Error)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _putLocal: function _putLocal(key, rec, callback) {\n      promiseToCallback(this._putLocalAsync(key, rec))(function (err) {\n        return callback(err);\n      });\n    },\n    _putLocalAsync: function _putLocalAsync(key, rec) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return promisify(function (cb) {\n                  return dht.datastore.put(utils.bufferToKey(key), rec, cb);\n                })();\n\n              case 2:\n                return _context9.abrupt(\"return\", undefined);\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }))();\n    },\n\n    /**\n     * Get the value for given key.\n     *\n     * @param {Buffer} key\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout (default: 60000)\n     * @param {function(Error, Record)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _get: function _get(key, options, callback) {\n      promiseToCallback(this._getAsync(key, options))(callback);\n    },\n    _getAsync: function _getAsync(key, options) {\n      var _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var vals, recs, i, best;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                dht._log('_get %b', key);\n\n                _context10.next = 3;\n                return promisify(function (cb) {\n                  return dht.getMany(key, c.GET_MANY_RECORD_COUNT, options, cb);\n                })();\n\n              case 3:\n                vals = _context10.sent;\n                recs = vals.map(function (v) {\n                  return v.val;\n                });\n                i = 0;\n                _context10.prev = 6;\n                i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n                _context10.next = 14;\n                break;\n\n              case 10:\n                _context10.prev = 10;\n                _context10.t0 = _context10[\"catch\"](6);\n\n                if (!(_context10.t0.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY')) {\n                  _context10.next = 14;\n                  break;\n                }\n\n                throw _context10.t0;\n\n              case 14:\n                best = recs[i];\n\n                dht._log('GetValue %b %s', key, best);\n\n                if (best) {\n                  _context10.next = 18;\n                  break;\n                }\n\n                throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n\n              case 18:\n                _context10.next = 20;\n                return _this._sendCorrectionRecord(key, vals, best);\n\n              case 20:\n                return _context10.abrupt(\"return\", best);\n\n              case 21:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, null, [[6, 10]]);\n      }))();\n    },\n\n    /**\n     * Send the best record found to any peers that have an out of date record.\n     *\n     * @param {Buffer} key\n     * @param {Array<Object>} vals - values retrieved from the DHT\n     * @param {Object} best - the best record that was found\n     * @returns {Promise}\n     *\n     * @private\n     */\n    _sendCorrectionRecord: function _sendCorrectionRecord(key, vals, best) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var fixupRec;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return promisify(function (cb) {\n                  return utils.createPutRecord(key, best, cb);\n                })();\n\n              case 2:\n                fixupRec = _context12.sent;\n                return _context12.abrupt(\"return\", Promise.all(vals.map( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(v) {\n                    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n                      while (1) {\n                        switch (_context11.prev = _context11.next) {\n                          case 0:\n                            if (!v.val.equals(best)) {\n                              _context11.next = 2;\n                              break;\n                            }\n\n                            return _context11.abrupt(\"return\");\n\n                          case 2:\n                            if (!dht._isSelf(v.from)) {\n                              _context11.next = 12;\n                              break;\n                            }\n\n                            _context11.prev = 3;\n                            _context11.next = 6;\n                            return dht._putLocalAsync(key, fixupRec);\n\n                          case 6:\n                            _context11.next = 11;\n                            break;\n\n                          case 8:\n                            _context11.prev = 8;\n                            _context11.t0 = _context11[\"catch\"](3);\n\n                            dht._log.error('Failed error correcting self', _context11.t0);\n\n                          case 11:\n                            return _context11.abrupt(\"return\");\n\n                          case 12:\n                            _context11.prev = 12;\n                            _context11.next = 15;\n                            return dht._putValueToPeerAsync(key, fixupRec, v.from);\n\n                          case 15:\n                            _context11.next = 20;\n                            break;\n\n                          case 17:\n                            _context11.prev = 17;\n                            _context11.t1 = _context11[\"catch\"](12);\n\n                            dht._log.error('Failed error correcting entry', _context11.t1);\n\n                          case 20:\n                          case \"end\":\n                            return _context11.stop();\n                        }\n                      }\n                    }, _callee11, null, [[3, 8], [12, 17]]);\n                  }));\n\n                  return function (_x) {\n                    return _ref.apply(this, arguments);\n                  };\n                }())));\n\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }))();\n    },\n\n    /**\n     * Attempt to retrieve the value for the given key from\n     * the local datastore.\n     *\n     * @param {Buffer} key\n     * @param {function(Error, Record)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _getLocal: function _getLocal(key, callback) {\n      promiseToCallback(this._getLocalAsync(key))(callback);\n    },\n    _getLocalAsync: function _getLocalAsync(key) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var raw, rec;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                dht._log('getLocal %b', key);\n\n                _context13.next = 3;\n                return promisify(function (cb) {\n                  return dht.datastore.get(utils.bufferToKey(key), cb);\n                })();\n\n              case 3:\n                raw = _context13.sent;\n\n                dht._log('found %b in local datastore', key);\n\n                rec = Record.deserialize(raw);\n                _context13.next = 8;\n                return dht._verifyRecordLocallyAsync(rec);\n\n              case 8:\n                return _context13.abrupt(\"return\", rec);\n\n              case 9:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13);\n      }))();\n    },\n\n    /**\n     * Query a particular peer for the value for the given key.\n     * It will either return the value or a list of closer peers.\n     *\n     * Note: The peerbook is updated with new addresses found for the given peer.\n     *\n     * @param {PeerId} peer\n     * @param {Buffer} key\n     * @param {function(Error, Redcord, Array<PeerInfo>)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _getValueOrPeers: function _getValueOrPeers(peer, key, callback) {\n      promiseToCallback(this._getValueOrPeersAsync(peer, key))(function (err, result) {\n        if (err) return callback(err);\n        callback(null, result.record, result.peers);\n      });\n    },\n    _getValueOrPeersAsync: function _getValueOrPeersAsync(peer, key) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var msg, peers, record, errMsg;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return promisify(function (cb) {\n                  return dht._getValueSingle(peer, key, cb);\n                })();\n\n              case 2:\n                msg = _context14.sent;\n                peers = msg.closerPeers;\n                record = msg.record;\n\n                if (!record) {\n                  _context14.next = 17;\n                  break;\n                }\n\n                _context14.prev = 6;\n                _context14.next = 9;\n                return dht._verifyRecordOnlineAsync(record);\n\n              case 9:\n                _context14.next = 16;\n                break;\n\n              case 11:\n                _context14.prev = 11;\n                _context14.t0 = _context14[\"catch\"](6);\n                errMsg = 'invalid record received, discarded';\n\n                dht._log(errMsg);\n\n                throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD');\n\n              case 16:\n                return _context14.abrupt(\"return\", {\n                  record: record,\n                  peers: peers\n                });\n\n              case 17:\n                if (!(peers.length > 0)) {\n                  _context14.next = 19;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", {\n                  peers: peers\n                });\n\n              case 19:\n                throw errcode(new Error('Not found'), 'ERR_NOT_FOUND');\n\n              case 20:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, null, [[6, 11]]);\n      }))();\n    },\n\n    /**\n     * Get a value via rpc call for the given parameters.\n     *\n     * @param {PeerId} peer\n     * @param {Buffer} key\n     * @param {function(Error, Message)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _getValueSingle: function _getValueSingle(peer, key, callback) {\n      promiseToCallback(this._getValueSingleAsync(peer, key))(callback);\n    },\n    _getValueSingleAsync: function _getValueSingleAsync(peer, key) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n        var msg;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n                return _context15.abrupt(\"return\", promisify(function (cb) {\n                  return dht.network.sendRequest(peer, msg, cb);\n                })());\n\n              case 2:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15);\n      }))();\n    },\n\n    /**\n     * Verify a record, fetching missing public keys from the network.\n     * Calls back with an error if the record is invalid.\n     *\n     * @param {Record} record\n     * @param {function(Error)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _verifyRecordOnline: function _verifyRecordOnline(record, callback) {\n      promiseToCallback(this._verifyRecordOnlineAsync(record))(function (err) {\n        return callback(err);\n      });\n    },\n    _verifyRecordOnlineAsync: function _verifyRecordOnlineAsync(record) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return promisify(function (cb) {\n                  return libp2pRecord.validator.verifyRecord(dht.validators, record, cb);\n                })();\n\n              case 2:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16);\n      }))();\n    },\n\n    /**\n     * Get the public key directly from a node.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error, PublicKey)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _getPublicKeyFromNode: function _getPublicKeyFromNode(peer, callback) {\n      promiseToCallback(this._getPublicKeyFromNodeAsync(peer))(callback);\n    },\n    _getPublicKeyFromNodeAsync: function _getPublicKeyFromNodeAsync(peer) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n        var pkKey, msg, recPeer;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                pkKey = utils.keyForPublicKey(peer); // const msg = await dht._getValueSingleAsync(peer, pkKey)\n\n                _context17.next = 3;\n                return promisify(function (cb) {\n                  return dht._getValueSingle(peer, pkKey, cb);\n                })();\n\n              case 3:\n                msg = _context17.sent;\n\n                if (!(!msg.record || !msg.record.value)) {\n                  _context17.next = 6;\n                  break;\n                }\n\n                throw errcode(\"Node not responding with its public key: \".concat(peer.toB58String()), 'ERR_INVALID_RECORD');\n\n              case 6:\n                _context17.next = 8;\n                return promisify(function (cb) {\n                  return PeerId.createFromPubKey(msg.record.value, cb);\n                })();\n\n              case 8:\n                recPeer = _context17.sent;\n\n                if (recPeer.isEqual(peer)) {\n                  _context17.next = 11;\n                  break;\n                }\n\n                throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n\n              case 11:\n                return _context17.abrupt(\"return\", recPeer.pubKey);\n\n              case 12:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17);\n      }))();\n    },\n\n    /**\n     * Search the dht for up to `n` providers of the given CID.\n     *\n     * @param {CID} key\n     * @param {number} providerTimeout - How long the query should maximally run in milliseconds.\n     * @param {number} n\n     * @param {function(Error, Array<PeerInfo>)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _findNProviders: function _findNProviders(key, providerTimeout, n, callback) {\n      promiseToCallback(this._findNProvidersAsync(key, providerTimeout, n))(callback);\n    },\n    _findNProvidersAsync: function _findNProvidersAsync(key, providerTimeout, n) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n        var out, provs, paths, query, peers;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                out = new LimitedPeerList(n);\n                _context19.next = 3;\n                return dht.providers.getProviders(key);\n\n              case 3:\n                provs = _context19.sent;\n                provs.forEach(function (id) {\n                  var info;\n\n                  if (dht.peerBook.has(id)) {\n                    info = dht.peerBook.get(id);\n                  } else {\n                    info = dht.peerBook.put(new PeerInfo(id));\n                  }\n\n                  out.push(info);\n                }); // All done\n\n                if (!(out.length >= n)) {\n                  _context19.next = 7;\n                  break;\n                }\n\n                return _context19.abrupt(\"return\", out.toArray());\n\n              case 7:\n                // need more, query the network\n                paths = [];\n                query = new Query(dht, key.buffer, function (pathIndex, numPaths) {\n                  // This function body runs once per disjoint path\n                  var pathSize = utils.pathSize(n - out.length, numPaths);\n                  var pathProviders = new LimitedPeerList(pathSize);\n                  paths.push(pathProviders); // Here we return the query function to use on this particular disjoint path\n\n                  return /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(peer) {\n                      var msg, provs;\n                      return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n                        while (1) {\n                          switch (_context18.prev = _context18.next) {\n                            case 0:\n                              _context18.next = 2;\n                              return dht._findProvidersSingleAsync(peer, key);\n\n                            case 2:\n                              msg = _context18.sent;\n                              provs = msg.providerPeers;\n\n                              dht._log('(%s) found %s provider entries', dht.peerInfo.id.toB58String(), provs.length);\n\n                              provs.forEach(function (prov) {\n                                pathProviders.push(dht.peerBook.put(prov));\n                              }); // hooray we have all that we want\n\n                              if (!(pathProviders.length >= pathSize)) {\n                                _context18.next = 8;\n                                break;\n                              }\n\n                              return _context18.abrupt(\"return\", {\n                                pathComplete: true\n                              });\n\n                            case 8:\n                              return _context18.abrupt(\"return\", {\n                                closerPeers: msg.closerPeers\n                              });\n\n                            case 9:\n                            case \"end\":\n                              return _context18.stop();\n                          }\n                        }\n                      }, _callee18);\n                    }));\n\n                    return function (_x2) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }();\n                });\n                peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize);\n                _context19.prev = 10;\n                _context19.next = 13;\n                return promisify(function (callback) {\n                  return timeout(function (cb) {\n                    promiseToCallback(query.run(peers))(cb);\n                  }, providerTimeout)(callback);\n                })();\n\n              case 13:\n                _context19.next = 19;\n                break;\n\n              case 15:\n                _context19.prev = 15;\n                _context19.t0 = _context19[\"catch\"](10);\n\n                if (!(_context19.t0.code !== 'ETIMEDOUT')) {\n                  _context19.next = 19;\n                  break;\n                }\n\n                throw _context19.t0;\n\n              case 19:\n                _context19.prev = 19;\n                query.stop();\n                return _context19.finish(19);\n\n              case 22:\n                // combine peers from each path\n                paths.forEach(function (path) {\n                  path.toArray().forEach(function (peer) {\n                    out.push(peer);\n                  });\n                });\n\n                if (!(out.length === 0)) {\n                  _context19.next = 25;\n                  break;\n                }\n\n                throw errcode(new Error('no providers found'), 'ERR_NOT_FOUND');\n\n              case 25:\n                return _context19.abrupt(\"return\", out.toArray());\n\n              case 26:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, null, [[10, 15, 19, 22]]);\n      }))();\n    },\n\n    /**\n     * Check for providers from a single node.\n     *\n     * @param {PeerId} peer\n     * @param {CID} key\n     * @param {function(Error, Message)} callback\n     * @returns {void}\n     *\n     * @private\n     */\n    _findProvidersSingle: function _findProvidersSingle(peer, key, callback) {\n      promiseToCallback(this._findProvidersSingleAsync(peer, key))(callback);\n    },\n    _findProvidersSingleAsync: function _findProvidersSingleAsync(peer, key) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {\n        var msg;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0);\n                return _context20.abrupt(\"return\", promisify(function (cb) {\n                  return dht.network.sendRequest(peer, msg, cb);\n                })());\n\n              case 2:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20);\n      }))();\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-kad-dht/src/private.js"],"names":["PeerId","require","libp2pRecord","timeout","PeerInfo","promisify","promiseToCallback","errcode","utils","Message","c","Query","LimitedPeerList","Record","module","exports","dht","_nearestPeersToQuery","msg","callback","_nearestPeersToQueryAsync","convertBuffer","key","ids","routingTable","closestPeers","kBucketSize","map","p","peerBook","has","get","put","_betterPeersToQuery","peer","_betterPeersToQueryAsync","_log","closer","filter","_isSelf","id","error","isEqual","_checkLocalDatastore","_checkLocalDatastoreAsync","dsKey","bufferToKey","cb","datastore","rawRecord","code","undefined","record","deserialize","timeReceived","now","MAX_RECORD_AGE","delete","_add","_addAsync","err","add","_verifyRecordLocally","_verifyRecordLocallyAsync","validator","verifyRecord","validators","_closerPeersSingle","_closerPeersSingleAsync","toB58String","_findPeerSingleAsync","closerPeers","pInfo","other","peerInfo","equals","_findPeerSingle","target","TYPES","FIND_NODE","network","sendRequest","_putValueToPeer","rec","_putValueToPeerAsync","PUT_VALUE","resp","value","Error","_putLocal","_putLocalAsync","_get","options","_getAsync","getMany","GET_MANY_RECORD_COUNT","vals","recs","v","val","i","selection","bestRecord","selectors","best","_sendCorrectionRecord","createPutRecord","fixupRec","Promise","all","from","_getLocal","_getLocalAsync","raw","_getValueOrPeers","_getValueOrPeersAsync","result","peers","_getValueSingle","_verifyRecordOnlineAsync","errMsg","length","_getValueSingleAsync","GET_VALUE","_verifyRecordOnline","_getPublicKeyFromNode","_getPublicKeyFromNodeAsync","pkKey","keyForPublicKey","createFromPubKey","recPeer","pubKey","_findNProviders","providerTimeout","n","_findNProvidersAsync","out","providers","getProviders","provs","forEach","info","push","toArray","paths","query","buffer","pathIndex","numPaths","pathSize","pathProviders","_findProvidersSingleAsync","providerPeers","prov","pathComplete","run","stop","path","_findProvidersSingle","GET_PROVIDERS"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst libp2pRecord = require('libp2p-record')\nconst timeout = require('async/timeout')\nconst PeerInfo = require('peer-info')\nconst promisify = require('promisify-es6')\nconst promiseToCallback = require('promise-to-callback')\nconst errcode = require('err-code')\n\nconst utils = require('./utils')\nconst Message = require('./message')\nconst c = require('./constants')\nconst Query = require('./query')\nconst LimitedPeerList = require('./limited-peer-list')\n\nconst Record = libp2pRecord.Record\n\nmodule.exports = (dht) => ({\n  /**\n   * Returns the routing tables closest peers, for the key of\n   * the message.\n   *\n   * @param {Message} msg\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {undefined}\n   * @private\n   */\n  _nearestPeersToQuery (msg, callback) {\n    promiseToCallback(this._nearestPeersToQueryAsync(msg))(callback)\n  },\n\n  async _nearestPeersToQueryAsync (msg) {\n    const key = await promisify(utils.convertBuffer)(msg.key)\n\n    const ids = dht.routingTable.closestPeers(key, dht.kBucketSize)\n    return ids.map((p) => {\n      if (dht.peerBook.has(p)) {\n        return dht.peerBook.get(p)\n      }\n      return dht.peerBook.put(new PeerInfo(p))\n    })\n  },\n  /**\n   * Get the nearest peers to the given query, but iff closer\n   * than self.\n   *\n   * @param {Message} msg\n   * @param {PeerInfo} peer\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {undefined}\n   * @private\n   */\n\n  _betterPeersToQuery (msg, peer, callback) {\n    promiseToCallback(this._betterPeersToQueryAsync(msg, peer))(callback)\n  },\n\n  async _betterPeersToQueryAsync (msg, peer) {\n    dht._log('betterPeersToQuery')\n    const closer = await dht._nearestPeersToQueryAsync(msg)\n\n    return closer.filter((closer) => {\n      if (dht._isSelf(closer.id)) {\n        // Should bail, not sure\n        dht._log.error('trying to return self as closer')\n        return false\n      }\n\n      return !closer.id.isEqual(peer.id)\n    })\n  },\n\n  /**\n   * Try to fetch a given record by from the local datastore.\n   * Returns the record iff it is still valid, meaning\n   * - it was either authored by this node, or\n   * - it was received less than `MAX_RECORD_AGE` ago.\n   *\n   * @param {Buffer} key\n   * @param {function(Error, Record)} callback\n   * @returns {undefined}\n   *\n   *@private\n   */\n\n  _checkLocalDatastore (key, callback) {\n    promiseToCallback(this._checkLocalDatastoreAsync(key))(callback)\n  },\n\n  async _checkLocalDatastoreAsync (key) {\n    dht._log('checkLocalDatastore: %b', key)\n    const dsKey = utils.bufferToKey(key)\n\n    // Fetch value from ds\n    let rawRecord\n    try {\n      rawRecord = await promisify(cb => dht.datastore.get(dsKey, cb))()\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        return undefined\n      }\n      throw err\n    }\n\n    // Create record from the returned bytes\n    const record = Record.deserialize(rawRecord)\n\n    if (!record) {\n      throw errcode('Invalid record', 'ERR_INVALID_RECORD')\n    }\n\n    // Check validity: compare time received with max record age\n    if (record.timeReceived == null ||\n        utils.now() - record.timeReceived > c.MAX_RECORD_AGE) {\n      // If record is bad delete it and return\n      await promisify(cb => dht.datastore.delete(dsKey, cb))()\n      return undefined\n    }\n\n    // Record is valid\n    return record\n  },\n  /**\n   * Add the peer to the routing table and update it in the peerbook.\n   *\n   * @param {PeerInfo} peer\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   * @private\n   */\n\n  _add (peer, callback) {\n    promiseToCallback(this._addAsync(peer))(err => callback(err))\n  },\n\n  async _addAsync (peer) {\n    peer = dht.peerBook.put(peer)\n    await promisify(cb => dht.routingTable.add(peer.id, cb))()\n    return undefined\n  },\n  /**\n   * Verify a record without searching the DHT.\n   *\n   * @param {Record} record\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   * @private\n   */\n\n  _verifyRecordLocally (record, callback) {\n    promiseToCallback(this._verifyRecordLocallyAsync(record))(err => callback(err))\n  },\n\n  async _verifyRecordLocallyAsync (record) {\n    dht._log('verifyRecordLocally')\n    await promisify(cb => libp2pRecord.validator.verifyRecord(\n      dht.validators,\n      record,\n      cb\n    ))()\n  },\n\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Buffer} key\n   * @param {PeerId} peer\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _closerPeersSingle (key, peer, callback) {\n    promiseToCallback(this._closerPeersSingleAsync(key, peer))(callback)\n  },\n\n  async _closerPeersSingleAsync (key, peer) {\n    dht._log('_closerPeersSingle %b from %s', key, peer.toB58String())\n    const msg = await dht._findPeerSingleAsync(peer, new PeerId(key))\n    return msg.closerPeers\n      .filter((pInfo) => !dht._isSelf(pInfo.id))\n      .map((pInfo) => dht.peerBook.put(pInfo))\n  },\n\n  /**\n   * Is the given peer id our PeerId?\n   *\n   * @param {PeerId} other\n   * @returns {bool}\n   *\n   * @private\n   */\n\n  _isSelf (other) {\n    return other && dht.peerInfo.id.id.equals(other.id)\n  },\n\n  /**\n   * Ask peer `peer` if they know where the peer with id `target` is.\n   *\n   * @param {PeerId} peer\n   * @param {PeerId} target\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _findPeerSingle (peer, target, callback) {\n    promiseToCallback(this._findPeerSingleAsync(peer, target))(callback)\n  },\n\n  async _findPeerSingleAsync (peer, target) {\n    dht._log('_findPeerSingle %s', peer.toB58String())\n    const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0)\n    return promisify(callback => dht.network.sendRequest(peer, msg, callback))()\n  },\n\n  /**\n   * Store the given key/value pair at the peer `target`.\n   *\n   * @param {Buffer} key\n   * @param {Buffer} rec - encoded record\n   * @param {PeerId} target\n   * @param {function(Error)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _putValueToPeer (key, rec, target, callback) {\n    promiseToCallback(this._putValueToPeerAsync(key, rec, target))(callback)\n  },\n\n  async _putValueToPeerAsync (key, rec, target) {\n    const msg = new Message(Message.TYPES.PUT_VALUE, key, 0)\n    msg.record = rec\n\n    const resp = await promisify(cb => dht.network.sendRequest(target, msg, cb))()\n\n    if (!resp.record.value.equals(Record.deserialize(rec).value)) {\n      throw errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID')\n    }\n  },\n\n  /**\n   * Store the given key/value pair locally, in the datastore.\n   * @param {Buffer} key\n   * @param {Buffer} rec - encoded record\n   * @param {function(Error)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _putLocal (key, rec, callback) {\n    promiseToCallback(this._putLocalAsync(key, rec))(err => callback(err))\n  },\n\n  async _putLocalAsync (key, rec) {\n    await promisify(cb => dht.datastore.put(utils.bufferToKey(key), rec, cb))()\n    return undefined\n  },\n\n  /**\n   * Get the value for given key.\n   *\n   * @param {Buffer} key\n   * @param {Object} options - get options\n   * @param {number} options.timeout - optional timeout (default: 60000)\n   * @param {function(Error, Record)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _get (key, options, callback) {\n    promiseToCallback(this._getAsync(key, options))(callback)\n  },\n\n  async _getAsync (key, options) {\n    dht._log('_get %b', key)\n\n    const vals = await promisify(cb => dht.getMany(key, c.GET_MANY_RECORD_COUNT, options, cb))()\n\n    const recs = vals.map((v) => v.val)\n    let i = 0\n\n    try {\n      i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs)\n    } catch (err) {\n      // Assume the first record if no selector available\n      if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n        throw err\n      }\n    }\n\n    const best = recs[i]\n    dht._log('GetValue %b %s', key, best)\n\n    if (!best) {\n      throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND')\n    }\n\n    await this._sendCorrectionRecord(key, vals, best)\n\n    return best\n  },\n\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Buffer} key\n   * @param {Array<Object>} vals - values retrieved from the DHT\n   * @param {Object} best - the best record that was found\n   * @returns {Promise}\n   *\n   * @private\n   */\n  async _sendCorrectionRecord (key, vals, best) {\n    const fixupRec = await promisify(cb => utils.createPutRecord(key, best, cb))()\n\n    return Promise.all(vals.map(async (v) => {\n      // no need to do anything\n      if (v.val.equals(best)) {\n        return\n      }\n\n      // correct ourself\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocalAsync(key, fixupRec)\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err)\n        }\n        return\n      }\n\n      // send correction\n      try {\n        await dht._putValueToPeerAsync(key, fixupRec, v.from)\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err)\n      }\n    }))\n  },\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Buffer} key\n   * @param {function(Error, Record)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _getLocal (key, callback) {\n    promiseToCallback(this._getLocalAsync(key))(callback)\n  },\n\n  async _getLocalAsync (key) {\n    dht._log('getLocal %b', key)\n\n    const raw = await promisify(cb => dht.datastore.get(utils.bufferToKey(key), cb))()\n    dht._log('found %b in local datastore', key)\n    const rec = Record.deserialize(raw)\n\n    await dht._verifyRecordLocallyAsync(rec)\n    return rec\n  },\n\n  /**\n   * Query a particular peer for the value for the given key.\n   * It will either return the value or a list of closer peers.\n   *\n   * Note: The peerbook is updated with new addresses found for the given peer.\n   *\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @param {function(Error, Redcord, Array<PeerInfo>)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _getValueOrPeers (peer, key, callback) {\n    promiseToCallback(this._getValueOrPeersAsync(peer, key))((err, result) => {\n      if (err) return callback(err)\n      callback(null, result.record, result.peers)\n    })\n  },\n\n  async _getValueOrPeersAsync (peer, key) {\n    const msg = await promisify(cb => dht._getValueSingle(peer, key, cb))()\n\n    const peers = msg.closerPeers\n    const record = msg.record\n\n    if (record) {\n      // We have a record\n      try {\n        await dht._verifyRecordOnlineAsync(record)\n      } catch (err) {\n        const errMsg = 'invalid record received, discarded'\n        dht._log(errMsg)\n        throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD')\n      }\n\n      return { record, peers }\n    }\n\n    if (peers.length > 0) {\n      return { peers }\n    }\n\n    throw errcode(new Error('Not found'), 'ERR_NOT_FOUND')\n  },\n\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _getValueSingle (peer, key, callback) {\n    promiseToCallback(this._getValueSingleAsync(peer, key))(callback)\n  },\n\n  async _getValueSingleAsync (peer, key) {\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0)\n    return promisify(cb => dht.network.sendRequest(peer, msg, cb))()\n  },\n\n  /**\n   * Verify a record, fetching missing public keys from the network.\n   * Calls back with an error if the record is invalid.\n   *\n   * @param {Record} record\n   * @param {function(Error)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _verifyRecordOnline (record, callback) {\n    promiseToCallback(this._verifyRecordOnlineAsync(record))(err => callback(err))\n  },\n\n  async _verifyRecordOnlineAsync (record) {\n    await promisify(cb => libp2pRecord.validator.verifyRecord(dht.validators, record, cb))()\n  },\n\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PublicKey)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _getPublicKeyFromNode (peer, callback) {\n    promiseToCallback(this._getPublicKeyFromNodeAsync(peer))(callback)\n  },\n\n  async _getPublicKeyFromNodeAsync (peer) {\n    const pkKey = utils.keyForPublicKey(peer)\n    // const msg = await dht._getValueSingleAsync(peer, pkKey)\n    const msg = await promisify(cb => dht._getValueSingle(peer, pkKey, cb))()\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(`Node not responding with its public key: ${peer.toB58String()}`, 'ERR_INVALID_RECORD')\n    }\n\n    const recPeer = await promisify(cb => PeerId.createFromPubKey(msg.record.value, cb))()\n\n    // compare hashes of the pub key\n    if (!recPeer.isEqual(peer)) {\n      throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')\n    }\n\n    return recPeer.pubKey\n  },\n\n  /**\n   * Search the dht for up to `n` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {number} providerTimeout - How long the query should maximally run in milliseconds.\n   * @param {number} n\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _findNProviders (key, providerTimeout, n, callback) {\n    promiseToCallback(this._findNProvidersAsync(key, providerTimeout, n))(callback)\n  },\n\n  async _findNProvidersAsync (key, providerTimeout, n) {\n    const out = new LimitedPeerList(n)\n\n    const provs = await dht.providers.getProviders(key)\n\n    provs.forEach((id) => {\n      let info\n      if (dht.peerBook.has(id)) {\n        info = dht.peerBook.get(id)\n      } else {\n        info = dht.peerBook.put(new PeerInfo(id))\n      }\n      out.push(info)\n    })\n\n    // All done\n    if (out.length >= n) {\n      return out.toArray()\n    }\n\n    // need more, query the network\n    const paths = []\n    const query = new Query(dht, key.buffer, (pathIndex, numPaths) => {\n      // This function body runs once per disjoint path\n      const pathSize = utils.pathSize(n - out.length, numPaths)\n      const pathProviders = new LimitedPeerList(pathSize)\n      paths.push(pathProviders)\n\n      // Here we return the query function to use on this particular disjoint path\n      return async (peer) => {\n        const msg = await dht._findProvidersSingleAsync(peer, key)\n        const provs = msg.providerPeers\n        dht._log('(%s) found %s provider entries', dht.peerInfo.id.toB58String(), provs.length)\n\n        provs.forEach((prov) => {\n          pathProviders.push(dht.peerBook.put(prov))\n        })\n\n        // hooray we have all that we want\n        if (pathProviders.length >= pathSize) {\n          return { pathComplete: true }\n        }\n\n        // it looks like we want some more\n        return { closerPeers: msg.closerPeers }\n      }\n    })\n\n    const peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize)\n\n    try {\n      await promisify(callback => timeout((cb) => {\n        promiseToCallback(query.run(peers))(cb)\n      }, providerTimeout)(callback))()\n    } catch (err) {\n      if (err.code !== 'ETIMEDOUT') {\n        throw err\n      }\n    } finally {\n      query.stop()\n    }\n\n    // combine peers from each path\n    paths.forEach((path) => {\n      path.toArray().forEach((peer) => {\n        out.push(peer)\n      })\n    })\n\n    if (out.length === 0) {\n      throw errcode(new Error('no providers found'), 'ERR_NOT_FOUND')\n    }\n\n    return out.toArray()\n  },\n\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _findProvidersSingle (peer, key, callback) {\n    promiseToCallback(this._findProvidersSingleAsync(peer, key))(callback)\n  },\n\n  async _findProvidersSingleAsync (peer, key) {\n    const msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0)\n    return promisify(cb => dht.network.sendRequest(peer, msg, cb))()\n  }\n})\n"]},"metadata":{},"sourceType":"script"}