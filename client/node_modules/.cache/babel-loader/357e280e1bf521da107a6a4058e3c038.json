{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar each = require('async/each');\n\nvar eachSeries = require('async/eachSeries');\n\nvar waterfall = require('async/waterfall');\n\nvar nextTick = require('async/nextTick');\n\nvar map = require('async/map');\n\nvar debounce = require('just-debounce-it');\n\nvar Message = require('../types/message');\n\nvar Wantlist = require('../types/wantlist');\n\nvar Ledger = require('./ledger');\n\nvar _require = require('../utils'),\n    logger = _require.logger,\n    groupBy = _require.groupBy,\n    pullAllWith = _require.pullAllWith,\n    uniqWith = _require.uniqWith;\n\nvar MAX_MESSAGE_SIZE = 512 * 1024;\n\nvar DecisionEngine = /*#__PURE__*/function () {\n  function DecisionEngine(peerId, blockstore, network, stats) {\n    _classCallCheck(this, DecisionEngine);\n\n    this._log = logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats; // A list of of ledgers by their partner id\n\n    this.ledgerMap = new Map();\n    this._running = false; // List of tasks to be processed\n\n    this._tasks = [];\n    this._outbox = debounce(this._processTasks.bind(this), 100);\n  }\n\n  _createClass(DecisionEngine, [{\n    key: \"_sendBlocks\",\n    value: function _sendBlocks(peer, blocks, cb) {\n      var _this = this;\n\n      // split into messges of max 512 * 1024 bytes\n      var total = blocks.reduce(function (acc, b) {\n        return acc + b.data.byteLength;\n      }, 0);\n\n      if (total < MAX_MESSAGE_SIZE) {\n        return this._sendSafeBlocks(peer, blocks, cb);\n      }\n\n      var size = 0;\n      var batch = [];\n      var outstanding = blocks.length;\n      eachSeries(blocks, function (b, cb) {\n        outstanding--;\n        batch.push(b);\n        size += b.data.byteLength;\n\n        if (size >= MAX_MESSAGE_SIZE || // need to ensure the last remaining items get sent\n        outstanding === 0) {\n          size = 0;\n          var nextBatch = batch.slice();\n          batch = [];\n\n          _this._sendSafeBlocks(peer, nextBatch, function (err) {\n            if (err) {\n              _this._log('sendblock error: %s', err.message);\n            } // not returning the error, so we send as much as we can\n            // as otherwise `eachSeries` would cancel\n\n\n            cb();\n          });\n        } else {\n          nextTick(cb);\n        }\n      }, cb);\n    }\n  }, {\n    key: \"_sendSafeBlocks\",\n    value: function _sendSafeBlocks(peer, blocks, cb) {\n      var msg = new Message(false);\n      blocks.forEach(function (b) {\n        return msg.addBlock(b);\n      });\n      this.network.sendMessage(peer, msg, cb);\n    }\n  }, {\n    key: \"_processTasks\",\n    value: function _processTasks() {\n      var _this2 = this;\n\n      if (!this._running || !this._tasks.length) {\n        return;\n      }\n\n      var tasks = this._tasks;\n      this._tasks = [];\n      var entries = tasks.map(function (t) {\n        return t.entry;\n      });\n      var cids = entries.map(function (e) {\n        return e.cid;\n      });\n      var uniqCids = uniqWith(function (a, b) {\n        return a.equals(b);\n      }, cids);\n      var groupedTasks = groupBy(function (task) {\n        return task.target.toB58String();\n      }, tasks);\n      waterfall([function (callback) {\n        return map(uniqCids, function (cid, cb) {\n          _this2.blockstore.get(cid, cb);\n        }, callback);\n      }, function (blocks, callback) {\n        return each(Object.values(groupedTasks), function (tasks, cb) {\n          // all tasks have the same target\n          var peer = tasks[0].target;\n          var blockList = cids.map(function (cid) {\n            return blocks.find(function (b) {\n              return b.cid.equals(cid);\n            });\n          });\n\n          _this2._sendBlocks(peer, blockList, function (err) {\n            if (err) {\n              // `_sendBlocks` actually doesn't return any errors\n              _this2._log.error('should never happen: ', err);\n            } else {\n              blockList.forEach(function (block) {\n                return _this2.messageSent(peer, block);\n              });\n            }\n\n            cb();\n          });\n        }, callback);\n      }], function (err) {\n        _this2._tasks = [];\n\n        if (err) {\n          _this2._log.error(err);\n        }\n      });\n    }\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId) {\n      var peerIdStr = peerId.toB58String();\n\n      if (!this.ledgerMap.has(peerIdStr)) {\n        return new Map();\n      }\n\n      return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries();\n    }\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      var peerIdStr = peerId.toB58String();\n      var ledger = this.ledgerMap.get(peerIdStr);\n\n      if (!ledger) {\n        return null;\n      }\n\n      return {\n        peer: ledger.partner.toPrint(),\n        value: ledger.debtRatio(),\n        sent: ledger.accounting.bytesSent,\n        recv: ledger.accounting.bytesRecv,\n        exchanged: ledger.exchangeCount\n      };\n    }\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return Array.from(this.ledgerMap.values()).map(function (l) {\n        return l.partner;\n      });\n    }\n  }, {\n    key: \"receivedBlocks\",\n    value: function receivedBlocks(cids) {\n      var _this3 = this;\n\n      if (!cids.length) {\n        return;\n      } // Check all connected peers if they want the block we received\n\n\n      this.ledgerMap.forEach(function (ledger) {\n        cids.map(function (cid) {\n          return ledger.wantlistContains(cid);\n        }).filter(Boolean).forEach(function (entry) {\n          _this3._tasks.push({\n            entry: entry,\n            target: ledger.partner\n          });\n        });\n      });\n\n      this._outbox();\n    } // Handle incoming messages\n\n  }, {\n    key: \"messageReceived\",\n    value: function messageReceived(peerId, msg, cb) {\n      var ledger = this._findOrCreate(peerId);\n\n      if (msg.empty) {\n        return nextTick(cb);\n      } // If the message was a full wantlist clear the current one\n\n\n      if (msg.full) {\n        ledger.wantlist = new Wantlist();\n      }\n\n      this._processBlocks(msg.blocks, ledger);\n\n      if (msg.wantlist.size === 0) {\n        return nextTick(cb);\n      }\n\n      var cancels = [];\n      var wants = [];\n      msg.wantlist.forEach(function (entry) {\n        if (entry.cancel) {\n          ledger.cancelWant(entry.cid);\n          cancels.push(entry);\n        } else {\n          ledger.wants(entry.cid, entry.priority);\n          wants.push(entry);\n        }\n      });\n\n      this._cancelWants(ledger, peerId, cancels);\n\n      this._addWants(ledger, peerId, wants, cb);\n    }\n  }, {\n    key: \"_cancelWants\",\n    value: function _cancelWants(ledger, peerId, entries) {\n      var id = peerId.toB58String();\n      this._tasks = pullAllWith(function (t, e) {\n        var sameTarget = t.target.toB58String() === id;\n        var sameCid = t.entry.cid.equals(e.cid);\n        return sameTarget && sameCid;\n      }, this._tasks, entries);\n    }\n  }, {\n    key: \"_addWants\",\n    value: function _addWants(ledger, peerId, entries, callback) {\n      var _this4 = this;\n\n      each(entries, function (entry, cb) {\n        // If we already have the block, serve it\n        _this4.blockstore.has(entry.cid, function (err, exists) {\n          if (err) {\n            _this4._log.error('failed existence check');\n          } else if (exists) {\n            _this4._tasks.push({\n              entry: entry.entry,\n              target: peerId\n            });\n          }\n\n          cb();\n        });\n      }, function () {\n        _this4._outbox();\n\n        callback();\n      });\n    }\n  }, {\n    key: \"_processBlocks\",\n    value: function _processBlocks(blocks, ledger, callback) {\n      var _this5 = this;\n\n      var cids = [];\n      blocks.forEach(function (b, cidStr) {\n        _this5._log('got block (%s bytes)', b.data.length);\n\n        ledger.receivedBytes(b.data.length);\n        cids.push(b.cid);\n      });\n      this.receivedBlocks(cids);\n    } // Clear up all accounting things after message was sent\n\n  }, {\n    key: \"messageSent\",\n    value: function messageSent(peerId, block) {\n      var ledger = this._findOrCreate(peerId);\n\n      ledger.sentBytes(block ? block.data.length : 0);\n\n      if (block && block.cid) {\n        ledger.wantlist.remove(block.cid);\n      }\n    }\n  }, {\n    key: \"numBytesSentTo\",\n    value: function numBytesSentTo(peerId) {\n      return this._findOrCreate(peerId).accounting.bytesSent;\n    }\n  }, {\n    key: \"numBytesReceivedFrom\",\n    value: function numBytesReceivedFrom(peerId) {\n      return this._findOrCreate(peerId).accounting.bytesRecv;\n    }\n  }, {\n    key: \"peerDisconnected\",\n    value: function peerDisconnected(peerId) {// if (this.ledgerMap.has(peerId.toB58String())) {\n      //   this.ledgerMap.delete(peerId.toB58String())\n      // }\n      //\n      // TODO: figure out how to remove all other references\n      // in the peer request queue\n    }\n  }, {\n    key: \"_findOrCreate\",\n    value: function _findOrCreate(peerId) {\n      var peerIdStr = peerId.toB58String();\n\n      if (this.ledgerMap.has(peerIdStr)) {\n        return this.ledgerMap.get(peerIdStr);\n      }\n\n      var l = new Ledger(peerId);\n      this.ledgerMap.set(peerIdStr, l);\n\n      if (this._stats) {\n        this._stats.push(peerIdStr, 'peerCount', 1);\n      }\n\n      return l;\n    }\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      this._running = true;\n      nextTick(function () {\n        return callback();\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      this._running = false;\n      nextTick(function () {\n        return callback();\n      });\n    }\n  }]);\n\n  return DecisionEngine;\n}();\n\nmodule.exports = DecisionEngine;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs-bitswap/src/decision-engine/index.js"],"names":["each","require","eachSeries","waterfall","nextTick","map","debounce","Message","Wantlist","Ledger","logger","groupBy","pullAllWith","uniqWith","MAX_MESSAGE_SIZE","DecisionEngine","peerId","blockstore","network","stats","_log","_stats","ledgerMap","Map","_running","_tasks","_outbox","_processTasks","bind","peer","blocks","cb","total","reduce","acc","b","data","byteLength","_sendSafeBlocks","size","batch","outstanding","length","push","nextBatch","slice","err","message","msg","forEach","addBlock","sendMessage","tasks","entries","t","entry","cids","e","cid","uniqCids","a","equals","groupedTasks","task","target","toB58String","callback","get","Object","values","blockList","find","_sendBlocks","error","block","messageSent","peerIdStr","has","wantlist","sortedEntries","ledger","partner","toPrint","value","debtRatio","sent","accounting","bytesSent","recv","bytesRecv","exchanged","exchangeCount","Array","from","l","wantlistContains","filter","Boolean","_findOrCreate","empty","full","_processBlocks","cancels","wants","cancel","cancelWant","priority","_cancelWants","_addWants","id","sameTarget","sameCid","exists","cidStr","receivedBytes","receivedBlocks","sentBytes","remove","set","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst each = require('async/each')\nconst eachSeries = require('async/eachSeries')\nconst waterfall = require('async/waterfall')\nconst nextTick = require('async/nextTick')\n\nconst map = require('async/map')\nconst debounce = require('just-debounce-it')\n\nconst Message = require('../types/message')\nconst Wantlist = require('../types/wantlist')\nconst Ledger = require('./ledger')\nconst { logger, groupBy, pullAllWith, uniqWith } = require('../utils')\n\nconst MAX_MESSAGE_SIZE = 512 * 1024\n\nclass DecisionEngine {\n  constructor (peerId, blockstore, network, stats) {\n    this._log = logger(peerId, 'engine')\n    this.blockstore = blockstore\n    this.network = network\n    this._stats = stats\n\n    // A list of of ledgers by their partner id\n    this.ledgerMap = new Map()\n    this._running = false\n\n    // List of tasks to be processed\n    this._tasks = []\n\n    this._outbox = debounce(this._processTasks.bind(this), 100)\n  }\n\n  _sendBlocks (peer, blocks, cb) {\n    // split into messges of max 512 * 1024 bytes\n    const total = blocks.reduce((acc, b) => {\n      return acc + b.data.byteLength\n    }, 0)\n\n    if (total < MAX_MESSAGE_SIZE) {\n      return this._sendSafeBlocks(peer, blocks, cb)\n    }\n\n    let size = 0\n    let batch = []\n    let outstanding = blocks.length\n\n    eachSeries(blocks, (b, cb) => {\n      outstanding--\n      batch.push(b)\n      size += b.data.byteLength\n\n      if (size >= MAX_MESSAGE_SIZE ||\n          // need to ensure the last remaining items get sent\n          outstanding === 0) {\n        size = 0\n        const nextBatch = batch.slice()\n        batch = []\n        this._sendSafeBlocks(peer, nextBatch, (err) => {\n          if (err) {\n            this._log('sendblock error: %s', err.message)\n          }\n          // not returning the error, so we send as much as we can\n          // as otherwise `eachSeries` would cancel\n          cb()\n        })\n      } else {\n        nextTick(cb)\n      }\n    }, cb)\n  }\n\n  _sendSafeBlocks (peer, blocks, cb) {\n    const msg = new Message(false)\n    blocks.forEach((b) => msg.addBlock(b))\n\n    this.network.sendMessage(peer, msg, cb)\n  }\n\n  _processTasks () {\n    if (!this._running || !this._tasks.length) {\n      return\n    }\n\n    const tasks = this._tasks\n    this._tasks = []\n    const entries = tasks.map((t) => t.entry)\n    const cids = entries.map((e) => e.cid)\n    const uniqCids = uniqWith((a, b) => a.equals(b), cids)\n    const groupedTasks = groupBy(task => task.target.toB58String(), tasks)\n\n    waterfall([\n      (callback) => map(uniqCids, (cid, cb) => {\n        this.blockstore.get(cid, cb)\n      }, callback),\n      (blocks, callback) => each(Object.values(groupedTasks), (tasks, cb) => {\n        // all tasks have the same target\n        const peer = tasks[0].target\n        const blockList = cids.map((cid) => {\n          return blocks.find(b => b.cid.equals(cid))\n        })\n\n        this._sendBlocks(peer, blockList, (err) => {\n          if (err) {\n            // `_sendBlocks` actually doesn't return any errors\n            this._log.error('should never happen: ', err)\n          } else {\n            blockList.forEach((block) => this.messageSent(peer, block))\n          }\n\n          cb()\n        })\n      }, callback)\n    ], (err) => {\n      this._tasks = []\n\n      if (err) {\n        this._log.error(err)\n      }\n    })\n  }\n\n  wantlistForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n    if (!this.ledgerMap.has(peerIdStr)) {\n      return new Map()\n    }\n\n    return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries()\n  }\n\n  ledgerForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n\n    const ledger = this.ledgerMap.get(peerIdStr)\n    if (!ledger) {\n      return null\n    }\n    return {\n      peer: ledger.partner.toPrint(),\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    }\n  }\n\n  peers () {\n    return Array.from(this.ledgerMap.values()).map((l) => l.partner)\n  }\n\n  receivedBlocks (cids) {\n    if (!cids.length) {\n      return\n    }\n    // Check all connected peers if they want the block we received\n    this.ledgerMap.forEach((ledger) => {\n      cids\n        .map((cid) => ledger.wantlistContains(cid))\n        .filter(Boolean)\n        .forEach((entry) => {\n          this._tasks.push({\n            entry: entry,\n            target: ledger.partner\n          })\n        })\n    })\n    this._outbox()\n  }\n\n  // Handle incoming messages\n  messageReceived (peerId, msg, cb) {\n    const ledger = this._findOrCreate(peerId)\n\n    if (msg.empty) {\n      return nextTick(cb)\n    }\n\n    // If the message was a full wantlist clear the current one\n    if (msg.full) {\n      ledger.wantlist = new Wantlist()\n    }\n\n    this._processBlocks(msg.blocks, ledger)\n\n    if (msg.wantlist.size === 0) {\n      return nextTick(cb)\n    }\n\n    let cancels = []\n    let wants = []\n    msg.wantlist.forEach((entry) => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid)\n        cancels.push(entry)\n      } else {\n        ledger.wants(entry.cid, entry.priority)\n        wants.push(entry)\n      }\n    })\n\n    this._cancelWants(ledger, peerId, cancels)\n    this._addWants(ledger, peerId, wants, cb)\n  }\n\n  _cancelWants (ledger, peerId, entries) {\n    const id = peerId.toB58String()\n\n    this._tasks = pullAllWith((t, e) => {\n      const sameTarget = t.target.toB58String() === id\n      const sameCid = t.entry.cid.equals(e.cid)\n      return sameTarget && sameCid\n    }, this._tasks, entries)\n  }\n\n  _addWants (ledger, peerId, entries, callback) {\n    each(entries, (entry, cb) => {\n      // If we already have the block, serve it\n      this.blockstore.has(entry.cid, (err, exists) => {\n        if (err) {\n          this._log.error('failed existence check')\n        } else if (exists) {\n          this._tasks.push({\n            entry: entry.entry,\n            target: peerId\n          })\n        }\n        cb()\n      })\n    }, () => {\n      this._outbox()\n      callback()\n    })\n  }\n\n  _processBlocks (blocks, ledger, callback) {\n    const cids = []\n    blocks.forEach((b, cidStr) => {\n      this._log('got block (%s bytes)', b.data.length)\n      ledger.receivedBytes(b.data.length)\n      cids.push(b.cid)\n    })\n\n    this.receivedBlocks(cids)\n  }\n\n  // Clear up all accounting things after message was sent\n  messageSent (peerId, block) {\n    const ledger = this._findOrCreate(peerId)\n    ledger.sentBytes(block ? block.data.length : 0)\n    if (block && block.cid) {\n      ledger.wantlist.remove(block.cid)\n    }\n  }\n\n  numBytesSentTo (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent\n  }\n\n  numBytesReceivedFrom (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv\n  }\n\n  peerDisconnected (peerId) {\n    // if (this.ledgerMap.has(peerId.toB58String())) {\n    //   this.ledgerMap.delete(peerId.toB58String())\n    // }\n    //\n    // TODO: figure out how to remove all other references\n    // in the peer request queue\n  }\n\n  _findOrCreate (peerId) {\n    const peerIdStr = peerId.toB58String()\n    if (this.ledgerMap.has(peerIdStr)) {\n      return this.ledgerMap.get(peerIdStr)\n    }\n\n    const l = new Ledger(peerId)\n\n    this.ledgerMap.set(peerIdStr, l)\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1)\n    }\n\n    return l\n  }\n\n  start (callback) {\n    this._running = true\n    nextTick(() => callback())\n  }\n\n  stop (callback) {\n    this._running = false\n    nextTick(() => callback())\n  }\n}\n\nmodule.exports = DecisionEngine\n"]},"metadata":{},"sourceType":"script"}