{"ast":null,"code":"'use strict';\n\nvar PeerInfo = require('peer-info');\n\nvar PeerId = require('peer-id');\n\nvar multiaddr = require('multiaddr');\n\nvar pull = require('pull-stream/pull');\n\nvar take = require('pull-stream/throughs/take');\n\nvar collect = require('pull-stream/sinks/collect');\n\nvar lp = require('pull-length-prefixed');\n\nvar msg = require('./message');\n\nmodule.exports = function (conn, expectedPeerInfo, callback) {\n  if (typeof expectedPeerInfo === 'function') {\n    callback = expectedPeerInfo;\n    expectedPeerInfo = null;\n    console.warn('WARNING: no expected peer info was given, identify will not be able to verify peer integrity');\n  }\n\n  pull(conn, lp.decode(), take(1), collect(function (err, data) {\n    if (err) {\n      return callback(err);\n    } // connection got closed graciously\n\n\n    if (data.length === 0) {\n      return callback(new Error('conn was closed, did not receive data'));\n    }\n\n    var input = msg.decode(data[0]);\n    PeerId.createFromPubKey(input.publicKey, function (err, id) {\n      if (err) {\n        return callback(err);\n      }\n\n      var peerInfo = new PeerInfo(id);\n\n      if (expectedPeerInfo && expectedPeerInfo.id.toB58String() !== id.toB58String()) {\n        return callback(new Error('invalid peer'));\n      }\n\n      try {\n        input.listenAddrs.map(multiaddr).forEach(function (ma) {\n          return peerInfo.multiaddrs.add(ma);\n        });\n      } catch (err) {\n        return callback(err);\n      }\n\n      var observedAddr;\n\n      try {\n        observedAddr = getObservedAddrs(input);\n      } catch (err) {\n        return callback(err);\n      } // Copy the protocols\n\n\n      peerInfo.protocols = new Set(input.protocols);\n      callback(null, peerInfo, observedAddr);\n    });\n  }));\n};\n\nfunction getObservedAddrs(input) {\n  if (!hasObservedAddr(input)) {\n    return [];\n  }\n\n  var addrs = input.observedAddr;\n\n  if (!Array.isArray(addrs)) {\n    addrs = [addrs];\n  }\n\n  return addrs.map(function (oa) {\n    return multiaddr(oa);\n  });\n}\n\nfunction hasObservedAddr(input) {\n  return input.observedAddr && input.observedAddr.length > 0;\n}","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-identify/src/dialer.js"],"names":["PeerInfo","require","PeerId","multiaddr","pull","take","collect","lp","msg","module","exports","conn","expectedPeerInfo","callback","console","warn","decode","err","data","length","Error","input","createFromPubKey","publicKey","id","peerInfo","toB58String","listenAddrs","map","forEach","ma","multiaddrs","add","observedAddr","getObservedAddrs","protocols","Set","hasObservedAddr","addrs","Array","isArray","oa"],"mappings":"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","sourcesContent":["'use strict'\nconst PeerInfo = require('peer-info')\nconst PeerId = require('peer-id')\nconst multiaddr = require('multiaddr')\nconst pull = require('pull-stream/pull')\nconst take = require('pull-stream/throughs/take')\nconst collect = require('pull-stream/sinks/collect')\nconst lp = require('pull-length-prefixed')\n\nconst msg = require('./message')\n\nmodule.exports = (conn, expectedPeerInfo, callback) => {\n  if (typeof expectedPeerInfo === 'function') {\n    callback = expectedPeerInfo\n    expectedPeerInfo = null\n    console.warn('WARNING: no expected peer info was given, identify will not be able to verify peer integrity')\n  }\n\n  pull(\n    conn,\n    lp.decode(),\n    take(1),\n    collect((err, data) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // connection got closed graciously\n      if (data.length === 0) {\n        return callback(new Error('conn was closed, did not receive data'))\n      }\n\n      const input = msg.decode(data[0])\n\n      PeerId.createFromPubKey(input.publicKey, (err, id) => {\n        if (err) {\n          return callback(err)\n        }\n\n        const peerInfo = new PeerInfo(id)\n        if (expectedPeerInfo && expectedPeerInfo.id.toB58String() !== id.toB58String()) {\n          return callback(new Error('invalid peer'))\n        }\n\n        try {\n          input.listenAddrs\n            .map(multiaddr)\n            .forEach((ma) => peerInfo.multiaddrs.add(ma))\n        } catch (err) {\n          return callback(err)\n        }\n\n        let observedAddr\n\n        try {\n          observedAddr = getObservedAddrs(input)\n        } catch (err) {\n          return callback(err)\n        }\n\n        // Copy the protocols\n        peerInfo.protocols = new Set(input.protocols)\n\n        callback(null, peerInfo, observedAddr)\n      })\n    })\n  )\n}\n\nfunction getObservedAddrs (input) {\n  if (!hasObservedAddr(input)) {\n    return []\n  }\n\n  let addrs = input.observedAddr\n\n  if (!Array.isArray(addrs)) {\n    addrs = [addrs]\n  }\n\n  return addrs.map((oa) => multiaddr(oa))\n}\n\nfunction hasObservedAddr (input) {\n  return input.observedAddr && input.observedAddr.length > 0\n}\n"]},"metadata":{},"sourceType":"script"}