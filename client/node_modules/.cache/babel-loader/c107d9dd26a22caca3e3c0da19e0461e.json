{"ast":null,"code":"'use strict';\n\nvar Key = require('interface-datastore').Key;\n\nvar queue = require('async/queue');\n\nvar waterfall = require('async/waterfall');\n\nvar _get = require('dlv');\n\nvar _set = require('just-safe-set');\n\nvar Buffer = require('buffer').Buffer;\n\nvar configKey = new Key('config');\n\nmodule.exports = function (store) {\n  var setQueue = queue(_doSet, 1);\n  var configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {String} key - the config key to get\n     * @param {function(Error, Object)} callback\n     * @returns {void}\n     */\n    get: function get(key, callback) {\n      if (typeof key === 'function') {\n        callback = key;\n        key = undefined;\n      }\n\n      if (!key) {\n        key = undefined;\n      }\n\n      store.get(configKey, function (err, encodedValue) {\n        if (err) {\n          return callback(err);\n        }\n\n        var config;\n\n        try {\n          config = JSON.parse(encodedValue.toString());\n        } catch (err) {\n          return callback(err);\n        }\n\n        if (typeof key === 'undefined') {\n          return callback(null, config);\n        }\n\n        if (typeof key !== 'string') {\n          return callback(new Error('Key ' + key + ' must be a string.'));\n        }\n\n        var value = _get(config, key, null);\n\n        if (value === null) {\n          return callback(new Error('Key ' + key + ' does not exist in config.'));\n        }\n\n        callback(null, value);\n      });\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {String} key - the config key to be written\n     * @param {Object} value - the config value to be written\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    set: function set(key, value, callback) {\n      if (typeof value === 'function') {\n        callback = value;\n        value = key;\n        key = undefined;\n      } else if (!key || typeof key !== 'string') {\n        return callback(new Error('Invalid key type'));\n      }\n\n      if (value === undefined || Buffer.isBuffer(value)) {\n        return callback(new Error('Invalid value type'));\n      }\n\n      setQueue.push({\n        key: key,\n        value: value\n      }, callback);\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     * @param {function(Error, bool)} callback\n     * @returns {void}\n     */\n    exists: function exists(callback) {\n      store.has(configKey, callback);\n    }\n  };\n  return configStore;\n\n  function _doSet(m, callback) {\n    var key = m.key;\n    var value = m.value;\n\n    if (key) {\n      waterfall([function (cb) {\n        return configStore.get(cb);\n      }, function (config, cb) {\n        _set(config, key, value);\n\n        cb(null, config);\n      }, _saveAll], callback);\n    } else {\n      _saveAll(value, callback);\n    }\n  }\n\n  function _saveAll(config, callback) {\n    var buf = Buffer.from(JSON.stringify(config, null, 2));\n    store.put(configKey, buf, callback);\n  }\n};","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs-repo/src/config.js"],"names":["Key","require","queue","waterfall","_get","_set","Buffer","configKey","module","exports","store","setQueue","_doSet","configStore","get","key","callback","undefined","err","encodedValue","config","JSON","parse","toString","Error","value","set","isBuffer","push","exists","has","m","cb","_saveAll","buf","from","stringify","put"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Key = require('interface-datastore').Key\nconst queue = require('async/queue')\nconst waterfall = require('async/waterfall')\nconst _get = require('dlv')\nconst _set = require('just-safe-set')\nconst Buffer = require('buffer').Buffer\n\nconst configKey = new Key('config')\n\nmodule.exports = (store) => {\n  const setQueue = queue(_doSet, 1)\n\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {String} key - the config key to get\n     * @param {function(Error, Object)} callback\n     * @returns {void}\n     */\n    get (key, callback) {\n      if (typeof key === 'function') {\n        callback = key\n        key = undefined\n      }\n      if (!key) {\n        key = undefined\n      }\n      store.get(configKey, (err, encodedValue) => {\n        if (err) { return callback(err) }\n\n        let config\n        try {\n          config = JSON.parse(encodedValue.toString())\n        } catch (err) {\n          return callback(err)\n        }\n\n        if (typeof key === 'undefined') {\n          return callback(null, config)\n        }\n\n        if (typeof key !== 'string') {\n          return callback(new Error('Key ' + key + ' must be a string.'))\n        }\n\n        const value = _get(config, key, null)\n\n        if (value === null) {\n          return callback(new Error('Key ' + key + ' does not exist in config.'))\n        }\n\n        callback(null, value)\n      })\n    },\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {String} key - the config key to be written\n     * @param {Object} value - the config value to be written\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    set (key, value, callback) {\n      if (typeof value === 'function') {\n        callback = value\n        value = key\n        key = undefined\n      } else if (!key || typeof key !== 'string') {\n        return callback(new Error('Invalid key type'))\n      }\n\n      if (value === undefined || Buffer.isBuffer(value)) {\n        return callback(new Error('Invalid value type'))\n      }\n\n      setQueue.push({\n        key: key,\n        value: value\n      }, callback)\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     * @param {function(Error, bool)} callback\n     * @returns {void}\n     */\n    exists (callback) {\n      store.has(configKey, callback)\n    }\n  }\n\n  return configStore\n\n  function _doSet (m, callback) {\n    const key = m.key\n    const value = m.value\n    if (key) {\n      waterfall(\n        [\n          (cb) => configStore.get(cb),\n          (config, cb) => {\n            _set(config, key, value)\n            cb(null, config)\n          },\n          _saveAll\n        ],\n        callback)\n    } else {\n      _saveAll(value, callback)\n    }\n  }\n\n  function _saveAll (config, callback) {\n    const buf = Buffer.from(JSON.stringify(config, null, 2))\n    store.put(configKey, buf, callback)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}