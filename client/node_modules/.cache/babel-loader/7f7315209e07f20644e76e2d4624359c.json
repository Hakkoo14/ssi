{"ast":null,"code":"'use strict';\n\nvar waterfall = require('async/waterfall');\n\nvar RepoErrors = require('ipfs-repo').errors; // Boot an IPFS node depending on the options set\n\n\nmodule.exports = function (self) {\n  self.log('booting');\n  var options = self._options;\n  var doInit = options.init;\n  var doStart = options.start; // Do the actual boot sequence\n\n  waterfall([// Checks if a repo exists, and if so opens it\n  // Will return callback with a bool indicating the existence\n  // of the repo\n  function (cb) {\n    // nothing to do\n    if (!self._repo.closed) {\n      return cb(null, true);\n    }\n\n    self._repo.open(function (err, res) {\n      if (isRepoUninitializedError(err)) return cb(null, false);\n      if (err) return cb(err);\n      cb(null, true);\n    });\n  }, function (repoOpened, cb) {\n    // Init with existing initialized, opened, repo\n    if (repoOpened) {\n      return self.init({\n        repo: self._repo\n      }, function (err) {\n        if (err) return cb(Object.assign(err, {\n          emitted: true\n        }));\n        cb();\n      });\n    }\n\n    if (doInit) {\n      var initOptions = Object.assign({\n        bits: 2048,\n        pass: self._options.pass\n      }, typeof options.init === 'object' ? options.init : {});\n      return self.init(initOptions, function (err) {\n        if (err) return cb(Object.assign(err, {\n          emitted: true\n        }));\n        cb();\n      });\n    }\n\n    cb();\n  }, function (cb) {\n    // No problem, we don't have to start the node\n    if (!doStart) {\n      return cb();\n    }\n\n    self.start(function (err) {\n      if (err) return cb(Object.assign(err, {\n        emitted: true\n      }));\n      cb();\n    });\n  }], function (err) {\n    if (err) {\n      if (!err.emitted) {\n        self.emit('error', err);\n      }\n\n      return;\n    }\n\n    self.log('booted');\n    self.emit('ready');\n  });\n};\n\nfunction isRepoUninitializedError(err) {\n  if (!err) {\n    return false;\n  } // If the error is that no repo exists,\n  // which happens when the version file is not found\n  // we just want to signal that no repo exist, not\n  // fail the whole process.\n  // Use standardized errors as much as possible\n\n\n  if (err.code === RepoErrors.ERR_REPO_NOT_INITIALIZED) {\n    return true;\n  } // TODO: As error codes continue to be standardized, this logic can be phase out;\n  // it is here to maintain compatibility\n\n\n  if (err.message.match(/not found/) || // indexeddb\n  err.message.match(/ENOENT/) || // fs\n  err.message.match(/No value/) // memory\n  ) {\n      return true;\n    }\n\n  return false;\n}","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs/src/core/boot.js"],"names":["waterfall","require","RepoErrors","errors","module","exports","self","log","options","_options","doInit","init","doStart","start","cb","_repo","closed","open","err","res","isRepoUninitializedError","repoOpened","repo","Object","assign","emitted","initOptions","bits","pass","emit","code","ERR_REPO_NOT_INITIALIZED","message","match"],"mappings":"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","sourcesContent":["'use strict'\n\nconst waterfall = require('async/waterfall')\nconst RepoErrors = require('ipfs-repo').errors\n\n// Boot an IPFS node depending on the options set\nmodule.exports = (self) => {\n  self.log('booting')\n  const options = self._options\n  const doInit = options.init\n  const doStart = options.start\n\n  // Do the actual boot sequence\n  waterfall([\n    // Checks if a repo exists, and if so opens it\n    // Will return callback with a bool indicating the existence\n    // of the repo\n    (cb) => {\n      // nothing to do\n      if (!self._repo.closed) {\n        return cb(null, true)\n      }\n\n      self._repo.open((err, res) => {\n        if (isRepoUninitializedError(err)) return cb(null, false)\n        if (err) return cb(err)\n        cb(null, true)\n      })\n    },\n    (repoOpened, cb) => {\n      // Init with existing initialized, opened, repo\n      if (repoOpened) {\n        return self.init({ repo: self._repo }, (err) => {\n          if (err) return cb(Object.assign(err, { emitted: true }))\n          cb()\n        })\n      }\n\n      if (doInit) {\n        const initOptions = Object.assign(\n          { bits: 2048, pass: self._options.pass },\n          typeof options.init === 'object' ? options.init : {}\n        )\n        return self.init(initOptions, (err) => {\n          if (err) return cb(Object.assign(err, { emitted: true }))\n          cb()\n        })\n      }\n\n      cb()\n    },\n    (cb) => {\n      // No problem, we don't have to start the node\n      if (!doStart) {\n        return cb()\n      }\n\n      self.start((err) => {\n        if (err) return cb(Object.assign(err, { emitted: true }))\n        cb()\n      })\n    }\n  ], (err) => {\n    if (err) {\n      if (!err.emitted) {\n        self.emit('error', err)\n      }\n      return\n    }\n    self.log('booted')\n    self.emit('ready')\n  })\n}\n\nfunction isRepoUninitializedError (err) {\n  if (!err) {\n    return false\n  }\n\n  // If the error is that no repo exists,\n  // which happens when the version file is not found\n  // we just want to signal that no repo exist, not\n  // fail the whole process.\n\n  // Use standardized errors as much as possible\n  if (err.code === RepoErrors.ERR_REPO_NOT_INITIALIZED) {\n    return true\n  }\n\n  // TODO: As error codes continue to be standardized, this logic can be phase out;\n  // it is here to maintain compatibility\n  if (err.message.match(/not found/) || // indexeddb\n    err.message.match(/ENOENT/) || // fs\n    err.message.match(/No value/) // memory\n  ) {\n    return true\n  }\n\n  return false\n}\n"]},"metadata":{},"sourceType":"script"}