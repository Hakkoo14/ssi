{"ast":null,"code":"var once = exports.once = function (value) {\n  return function (abort, cb) {\n    if (abort) return cb(abort);\n\n    if (value != null) {\n      var _value = value;\n      value = null;\n      cb(null, _value);\n    } else cb(true);\n  };\n};\n\nvar depthFirst = exports.depthFirst = function (start, createStream) {\n  var reads = [],\n      ended;\n  reads.unshift(once(start));\n  return function next(end, cb) {\n    if (!reads.length) return cb(true);\n    if (ended) return cb(ended);\n    reads[0](end, function (end, data) {\n      if (end) {\n        if (end !== true) {\n          ended = end;\n          reads.shift();\n\n          while (reads.length) {\n            reads.shift()(end, function () {});\n          }\n\n          return cb(end);\n        } //if this stream has ended, go to the next queue\n\n\n        reads.shift();\n        return next(null, cb);\n      }\n\n      reads.unshift(createStream(data));\n      cb(end, data);\n    });\n  };\n}; //width first is just like depth first,\n//but push each new stream onto the end of the queue\n\n\nvar widthFirst = exports.widthFirst = function (start, createStream) {\n  var reads = [];\n  reads.push(once(start));\n  return function next(end, cb) {\n    if (!reads.length) return cb(true);\n    reads[0](end, function (end, data) {\n      if (end) {\n        reads.shift();\n        return next(null, cb);\n      }\n\n      reads.push(createStream(data));\n      cb(end, data);\n    });\n  };\n}; //this came out different to the first (strm)\n//attempt at leafFirst, but it's still a valid\n//topological sort.\n\n\nvar leafFirst = exports.leafFirst = function (start, createStream) {\n  var reads = [];\n  var output = [];\n  reads.push(once(start));\n  return function next(end, cb) {\n    reads[0](end, function (end, data) {\n      if (end) {\n        reads.shift();\n        if (!output.length) return cb(true);\n        return cb(null, output.shift());\n      }\n\n      reads.unshift(createStream(data));\n      output.unshift(data);\n      next(null, cb);\n    });\n  };\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/pull-traverse/index.js"],"names":["once","exports","value","abort","cb","_value","depthFirst","start","createStream","reads","ended","unshift","next","end","length","data","shift","widthFirst","push","leafFirst","output"],"mappings":"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","sourcesContent":["\nvar once = exports.once =\nfunction (value) {\n  return function (abort, cb) {\n    if(abort) return cb(abort)\n    if(value != null) {\n      var _value = value; value = null\n      cb(null, _value)\n    } else\n      cb(true)\n  }\n}\n\nvar depthFirst = exports.depthFirst =\nfunction (start, createStream) {\n  var reads = [], ended\n\n  reads.unshift(once(start))\n\n  return function next (end, cb) {\n    if(!reads.length)\n      return cb(true)\n    if(ended)\n      return cb(ended)\n\n    reads[0](end, function (end, data) {\n      if(end) {\n        if(end !== true) {\n          ended = end\n          reads.shift()\n\n          while(reads.length)\n            reads.shift()(end, function () {})\n          \n          return cb(end)\n        }\n        //if this stream has ended, go to the next queue\n        reads.shift()\n        return next(null, cb)\n      }\n      reads.unshift(createStream(data))\n      cb(end, data)\n    })\n  }\n}\n//width first is just like depth first,\n//but push each new stream onto the end of the queue\nvar widthFirst = exports.widthFirst = \nfunction (start, createStream) {\n  var reads = []\n\n  reads.push(once(start))\n\n  return function next (end, cb) {\n    if(!reads.length)\n      return cb(true)\n    reads[0](end, function (end, data) {\n      if(end) {\n        reads.shift()\n        return next(null, cb)\n      }\n      reads.push(createStream(data))\n      cb(end, data)\n    })\n  }\n}\n\n//this came out different to the first (strm)\n//attempt at leafFirst, but it's still a valid\n//topological sort.\nvar leafFirst = exports.leafFirst = \nfunction (start, createStream) {\n  var reads = []\n  var output = []\n  reads.push(once(start))\n  \n  return function next (end, cb) {\n    reads[0](end, function (end, data) {\n      if(end) {\n        reads.shift()\n        if(!output.length)\n          return cb(true)\n        return cb(null, output.shift())\n      }\n      reads.unshift(createStream(data))\n      output.unshift(data)\n      next(null, cb)\n    })\n  }\n}\n\n"]},"metadata":{},"sourceType":"script"}