{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ipns = require('ipns');\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar each = require('async/each');\n\nvar waterfall = require('async/waterfall');\n\nvar log = debug('ipfs:ipns:republisher');\nlog.error = debug('ipfs:ipns:republisher:error');\nvar minute = 60 * 1000;\nvar hour = 60 * minute;\nvar defaultBroadcastInterval = 4 * hour;\nvar defaultRecordLifetime = 24 * hour;\n\nvar IpnsRepublisher = /*#__PURE__*/function () {\n  function IpnsRepublisher(publisher, datastore, peerInfo, keychain, options) {\n    _classCallCheck(this, IpnsRepublisher);\n\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerInfo = peerInfo;\n    this._keychain = keychain;\n    this._options = options;\n    this._republishHandle = null;\n  }\n\n  _createClass(IpnsRepublisher, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      if (this._republishHandle) {\n        var errMsg = 'already running';\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_REPUBLISH_ALREADY_RUNNING');\n      } // TODO: this handler should be isolated in another module\n\n\n      var republishHandle = {\n        _onCancel: null,\n        _timeoutId: null,\n        runPeriodically: function runPeriodically(fn, period) {\n          republishHandle._timeoutId = setTimeout(function () {\n            republishHandle._timeoutId = null;\n            fn(function (nextPeriod) {\n              // Was republish cancelled while fn was being called?\n              if (republishHandle._onCancel) {\n                return republishHandle._onCancel();\n              } // Schedule next\n\n\n              republishHandle.runPeriodically(fn, nextPeriod || period);\n            });\n          }, period);\n        },\n        cancel: function cancel(cb) {\n          // Not currently running a republish, can callback immediately\n          if (republishHandle._timeoutId) {\n            clearTimeout(republishHandle._timeoutId);\n            return cb();\n          } // Wait for republish to finish then call callback\n\n\n          republishHandle._onCancel = cb;\n        }\n      };\n      var privKey = this._peerInfo.id.privKey;\n      var pass = this._options.pass;\n      republishHandle.runPeriodically(function (done) {\n        _this._republishEntries(privKey, pass, function () {\n          return done(defaultBroadcastInterval);\n        });\n      }, minute);\n      this._republishHandle = republishHandle;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var republishHandle = this._republishHandle;\n\n      if (!republishHandle) {\n        var errMsg = 'not running';\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_REPUBLISH_NOT_RUNNING'));\n      }\n\n      this._republishHandle = null;\n      republishHandle.cancel(callback);\n    }\n  }, {\n    key: \"_republishEntries\",\n    value: function _republishEntries(privateKey, pass, callback) {\n      var _this2 = this;\n\n      // TODO: Should use list of published entries.\n      // We can't currently *do* that because go uses this method for now.\n      this._republishEntry(privateKey, function (err) {\n        if (err) {\n          var errMsg = 'cannot republish entry for the node\\'s private key';\n          log.error(errMsg);\n          return;\n        } // keychain needs pass to get the cryptographic keys\n\n\n        if (pass) {\n          _this2._keychain.listKeys(function (err, list) {\n            if (err) {\n              log.error(err);\n              return;\n            }\n\n            each(list, function (key, cb) {\n              waterfall([function (cb) {\n                return _this2._keychain.exportKey(key.name, pass, cb);\n              }, function (pem, cb) {\n                return crypto.keys.import(pem, pass, cb);\n              }], function (err, privKey) {\n                if (err) {\n                  log.error(err);\n                  return;\n                }\n\n                _this2._republishEntry(privKey, cb);\n              });\n            }, function (err) {\n              if (err) {\n                log.error(err);\n              }\n\n              callback(null);\n            });\n          });\n        } else {\n          callback(null);\n        }\n      });\n    }\n  }, {\n    key: \"_republishEntry\",\n    value: function _republishEntry(privateKey, callback) {\n      var _this3 = this;\n\n      if (!privateKey || !privateKey.bytes) {\n        var errMsg = \"one or more of the provided parameters are not defined\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'));\n      }\n\n      waterfall([function (cb) {\n        return PeerId.createFromPrivKey(privateKey.bytes, cb);\n      }, function (peerId, cb) {\n        return _this3._getPreviousValue(peerId, cb);\n      }], function (err, value) {\n        if (err) {\n          return callback(err.code === 'ERR_NO_ENTRY_FOUND' ? null : err);\n        }\n\n        _this3._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime, callback);\n      });\n    }\n  }, {\n    key: \"_getPreviousValue\",\n    value: function _getPreviousValue(peerId, callback) {\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      this._datastore.get(ipns.getLocalKey(peerId.id), function (err, dsVal) {\n        // error handling\n        // no need to republish\n        if (err && err.notFound) {\n          var _errMsg = \"no previous entry for record with id: \".concat(peerId.id);\n\n          log.error(_errMsg);\n          return callback(errcode(new Error(_errMsg), 'ERR_NO_ENTRY_FOUND'));\n        } else if (err) {\n          return callback(err);\n        }\n\n        if (!Buffer.isBuffer(dsVal)) {\n          var _errMsg2 = \"found ipns record that we couldn't process\";\n          log.error(_errMsg2);\n          return callback(errcode(new Error(_errMsg2), 'ERR_INVALID_IPNS_RECORD'));\n        } // unmarshal data\n\n\n        var record;\n\n        try {\n          record = ipns.unmarshal(dsVal);\n        } catch (err) {\n          var _errMsg3 = \"found ipns record that we couldn't convert to a value\";\n          log.error(_errMsg3);\n          return callback(errcode(new Error(_errMsg3), 'ERR_INVALID_IPNS_RECORD'));\n        }\n\n        callback(null, record.value);\n      });\n    }\n  }]);\n\n  return IpnsRepublisher;\n}();\n\nexports = module.exports = IpnsRepublisher;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs/src/core/ipns/republisher.js"],"names":["ipns","require","crypto","PeerId","errcode","debug","each","waterfall","log","error","minute","hour","defaultBroadcastInterval","defaultRecordLifetime","IpnsRepublisher","publisher","datastore","peerInfo","keychain","options","_publisher","_datastore","_peerInfo","_keychain","_options","_republishHandle","errMsg","Error","republishHandle","_onCancel","_timeoutId","runPeriodically","fn","period","setTimeout","nextPeriod","cancel","cb","clearTimeout","privKey","id","pass","done","_republishEntries","callback","privateKey","_republishEntry","err","listKeys","list","key","exportKey","name","pem","keys","import","bytes","createFromPrivKey","peerId","_getPreviousValue","value","code","publishWithEOL","isPeerId","get","getLocalKey","dsVal","notFound","Buffer","isBuffer","record","unmarshal","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\n\nconst debug = require('debug')\nconst each = require('async/each')\nconst waterfall = require('async/waterfall')\nconst log = debug('ipfs:ipns:republisher')\nlog.error = debug('ipfs:ipns:republisher:error')\n\nconst minute = 60 * 1000\nconst hour = 60 * minute\n\nconst defaultBroadcastInterval = 4 * hour\nconst defaultRecordLifetime = 24 * hour\n\nclass IpnsRepublisher {\n  constructor (publisher, datastore, peerInfo, keychain, options) {\n    this._publisher = publisher\n    this._datastore = datastore\n    this._peerInfo = peerInfo\n    this._keychain = keychain\n    this._options = options\n    this._republishHandle = null\n  }\n\n  start () {\n    if (this._republishHandle) {\n      const errMsg = 'already running'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_REPUBLISH_ALREADY_RUNNING')\n    }\n\n    // TODO: this handler should be isolated in another module\n    const republishHandle = {\n      _onCancel: null,\n      _timeoutId: null,\n      runPeriodically: (fn, period) => {\n        republishHandle._timeoutId = setTimeout(() => {\n          republishHandle._timeoutId = null\n\n          fn((nextPeriod) => {\n            // Was republish cancelled while fn was being called?\n            if (republishHandle._onCancel) {\n              return republishHandle._onCancel()\n            }\n            // Schedule next\n            republishHandle.runPeriodically(fn, nextPeriod || period)\n          })\n        }, period)\n      },\n      cancel: (cb) => {\n        // Not currently running a republish, can callback immediately\n        if (republishHandle._timeoutId) {\n          clearTimeout(republishHandle._timeoutId)\n          return cb()\n        }\n        // Wait for republish to finish then call callback\n        republishHandle._onCancel = cb\n      }\n    }\n\n    const { privKey } = this._peerInfo.id\n    const { pass } = this._options\n\n    republishHandle.runPeriodically((done) => {\n      this._republishEntries(privKey, pass, () => done(defaultBroadcastInterval))\n    }, minute)\n\n    this._republishHandle = republishHandle\n  }\n\n  stop (callback) {\n    const republishHandle = this._republishHandle\n\n    if (!republishHandle) {\n      const errMsg = 'not running'\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_REPUBLISH_NOT_RUNNING'))\n    }\n\n    this._republishHandle = null\n    republishHandle.cancel(callback)\n  }\n\n  _republishEntries (privateKey, pass, callback) {\n    // TODO: Should use list of published entries.\n    // We can't currently *do* that because go uses this method for now.\n    this._republishEntry(privateKey, (err) => {\n      if (err) {\n        const errMsg = 'cannot republish entry for the node\\'s private key'\n\n        log.error(errMsg)\n        return\n      }\n\n      // keychain needs pass to get the cryptographic keys\n      if (pass) {\n        this._keychain.listKeys((err, list) => {\n          if (err) {\n            log.error(err)\n            return\n          }\n\n          each(list, (key, cb) => {\n            waterfall([\n              (cb) => this._keychain.exportKey(key.name, pass, cb),\n              (pem, cb) => crypto.keys.import(pem, pass, cb)\n            ], (err, privKey) => {\n              if (err) {\n                log.error(err)\n                return\n              }\n\n              this._republishEntry(privKey, cb)\n            })\n          }, (err) => {\n            if (err) {\n              log.error(err)\n            }\n            callback(null)\n          })\n        })\n      } else {\n        callback(null)\n      }\n    })\n  }\n\n  _republishEntry (privateKey, callback) {\n    if (!privateKey || !privateKey.bytes) {\n      const errMsg = `one or more of the provided parameters are not defined`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'))\n    }\n\n    waterfall([\n      (cb) => PeerId.createFromPrivKey(privateKey.bytes, cb),\n      (peerId, cb) => this._getPreviousValue(peerId, cb)\n    ], (err, value) => {\n      if (err) {\n        return callback(err.code === 'ERR_NO_ENTRY_FOUND' ? null : err)\n      }\n\n      this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime, callback)\n    })\n  }\n\n  _getPreviousValue (peerId, callback) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = `peerId received is not valid`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'))\n    }\n\n    this._datastore.get(ipns.getLocalKey(peerId.id), (err, dsVal) => {\n      // error handling\n      // no need to republish\n      if (err && err.notFound) {\n        const errMsg = `no previous entry for record with id: ${peerId.id}`\n\n        log.error(errMsg)\n        return callback(errcode(new Error(errMsg), 'ERR_NO_ENTRY_FOUND'))\n      } else if (err) {\n        return callback(err)\n      }\n\n      if (!Buffer.isBuffer(dsVal)) {\n        const errMsg = `found ipns record that we couldn't process`\n\n        log.error(errMsg)\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_IPNS_RECORD'))\n      }\n\n      // unmarshal data\n      let record\n      try {\n        record = ipns.unmarshal(dsVal)\n      } catch (err) {\n        const errMsg = `found ipns record that we couldn't convert to a value`\n\n        log.error(errMsg)\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_IPNS_RECORD'))\n      }\n\n      callback(null, record.value)\n    })\n  }\n}\n\nexports = module.exports = IpnsRepublisher\n"]},"metadata":{},"sourceType":"script"}