{"ast":null,"code":"'use strict';\n\nvar peerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar multiaddr = require('multiaddr');\n\nvar waterfall = require('async/waterfall');\n\nvar Keychain = require('libp2p-keychain');\n\nvar mergeOptions = require('merge-options');\n\nvar NoKeychain = require('./no-keychain');\n/*\n * Load stuff from Repo into memory\n */\n\n\nmodule.exports = function preStart(self) {\n  return function (callback) {\n    self.log('pre-start');\n    var pass = self._options.pass;\n    waterfall([function (cb) {\n      return self._repo.config.get(cb);\n    }, function (config, cb) {\n      if (!self._options.config) {\n        return cb(null, config);\n      }\n\n      config = mergeOptions(config, self._options.config);\n      self.config.replace(config, function (err) {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(null, config);\n      });\n    }, function (config, cb) {\n      // Create keychain configuration, if needed.\n      if (config.Keychain) {\n        return cb(null, config);\n      }\n\n      config.Keychain = Keychain.generateOptions();\n      self.config.set('Keychain', config.Keychain, function (err) {\n        self.log('using default keychain options');\n        cb(err, config);\n      });\n    }, function (config, cb) {\n      // Construct the keychain\n      if (self._keychain) {// most likely an init or upgrade has happened\n      } else if (pass) {\n        var keychainOptions = Object.assign({\n          passPhrase: pass\n        }, config.Keychain);\n        self._keychain = new Keychain(self._repo.keys, keychainOptions);\n        self.log('keychain constructed');\n      } else {\n        self._keychain = new NoKeychain();\n        self.log('no keychain, use --pass');\n      }\n\n      cb(null, config);\n    }, function (config, cb) {\n      var privKey = config.Identity.PrivKey;\n      peerId.createFromPrivKey(privKey, function (err, id) {\n        cb(err, config, id);\n      });\n    }, function (config, id, cb) {\n      // Import the private key as 'self', if needed.\n      if (!pass) {\n        return cb(null, config, id);\n      }\n\n      self._keychain.findKeyByName('self', function (err) {\n        if (err) {\n          self.log('Creating \"self\" key');\n          return self._keychain.importPeer('self', id, function (err) {\n            return cb(err, config, id);\n          });\n        }\n\n        cb(null, config, id);\n      });\n    }, function (config, id, cb) {\n      self.log('peer created');\n      self._peerInfo = new PeerInfo(id);\n\n      if (config.Addresses && config.Addresses.Swarm) {\n        config.Addresses.Swarm.forEach(function (addr) {\n          var ma = multiaddr(addr);\n\n          if (ma.getPeerId()) {\n            ma = ma.encapsulate('/ipfs/' + self._peerInfo.id.toB58String());\n          }\n\n          self._peerInfo.multiaddrs.add(ma);\n        });\n      }\n\n      cb();\n    }, function (cb) {\n      return self.pin._load(cb);\n    }], callback);\n  };\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs/src/core/components/pre-start.js"],"names":["peerId","require","PeerInfo","multiaddr","waterfall","Keychain","mergeOptions","NoKeychain","module","exports","preStart","self","callback","log","pass","_options","cb","_repo","config","get","replace","err","generateOptions","set","_keychain","keychainOptions","Object","assign","passPhrase","keys","privKey","Identity","PrivKey","createFromPrivKey","id","findKeyByName","importPeer","_peerInfo","Addresses","Swarm","forEach","addr","ma","getPeerId","encapsulate","toB58String","multiaddrs","add","pin","_load"],"mappings":"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","sourcesContent":["'use strict'\n\nconst peerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst multiaddr = require('multiaddr')\nconst waterfall = require('async/waterfall')\nconst Keychain = require('libp2p-keychain')\nconst mergeOptions = require('merge-options')\nconst NoKeychain = require('./no-keychain')\n/*\n * Load stuff from Repo into memory\n */\nmodule.exports = function preStart (self) {\n  return (callback) => {\n    self.log('pre-start')\n\n    const pass = self._options.pass\n    waterfall([\n      (cb) => self._repo.config.get(cb),\n      (config, cb) => {\n        if (!self._options.config) {\n          return cb(null, config)\n        }\n\n        config = mergeOptions(config, self._options.config)\n\n        self.config.replace(config, (err) => {\n          if (err) {\n            return cb(err)\n          }\n\n          cb(null, config)\n        })\n      },\n      (config, cb) => {\n        // Create keychain configuration, if needed.\n        if (config.Keychain) {\n          return cb(null, config)\n        }\n        config.Keychain = Keychain.generateOptions()\n        self.config.set('Keychain', config.Keychain, (err) => {\n          self.log('using default keychain options')\n          cb(err, config)\n        })\n      },\n      (config, cb) => {\n        // Construct the keychain\n        if (self._keychain) {\n          // most likely an init or upgrade has happened\n        } else if (pass) {\n          const keychainOptions = Object.assign({ passPhrase: pass }, config.Keychain)\n          self._keychain = new Keychain(self._repo.keys, keychainOptions)\n          self.log('keychain constructed')\n        } else {\n          self._keychain = new NoKeychain()\n          self.log('no keychain, use --pass')\n        }\n        cb(null, config)\n      },\n      (config, cb) => {\n        const privKey = config.Identity.PrivKey\n\n        peerId.createFromPrivKey(privKey, (err, id) => {\n          cb(err, config, id)\n        })\n      },\n      (config, id, cb) => {\n        // Import the private key as 'self', if needed.\n        if (!pass) {\n          return cb(null, config, id)\n        }\n        self._keychain.findKeyByName('self', (err) => {\n          if (err) {\n            self.log('Creating \"self\" key')\n            return self._keychain.importPeer('self', id, (err) => cb(err, config, id))\n          }\n          cb(null, config, id)\n        })\n      },\n      (config, id, cb) => {\n        self.log('peer created')\n        self._peerInfo = new PeerInfo(id)\n\n        if (config.Addresses && config.Addresses.Swarm) {\n          config.Addresses.Swarm.forEach((addr) => {\n            let ma = multiaddr(addr)\n\n            if (ma.getPeerId()) {\n              ma = ma.encapsulate('/ipfs/' + self._peerInfo.id.toB58String())\n            }\n\n            self._peerInfo.multiaddrs.add(ma)\n          })\n        }\n\n        cb()\n      },\n      (cb) => self.pin._load(cb)\n    ], callback)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}