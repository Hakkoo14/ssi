{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar EventEmitter = require('events');\n\nvar Stat = require('./stat');\n\nvar OldPeers = require('./old-peers');\n\nvar defaultOptions = {\n  computeThrottleMaxQueueSize: 1000,\n  computeThrottleTimeout: 2000,\n  movingAverageIntervals: [60 * 1000, // 1 minute\n  5 * 60 * 1000, // 5 minutes\n  15 * 60 * 1000 // 15 minutes\n  ],\n  maxOldPeersRetention: 50\n};\nvar initialCounters = ['dataReceived', 'dataSent'];\nvar directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n};\n/**\n * Binds to message events on the given `observer` to generate stats\n * based on the Peer, Protocol and Transport used for the message. Stat\n * events will be emitted via the `update` event.\n *\n * @param {Observer} observer\n * @param {any} _options\n * @returns {Stats}\n */\n\nmodule.exports = function (observer, _options) {\n  var options = Object.assign({}, defaultOptions, _options);\n  var globalStats = new Stat(initialCounters, options);\n  var stats = Object.assign(new EventEmitter(), {\n    start: start,\n    stop: stop,\n    global: globalStats,\n    peers: function peers() {\n      return Array.from(peerStats.keys());\n    },\n    forPeer: function forPeer(peerId) {\n      return peerStats.get(peerId) || oldPeers.get(peerId);\n    },\n    transports: function transports() {\n      return Array.from(transportStats.keys());\n    },\n    forTransport: function forTransport(transport) {\n      return transportStats.get(transport);\n    },\n    protocols: function protocols() {\n      return Array.from(protocolStats.keys());\n    },\n    forProtocol: function forProtocol(protocol) {\n      return protocolStats.get(protocol);\n    }\n  });\n  globalStats.on('update', propagateChange);\n  var oldPeers = OldPeers(options.maxOldPeersRetention);\n  var peerStats = new Map();\n  var transportStats = new Map();\n  var protocolStats = new Map();\n  observer.on('peer:closed', function (peerId) {\n    var peer = peerStats.get(peerId);\n\n    if (peer) {\n      peer.removeListener('update', propagateChange);\n      peer.stop();\n      peerStats.delete(peerId);\n      oldPeers.set(peerId, peer);\n    }\n  });\n  return stats;\n\n  function onMessage(peerId, transportTag, protocolTag, direction, bufferLength) {\n    var event = directionToEvent[direction];\n\n    if (transportTag) {\n      // because it has a transport tag, this message is at the global level, so we account this\n      // traffic as global.\n      globalStats.push(event, bufferLength); // peer stats\n\n      var peer = peerStats.get(peerId);\n\n      if (!peer) {\n        peer = oldPeers.get(peerId);\n\n        if (peer) {\n          oldPeers.delete(peerId);\n        } else {\n          peer = new Stat(initialCounters, options);\n        }\n\n        peer.on('update', propagateChange);\n        peer.start();\n        peerStats.set(peerId, peer);\n      }\n\n      peer.push(event, bufferLength);\n    } // transport stats\n\n\n    if (transportTag) {\n      var transport = transportStats.get(transportTag);\n\n      if (!transport) {\n        transport = new Stat(initialCounters, options);\n        transport.on('update', propagateChange);\n        transportStats.set(transportTag, transport);\n      }\n\n      transport.push(event, bufferLength);\n    } // protocol stats\n\n\n    if (protocolTag) {\n      var protocol = protocolStats.get(protocolTag);\n\n      if (!protocol) {\n        protocol = new Stat(initialCounters, options);\n        protocol.on('update', propagateChange);\n        protocolStats.set(protocolTag, protocol);\n      }\n\n      protocol.push(event, bufferLength);\n    }\n  }\n\n  function start() {\n    observer.on('message', onMessage);\n    globalStats.start();\n\n    var _iterator = _createForOfIteratorHelper(peerStats.values()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var peerStat = _step.value;\n        peerStat.start();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper(transportStats.values()),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var transportStat = _step2.value;\n        transportStat.start();\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  function stop() {\n    observer.removeListener('message', onMessage);\n    globalStats.stop();\n\n    var _iterator3 = _createForOfIteratorHelper(peerStats.values()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var peerStat = _step3.value;\n        peerStat.stop();\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var _iterator4 = _createForOfIteratorHelper(transportStats.values()),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var transportStat = _step4.value;\n        transportStat.stop();\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  function propagateChange() {\n    stats.emit('update');\n  }\n};","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/libp2p-switch/src/stats/index.js"],"names":["EventEmitter","require","Stat","OldPeers","defaultOptions","computeThrottleMaxQueueSize","computeThrottleTimeout","movingAverageIntervals","maxOldPeersRetention","initialCounters","directionToEvent","in","out","module","exports","observer","_options","options","Object","assign","globalStats","stats","start","stop","global","peers","Array","from","peerStats","keys","forPeer","peerId","get","oldPeers","transports","transportStats","forTransport","transport","protocols","protocolStats","forProtocol","protocol","on","propagateChange","Map","peer","removeListener","delete","set","onMessage","transportTag","protocolTag","direction","bufferLength","event","push","values","peerStat","transportStat","emit"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\n\nconst Stat = require('./stat')\nconst OldPeers = require('./old-peers')\n\nconst defaultOptions = {\n  computeThrottleMaxQueueSize: 1000,\n  computeThrottleTimeout: 2000,\n  movingAverageIntervals: [\n    60 * 1000, // 1 minute\n    5 * 60 * 1000, // 5 minutes\n    15 * 60 * 1000 // 15 minutes\n  ],\n  maxOldPeersRetention: 50\n}\n\nconst initialCounters = [\n  'dataReceived',\n  'dataSent'\n]\n\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n}\n\n/**\n * Binds to message events on the given `observer` to generate stats\n * based on the Peer, Protocol and Transport used for the message. Stat\n * events will be emitted via the `update` event.\n *\n * @param {Observer} observer\n * @param {any} _options\n * @returns {Stats}\n */\nmodule.exports = (observer, _options) => {\n  const options = Object.assign({}, defaultOptions, _options)\n  const globalStats = new Stat(initialCounters, options)\n\n  const stats = Object.assign(new EventEmitter(), {\n    start: start,\n    stop: stop,\n    global: globalStats,\n    peers: () => Array.from(peerStats.keys()),\n    forPeer: (peerId) => {\n      return peerStats.get(peerId) || oldPeers.get(peerId)\n    },\n    transports: () => Array.from(transportStats.keys()),\n    forTransport: (transport) => transportStats.get(transport),\n    protocols: () => Array.from(protocolStats.keys()),\n    forProtocol: (protocol) => protocolStats.get(protocol)\n  })\n\n  globalStats.on('update', propagateChange)\n\n  const oldPeers = OldPeers(options.maxOldPeersRetention)\n  const peerStats = new Map()\n  const transportStats = new Map()\n  const protocolStats = new Map()\n\n  observer.on('peer:closed', (peerId) => {\n    const peer = peerStats.get(peerId)\n    if (peer) {\n      peer.removeListener('update', propagateChange)\n      peer.stop()\n      peerStats.delete(peerId)\n      oldPeers.set(peerId, peer)\n    }\n  })\n\n  return stats\n\n  function onMessage (peerId, transportTag, protocolTag, direction, bufferLength) {\n    const event = directionToEvent[direction]\n\n    if (transportTag) {\n      // because it has a transport tag, this message is at the global level, so we account this\n      // traffic as global.\n      globalStats.push(event, bufferLength)\n\n      // peer stats\n      let peer = peerStats.get(peerId)\n      if (!peer) {\n        peer = oldPeers.get(peerId)\n        if (peer) {\n          oldPeers.delete(peerId)\n        } else {\n          peer = new Stat(initialCounters, options)\n        }\n        peer.on('update', propagateChange)\n        peer.start()\n        peerStats.set(peerId, peer)\n      }\n      peer.push(event, bufferLength)\n    }\n\n    // transport stats\n    if (transportTag) {\n      let transport = transportStats.get(transportTag)\n      if (!transport) {\n        transport = new Stat(initialCounters, options)\n        transport.on('update', propagateChange)\n        transportStats.set(transportTag, transport)\n      }\n      transport.push(event, bufferLength)\n    }\n\n    // protocol stats\n    if (protocolTag) {\n      let protocol = protocolStats.get(protocolTag)\n      if (!protocol) {\n        protocol = new Stat(initialCounters, options)\n        protocol.on('update', propagateChange)\n        protocolStats.set(protocolTag, protocol)\n      }\n      protocol.push(event, bufferLength)\n    }\n  }\n\n  function start () {\n    observer.on('message', onMessage)\n\n    globalStats.start()\n\n    for (let peerStat of peerStats.values()) {\n      peerStat.start()\n    }\n    for (let transportStat of transportStats.values()) {\n      transportStat.start()\n    }\n  }\n\n  function stop () {\n    observer.removeListener('message', onMessage)\n    globalStats.stop()\n\n    for (let peerStat of peerStats.values()) {\n      peerStat.stop()\n    }\n    for (let transportStat of transportStats.values()) {\n      transportStat.stop()\n    }\n  }\n\n  function propagateChange () {\n    stats.emit('update')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}