{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:websocket-star');\n\nvar multiaddr = require('multiaddr');\n\nvar EE = require('events').EventEmitter;\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar Connection = require('interface-connection').Connection;\n\nvar setImmediate = require('async/setImmediate');\n\nvar utils = require('./utils');\n\nvar Listener = require('./listener');\n\nvar cleanUrlSIO = utils.cleanUrlSIO;\n\nvar mafmt = require('mafmt');\n\nvar withIs = require('class-is');\n\nvar WebsocketStar = /*#__PURE__*/function () {\n  /**\n    * WebsocketStar Transport\n    * @class\n    * @param {Object} options - Options for the listener\n    * @param {PeerId} options.id - Id for the crypto challenge\n    */\n  function WebsocketStar(options) {\n    _classCallCheck(this, WebsocketStar);\n\n    options = options || {};\n    this.id = options.id;\n    this.flag = options.allowJoinWithDisabledChallenge; // let's just refer to it as \"flag\"\n\n    this.discovery = new EE();\n    this.discovery.tag = 'websocketStar';\n\n    this.discovery.start = function (callback) {\n      setImmediate(callback);\n    };\n\n    this.discovery.stop = function (callback) {\n      setImmediate(callback);\n    };\n\n    this.listeners_list = {};\n    this._peerDiscovered = this._peerDiscovered.bind(this);\n  }\n  /**\n    * Sets the id after transport creation (aka the lazy way)\n    * @param {PeerId} id\n    * @returns {undefined}\n    */\n\n\n  _createClass(WebsocketStar, [{\n    key: \"lazySetId\",\n    value: function lazySetId(id) {\n      if (!id) return;\n      this.id = id;\n      this.canCrypto = true;\n    }\n    /**\n      * Dials a peer\n      * @param {Multiaddr} ma - Multiaddr to dial to\n      * @param {Object} options\n      * @param {function} callback\n      * @returns {Connection}\n      */\n\n  }, {\n    key: \"dial\",\n    value: function dial(ma, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      var url;\n\n      try {\n        url = cleanUrlSIO(ma);\n      } catch (err) {\n        return callback(err); // early\n      }\n\n      var listener = this.listeners_list[url];\n\n      if (!listener) {\n        callback(new Error('No listener for this server'));\n        return new Connection();\n      }\n\n      return listener.dial(ma, options, callback);\n    }\n    /**\n      * Creates a listener\n      * @param {Object} options\n      * @param {function} handler\n      * @returns {Listener}\n      */\n\n  }, {\n    key: \"createListener\",\n    value: function createListener(options, handler) {\n      if (typeof options === 'function') {\n        handler = options;\n        options = {};\n      }\n\n      var listener = new Listener({\n        id: this.id,\n        handler: handler,\n        listeners: this.listeners_list,\n        flag: this.flag\n      });\n      listener.on('peer', this._peerDiscovered);\n      return listener;\n    }\n    /**\n      * Filters multiaddrs\n      * @param {Multiaddr[]} multiaddrs\n      * @returns {boolean}\n      */\n\n  }, {\n    key: \"filter\",\n    value: function filter(multiaddrs) {\n      if (!Array.isArray(multiaddrs)) {\n        multiaddrs = [multiaddrs];\n      }\n\n      return multiaddrs.filter(function (ma) {\n        return mafmt.WebSocketStar.matches(ma);\n      });\n    }\n    /**\n      * Used to fire peer events on the discovery part\n      * @param {Multiaddr} maStr\n      * @fires Discovery#peer\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_peerDiscovered\",\n    value: function _peerDiscovered(maStr) {\n      log('Peer Discovered:', maStr);\n      var peerIdStr = maStr.split('/ipfs/').pop();\n      var peerId = PeerId.createFromB58String(peerIdStr);\n      var peerInfo = new PeerInfo(peerId);\n      peerInfo.multiaddrs.add(multiaddr(maStr));\n      this.discovery.emit('peer', peerInfo);\n    }\n  }]);\n\n  return WebsocketStar;\n}();\n\nmodule.exports = withIs(WebsocketStar, {\n  className: 'WebsocketStar',\n  symbolName: '@libp2p/js-libp2p-websocket-star/websocketstar'\n});","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/libp2p-websocket-star/src/index.js"],"names":["debug","require","log","multiaddr","EE","EventEmitter","PeerId","PeerInfo","Connection","setImmediate","utils","Listener","cleanUrlSIO","mafmt","withIs","WebsocketStar","options","id","flag","allowJoinWithDisabledChallenge","discovery","tag","start","callback","stop","listeners_list","_peerDiscovered","bind","canCrypto","ma","url","err","listener","Error","dial","handler","listeners","on","multiaddrs","Array","isArray","filter","WebSocketStar","matches","maStr","peerIdStr","split","pop","peerId","createFromB58String","peerInfo","add","emit","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:websocket-star')\nconst multiaddr = require('multiaddr')\nconst EE = require('events').EventEmitter\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst Connection = require('interface-connection').Connection\nconst setImmediate = require('async/setImmediate')\nconst utils = require('./utils')\nconst Listener = require('./listener')\nconst cleanUrlSIO = utils.cleanUrlSIO\nconst mafmt = require('mafmt')\nconst withIs = require('class-is')\n\nclass WebsocketStar {\n  /**\n    * WebsocketStar Transport\n    * @class\n    * @param {Object} options - Options for the listener\n    * @param {PeerId} options.id - Id for the crypto challenge\n    */\n  constructor (options) {\n    options = options || {}\n\n    this.id = options.id\n    this.flag = options.allowJoinWithDisabledChallenge // let's just refer to it as \"flag\"\n\n    this.discovery = new EE()\n    this.discovery.tag = 'websocketStar'\n    this.discovery.start = (callback) => {\n      setImmediate(callback)\n    }\n    this.discovery.stop = (callback) => {\n      setImmediate(callback)\n    }\n\n    this.listeners_list = {}\n    this._peerDiscovered = this._peerDiscovered.bind(this)\n  }\n\n  /**\n    * Sets the id after transport creation (aka the lazy way)\n    * @param {PeerId} id\n    * @returns {undefined}\n    */\n  lazySetId (id) {\n    if (!id) return\n    this.id = id\n    this.canCrypto = true\n  }\n\n  /**\n    * Dials a peer\n    * @param {Multiaddr} ma - Multiaddr to dial to\n    * @param {Object} options\n    * @param {function} callback\n    * @returns {Connection}\n    */\n  dial (ma, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    let url\n    try {\n      url = cleanUrlSIO(ma)\n    } catch (err) {\n      return callback(err) // early\n    }\n    const listener = this.listeners_list[url]\n    if (!listener) {\n      callback(new Error('No listener for this server'))\n      return new Connection()\n    }\n    return listener.dial(ma, options, callback)\n  }\n\n  /**\n    * Creates a listener\n    * @param {Object} options\n    * @param {function} handler\n    * @returns {Listener}\n    */\n  createListener (options, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    const listener = new Listener({\n      id: this.id,\n      handler,\n      listeners: this.listeners_list,\n      flag: this.flag\n    })\n\n    listener.on('peer', this._peerDiscovered)\n\n    return listener\n  }\n\n  /**\n    * Filters multiaddrs\n    * @param {Multiaddr[]} multiaddrs\n    * @returns {boolean}\n    */\n  filter (multiaddrs) {\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs]\n    }\n\n    return multiaddrs.filter((ma) => mafmt.WebSocketStar.matches(ma))\n  }\n\n  /**\n    * Used to fire peer events on the discovery part\n    * @param {Multiaddr} maStr\n    * @fires Discovery#peer\n    * @returns {undefined}\n    * @private\n    */\n  _peerDiscovered (maStr) {\n    log('Peer Discovered:', maStr)\n    const peerIdStr = maStr.split('/ipfs/').pop()\n    const peerId = PeerId.createFromB58String(peerIdStr)\n    const peerInfo = new PeerInfo(peerId)\n\n    peerInfo.multiaddrs.add(multiaddr(maStr))\n    this.discovery.emit('peer', peerInfo)\n  }\n}\n\nmodule.exports = withIs(WebsocketStar, { className: 'WebsocketStar', symbolName: '@libp2p/js-libp2p-websocket-star/websocketstar' })\n"]},"metadata":{},"sourceType":"script"}