{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _asyncIterator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _awaitAsyncGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar log = require('debug')('ipfs:mfs:write');\n\nvar importer = require('ipfs-unixfs-importer');\n\nvar stat = require('./stat');\n\nvar mkdir = require('./mkdir');\n\nvar addLink = require('./utils/add-link');\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar createLock = require('./utils/create-lock');\n\nvar toAsyncIterator = require('./utils/to-async-iterator');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar toPathComponents = require('./utils/to-path-components');\n\nvar toTrail = require('./utils/to-trail');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar errCode = require('err-code');\n\nvar _require = require('./utils/constants'),\n    MAX_CHUNK_SIZE = _require.MAX_CHUNK_SIZE;\n\nvar last = require('async-iterator-last');\n\nvar defaultOptions = {\n  offset: 0,\n  // the offset in the file to begin writing\n  length: undefined,\n  // how many bytes from the incoming buffer to write\n  create: false,\n  // whether to create the file if it does not exist\n  truncate: false,\n  // whether to truncate the file first\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  format: 'dag-pb',\n  parents: false,\n  // whether to create intermediate directories if they do not exist\n  progress: function progress() {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000\n};\n\nmodule.exports = function (context) {\n  return /*#__PURE__*/function () {\n    var _mfsWrite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path, content, options) {\n      var source, destination, parent;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              log('Hello world, writing', path, content, options);\n              options = applyDefaultOptions(options, defaultOptions);\n              log('Reading source, destination and parent');\n              _context2.next = 5;\n              return createLock().readLock( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return toAsyncIterator(content, options);\n\n                      case 2:\n                        source = _context.sent;\n                        _context.next = 5;\n                        return toMfsPath(context, path);\n\n                      case 5:\n                        destination = _context.sent;\n                        _context.next = 8;\n                        return toMfsPath(context, destination.mfsDirectory);\n\n                      case 8:\n                        parent = _context.sent;\n\n                      case 9:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              })))();\n\n            case 5:\n              log('Read source, destination and parent');\n\n              if (!(!options.parents && !parent.exists)) {\n                _context2.next = 8;\n                break;\n              }\n\n              throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST');\n\n            case 8:\n              if (!(!options.create && !destination.exists)) {\n                _context2.next = 10;\n                break;\n              }\n\n              throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST');\n\n            case 10:\n              return _context2.abrupt(\"return\", updateOrImport(context, path, source, destination, options));\n\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function mfsWrite(_x4, _x5, _x6) {\n      return _mfsWrite.apply(this, arguments);\n    }\n\n    return mfsWrite;\n  }();\n};\n\nvar updateOrImport = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(context, path, source, destination, options) {\n    var child;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return write(context, source, destination, options);\n\n          case 2:\n            child = _context4.sent;\n            _context4.next = 5;\n            return createLock().writeLock( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n              var pathComponents, fileName, parentExists, updatedPath, trail, parent, parentNode, result, newRootCid;\n              return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      pathComponents = toPathComponents(path);\n                      fileName = pathComponents.pop();\n                      parentExists = false;\n                      _context3.prev = 3;\n                      _context3.next = 6;\n                      return stat(context)(\"/\".concat(pathComponents.join('/')), options);\n\n                    case 6:\n                      parentExists = true;\n                      _context3.next = 13;\n                      break;\n\n                    case 9:\n                      _context3.prev = 9;\n                      _context3.t0 = _context3[\"catch\"](3);\n\n                      if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                        _context3.next = 13;\n                        break;\n                      }\n\n                      throw _context3.t0;\n\n                    case 13:\n                      if (parentExists) {\n                        _context3.next = 16;\n                        break;\n                      }\n\n                      _context3.next = 16;\n                      return mkdir(context)(\"/\".concat(pathComponents.join('/')), options);\n\n                    case 16:\n                      _context3.next = 18;\n                      return toMfsPath(context, path);\n\n                    case 18:\n                      updatedPath = _context3.sent;\n                      _context3.next = 21;\n                      return toTrail(context, updatedPath.mfsDirectory, options);\n\n                    case 21:\n                      trail = _context3.sent;\n                      parent = trail[trail.length - 1];\n\n                      if (parent.type.includes('directory')) {\n                        _context3.next = 25;\n                        break;\n                      }\n\n                      throw errCode(new Error(\"cannot write to \".concat(parent.name, \": Not a directory\")), 'ERR_NOT_A_DIRECTORY');\n\n                    case 25:\n                      _context3.next = 27;\n                      return context.ipld.get(parent.cid);\n\n                    case 27:\n                      parentNode = _context3.sent;\n                      _context3.next = 30;\n                      return addLink(context, {\n                        parent: parentNode,\n                        name: fileName,\n                        cid: child.cid,\n                        size: child.size,\n                        flush: options.flush,\n                        shardSplitThreshold: options.shardSplitThreshold,\n                        format: options.format,\n                        hashAlg: options.hashAlg,\n                        cidVersion: options.cidVersion\n                      });\n\n                    case 30:\n                      result = _context3.sent;\n                      parent.cid = result.cid; // update the tree with the new child\n\n                      _context3.next = 34;\n                      return updateTree(context, trail, options);\n\n                    case 34:\n                      newRootCid = _context3.sent;\n                      _context3.next = 37;\n                      return updateMfsRoot(context, newRootCid);\n\n                    case 37:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3, null, [[3, 9]]);\n            })))();\n\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function updateOrImport(_x7, _x8, _x9, _x10, _x11) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar write = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(context, source, destination, options) {\n    var sources, content, result;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (destination.exists) {\n              log(\"Overwriting file \".concat(destination.cid, \" offset \").concat(options.offset, \" length \").concat(options.length));\n            } else {\n              log(\"Writing file offset \".concat(options.offset, \" length \").concat(options.length));\n            }\n\n            sources = []; // pad start of file if necessary\n\n            if (options.offset > 0) {\n              if (destination.unixfs && destination.unixfs.fileSize() > options.offset) {\n                log(\"Writing first \".concat(options.offset, \" bytes of original file\"));\n                sources.push(function () {\n                  return destination.content({\n                    offset: 0,\n                    length: options.offset\n                  });\n                });\n              } else {\n                log(\"Writing zeros for first \".concat(options.offset, \" bytes\"));\n                sources.push(asyncZeroes(options.offset));\n              }\n            }\n\n            sources.push(limitAsyncStreamBytes(source, options.length));\n            content = countBytesStreamed(catAsyncInterators(sources), function (bytesWritten) {\n              if (destination.unixfs && !options.truncate) {\n                // if we've done reading from the new source and we are not going\n                // to truncate the file, add the end of the existing file to the output\n                var fileSize = destination.unixfs.fileSize();\n\n                if (fileSize > bytesWritten) {\n                  log(\"Writing last \".concat(fileSize - bytesWritten, \" of \").concat(fileSize, \" bytes from original file starting at offset \").concat(bytesWritten));\n                  return destination.content({\n                    offset: bytesWritten\n                  });\n                } else {\n                  log(\"Not writing last bytes from original file\");\n                }\n              }\n\n              return _defineProperty({}, Symbol.asyncIterator, _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5);\n              })));\n            });\n            _context6.next = 7;\n            return last(importer([{\n              content: content\n            }], context.ipld, {\n              progress: options.progress,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              strategy: options.strategy,\n              rawLeaves: options.rawLeaves,\n              reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n              leafType: options.leafType\n            }));\n\n          case 7:\n            result = _context6.sent;\n            log(\"Wrote \".concat(result.cid));\n            return _context6.abrupt(\"return\", {\n              cid: result.cid,\n              size: result.size\n            });\n\n          case 10:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function write(_x12, _x13, _x14, _x15) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar limitAsyncStreamBytes = function limitAsyncStreamBytes(stream, limit) {\n  return /*#__PURE__*/function () {\n    var _limitAsyncStreamBytes2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n      var emitted, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, buf;\n\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              emitted = 0;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context7.prev = 3;\n              _iterator = _asyncIterator(stream);\n\n            case 5:\n              _context7.next = 7;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 7:\n              _step = _context7.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context7.next = 11;\n              return _awaitAsyncGenerator(_step.value);\n\n            case 11:\n              _value = _context7.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context7.next = 24;\n                break;\n              }\n\n              buf = _value;\n              emitted += buf.length;\n\n              if (!(emitted > limit)) {\n                _context7.next = 19;\n                break;\n              }\n\n              _context7.next = 18;\n              return buf.slice(0, limit - emitted);\n\n            case 18:\n              return _context7.abrupt(\"return\");\n\n            case 19:\n              _context7.next = 21;\n              return buf;\n\n            case 21:\n              _iteratorNormalCompletion = true;\n              _context7.next = 5;\n              break;\n\n            case 24:\n              _context7.next = 30;\n              break;\n\n            case 26:\n              _context7.prev = 26;\n              _context7.t0 = _context7[\"catch\"](3);\n              _didIteratorError = true;\n              _iteratorError = _context7.t0;\n\n            case 30:\n              _context7.prev = 30;\n              _context7.prev = 31;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context7.next = 35;\n                break;\n              }\n\n              _context7.next = 35;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 35:\n              _context7.prev = 35;\n\n              if (!_didIteratorError) {\n                _context7.next = 38;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 38:\n              return _context7.finish(35);\n\n            case 39:\n              return _context7.finish(30);\n\n            case 40:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, null, [[3, 26, 30, 40], [31,, 35, 39]]);\n    }));\n\n    function _limitAsyncStreamBytes() {\n      return _limitAsyncStreamBytes2.apply(this, arguments);\n    }\n\n    return _limitAsyncStreamBytes;\n  }();\n};\n\nvar asyncZeroes = function asyncZeroes(count) {\n  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_CHUNK_SIZE;\n  var buf = Buffer.alloc(chunkSize, 0);\n\n  var stream = _defineProperty({}, Symbol.asyncIterator, function () {\n    var _asyncZeroes2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!true) {\n                _context8.next = 5;\n                break;\n              }\n\n              _context8.next = 3;\n              return buf.slice();\n\n            case 3:\n              _context8.next = 0;\n              break;\n\n            case 5:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n\n    function _asyncZeroes() {\n      return _asyncZeroes2.apply(this, arguments);\n    }\n\n    return _asyncZeroes;\n  }());\n\n  return limitAsyncStreamBytes(stream, count);\n};\n\nvar catAsyncInterators = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(sources) {\n    var i, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, buf;\n\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < sources.length)) {\n              _context9.next = 39;\n              break;\n            }\n\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context9.prev = 4;\n            _iterator2 = _asyncIterator(sources[i]());\n\n          case 6:\n            _context9.next = 8;\n            return _awaitAsyncGenerator(_iterator2.next());\n\n          case 8:\n            _step2 = _context9.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context9.next = 12;\n            return _awaitAsyncGenerator(_step2.value);\n\n          case 12:\n            _value2 = _context9.sent;\n\n            if (_iteratorNormalCompletion2) {\n              _context9.next = 20;\n              break;\n            }\n\n            buf = _value2;\n            _context9.next = 17;\n            return buf;\n\n          case 17:\n            _iteratorNormalCompletion2 = true;\n            _context9.next = 6;\n            break;\n\n          case 20:\n            _context9.next = 26;\n            break;\n\n          case 22:\n            _context9.prev = 22;\n            _context9.t0 = _context9[\"catch\"](4);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context9.t0;\n\n          case 26:\n            _context9.prev = 26;\n            _context9.prev = 27;\n\n            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n              _context9.next = 31;\n              break;\n            }\n\n            _context9.next = 31;\n            return _awaitAsyncGenerator(_iterator2.return());\n\n          case 31:\n            _context9.prev = 31;\n\n            if (!_didIteratorError2) {\n              _context9.next = 34;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 34:\n            return _context9.finish(31);\n\n          case 35:\n            return _context9.finish(26);\n\n          case 36:\n            i++;\n            _context9.next = 1;\n            break;\n\n          case 39:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[4, 22, 26, 36], [27,, 31, 35]]);\n  }));\n\n  return function catAsyncInterators(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar countBytesStreamed = /*#__PURE__*/function () {\n  var _ref3 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(source, notify) {\n    var wrote, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, buf, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _value4, _buf;\n\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            wrote = 0;\n            _iteratorNormalCompletion3 = true;\n            _didIteratorError3 = false;\n            _context10.prev = 3;\n            _iterator3 = _asyncIterator(source);\n\n          case 5:\n            _context10.next = 7;\n            return _awaitAsyncGenerator(_iterator3.next());\n\n          case 7:\n            _step3 = _context10.sent;\n            _iteratorNormalCompletion3 = _step3.done;\n            _context10.next = 11;\n            return _awaitAsyncGenerator(_step3.value);\n\n          case 11:\n            _value3 = _context10.sent;\n\n            if (_iteratorNormalCompletion3) {\n              _context10.next = 20;\n              break;\n            }\n\n            buf = _value3;\n            wrote += buf.length;\n            _context10.next = 17;\n            return buf;\n\n          case 17:\n            _iteratorNormalCompletion3 = true;\n            _context10.next = 5;\n            break;\n\n          case 20:\n            _context10.next = 26;\n            break;\n\n          case 22:\n            _context10.prev = 22;\n            _context10.t0 = _context10[\"catch\"](3);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context10.t0;\n\n          case 26:\n            _context10.prev = 26;\n            _context10.prev = 27;\n\n            if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {\n              _context10.next = 31;\n              break;\n            }\n\n            _context10.next = 31;\n            return _awaitAsyncGenerator(_iterator3.return());\n\n          case 31:\n            _context10.prev = 31;\n\n            if (!_didIteratorError3) {\n              _context10.next = 34;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 34:\n            return _context10.finish(31);\n\n          case 35:\n            return _context10.finish(26);\n\n          case 36:\n            _iteratorNormalCompletion4 = true;\n            _didIteratorError4 = false;\n            _context10.prev = 38;\n            _iterator4 = _asyncIterator(notify(wrote));\n\n          case 40:\n            _context10.next = 42;\n            return _awaitAsyncGenerator(_iterator4.next());\n\n          case 42:\n            _step4 = _context10.sent;\n            _iteratorNormalCompletion4 = _step4.done;\n            _context10.next = 46;\n            return _awaitAsyncGenerator(_step4.value);\n\n          case 46:\n            _value4 = _context10.sent;\n\n            if (_iteratorNormalCompletion4) {\n              _context10.next = 55;\n              break;\n            }\n\n            _buf = _value4;\n            wrote += _buf.length;\n            _context10.next = 52;\n            return _buf;\n\n          case 52:\n            _iteratorNormalCompletion4 = true;\n            _context10.next = 40;\n            break;\n\n          case 55:\n            _context10.next = 61;\n            break;\n\n          case 57:\n            _context10.prev = 57;\n            _context10.t1 = _context10[\"catch\"](38);\n            _didIteratorError4 = true;\n            _iteratorError4 = _context10.t1;\n\n          case 61:\n            _context10.prev = 61;\n            _context10.prev = 62;\n\n            if (!(!_iteratorNormalCompletion4 && _iterator4.return != null)) {\n              _context10.next = 66;\n              break;\n            }\n\n            _context10.next = 66;\n            return _awaitAsyncGenerator(_iterator4.return());\n\n          case 66:\n            _context10.prev = 66;\n\n            if (!_didIteratorError4) {\n              _context10.next = 69;\n              break;\n            }\n\n            throw _iteratorError4;\n\n          case 69:\n            return _context10.finish(66);\n\n          case 70:\n            return _context10.finish(61);\n\n          case 71:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[3, 22, 26, 36], [27,, 31, 35], [38, 57, 61, 71], [62,, 66, 70]]);\n  }));\n\n  return function countBytesStreamed(_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs-mfs/src/core/write.js"],"names":["log","require","importer","stat","mkdir","addLink","applyDefaultOptions","createLock","toAsyncIterator","toMfsPath","toPathComponents","toTrail","updateTree","updateMfsRoot","errCode","MAX_CHUNK_SIZE","last","defaultOptions","offset","length","undefined","create","truncate","rawLeaves","reduceSingleLeafToSelf","cidVersion","hashAlg","format","parents","progress","strategy","flush","leafType","shardSplitThreshold","module","exports","context","path","content","options","readLock","source","destination","mfsDirectory","parent","exists","Error","updateOrImport","mfsWrite","write","child","writeLock","pathComponents","fileName","pop","parentExists","join","code","updatedPath","trail","type","includes","name","ipld","get","cid","parentNode","size","result","newRootCid","sources","unixfs","fileSize","push","asyncZeroes","limitAsyncStreamBytes","countBytesStreamed","catAsyncInterators","bytesWritten","Symbol","asyncIterator","stream","limit","emitted","buf","slice","_limitAsyncStreamBytes","count","chunkSize","Buffer","alloc","_asyncZeroes","i","notify","wrote"],"mappings":"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","sourcesContent":["'use strict'\n\nconst log = require('debug')('ipfs:mfs:write')\nconst importer = require('ipfs-unixfs-importer')\nconst stat = require('./stat')\nconst mkdir = require('./mkdir')\nconst addLink = require('./utils/add-link')\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst createLock = require('./utils/create-lock')\nconst toAsyncIterator = require('./utils/to-async-iterator')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst toPathComponents = require('./utils/to-path-components')\nconst toTrail = require('./utils/to-trail')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst errCode = require('err-code')\nconst {\n  MAX_CHUNK_SIZE\n} = require('./utils/constants')\nconst last = require('async-iterator-last')\n\nconst defaultOptions = {\n  offset: 0, // the offset in the file to begin writing\n  length: undefined, // how many bytes from the incoming buffer to write\n  create: false, // whether to create the file if it does not exist\n  truncate: false, // whether to truncate the file first\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  format: 'dag-pb',\n  parents: false, // whether to create intermediate directories if they do not exist\n  progress: () => {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000\n}\n\nmodule.exports = (context) => {\n  return async function mfsWrite (path, content, options) {\n    log('Hello world, writing', path, content, options)\n    options = applyDefaultOptions(options, defaultOptions)\n\n    let source, destination, parent\n    log('Reading source, destination and parent')\n    await createLock().readLock(async () => {\n      source = await toAsyncIterator(content, options)\n      destination = await toMfsPath(context, path)\n      parent = await toMfsPath(context, destination.mfsDirectory)\n    })()\n    log('Read source, destination and parent')\n    if (!options.parents && !parent.exists) {\n      throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST')\n    }\n\n    if (!options.create && !destination.exists) {\n      throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST')\n    }\n\n    return updateOrImport(context, path, source, destination, options)\n  }\n}\n\nconst updateOrImport = async (context, path, source, destination, options) => {\n  const child = await write(context, source, destination, options)\n\n  // The slow bit is done, now add or replace the DAGLink in the containing directory\n  // re-reading the path to the containing folder in case it has changed in the interim\n  await createLock().writeLock(async () => {\n    const pathComponents = toPathComponents(path)\n    const fileName = pathComponents.pop()\n    let parentExists = false\n\n    try {\n      await stat(context)(`/${pathComponents.join('/')}`, options)\n      parentExists = true\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err\n      }\n    }\n\n    if (!parentExists) {\n      await mkdir(context)(`/${pathComponents.join('/')}`, options)\n    }\n\n    // get an updated mfs path in case the root changed while we were writing\n    const updatedPath = await toMfsPath(context, path)\n    const trail = await toTrail(context, updatedPath.mfsDirectory, options)\n    const parent = trail[trail.length - 1]\n\n    if (!parent.type.includes('directory')) {\n      throw errCode(new Error(`cannot write to ${parent.name}: Not a directory`), 'ERR_NOT_A_DIRECTORY')\n    }\n\n    const parentNode = await context.ipld.get(parent.cid)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: fileName,\n      cid: child.cid,\n      size: child.size,\n      flush: options.flush,\n      shardSplitThreshold: options.shardSplitThreshold,\n      format: options.format,\n      hashAlg: options.hashAlg,\n      cidVersion: options.cidVersion\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, options)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid)\n  })()\n}\n\nconst write = async (context, source, destination, options) => {\n  if (destination.exists) {\n    log(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`)\n  } else {\n    log(`Writing file offset ${options.offset} length ${options.length}`)\n  }\n\n  const sources = []\n\n  // pad start of file if necessary\n  if (options.offset > 0) {\n    if (destination.unixfs && destination.unixfs.fileSize() > options.offset) {\n      log(`Writing first ${options.offset} bytes of original file`)\n\n      sources.push(\n        () => {\n          return destination.content({\n            offset: 0,\n            length: options.offset\n          })\n        }\n      )\n    } else {\n      log(`Writing zeros for first ${options.offset} bytes`)\n      sources.push(\n        asyncZeroes(options.offset)\n      )\n    }\n  }\n\n  sources.push(\n    limitAsyncStreamBytes(source, options.length)\n  )\n\n  const content = countBytesStreamed(catAsyncInterators(sources), (bytesWritten) => {\n    if (destination.unixfs && !options.truncate) {\n      // if we've done reading from the new source and we are not going\n      // to truncate the file, add the end of the existing file to the output\n      const fileSize = destination.unixfs.fileSize()\n\n      if (fileSize > bytesWritten) {\n        log(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`)\n\n        return destination.content({\n          offset: bytesWritten\n        })\n      } else {\n        log(`Not writing last bytes from original file`)\n      }\n    }\n\n    return {\n      [Symbol.asyncIterator]: async function * () {}\n    }\n  })\n\n  let result = await last(importer([{\n    content: content\n  }], context.ipld, {\n    progress: options.progress,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    strategy: options.strategy,\n    rawLeaves: options.rawLeaves,\n    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n    leafType: options.leafType\n  }))\n\n  log(`Wrote ${result.cid}`)\n\n  return {\n    cid: result.cid,\n    size: result.size\n  }\n}\n\nconst limitAsyncStreamBytes = (stream, limit) => {\n  return async function * _limitAsyncStreamBytes () {\n    let emitted = 0\n\n    for await (const buf of stream) {\n      emitted += buf.length\n\n      if (emitted > limit) {\n        yield buf.slice(0, limit - emitted)\n\n        return\n      }\n\n      yield buf\n    }\n  }\n}\n\nconst asyncZeroes = (count, chunkSize = MAX_CHUNK_SIZE) => {\n  const buf = Buffer.alloc(chunkSize, 0)\n\n  const stream = {\n    [Symbol.asyncIterator]: async function * _asyncZeroes () {\n      while (true) {\n        yield buf.slice()\n      }\n    }\n  }\n\n  return limitAsyncStreamBytes(stream, count)\n}\n\nconst catAsyncInterators = async function * (sources) {\n  for (let i = 0; i < sources.length; i++) {\n    for await (const buf of sources[i]()) {\n      yield buf\n    }\n  }\n}\n\nconst countBytesStreamed = async function * (source, notify) {\n  let wrote = 0\n\n  for await (const buf of source) {\n    wrote += buf.length\n\n    yield buf\n  }\n\n  for await (const buf of notify(wrote)) {\n    wrote += buf.length\n\n    yield buf\n  }\n}\n"]},"metadata":{},"sourceType":"script"}