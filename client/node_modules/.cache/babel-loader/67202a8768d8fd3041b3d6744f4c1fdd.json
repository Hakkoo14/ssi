{"ast":null,"code":"/* @flow */\n'use strict';\n/* :: import type {Callback, Batch, Query, QueryResult, QueryEntry} from 'interface-datastore' */\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pull = require('pull-stream');\n\nvar levelup = require('levelup');\n\nvar asyncFilter = require('interface-datastore').utils.asyncFilter;\n\nvar asyncSort = require('interface-datastore').utils.asyncSort;\n\nvar Key = require('interface-datastore').Key;\n\nvar Errors = require('interface-datastore').Errors;\n\nvar encode = require('encoding-down');\n/**\n * A datastore backed by leveldb.\n */\n\n/* :: export type LevelOptions = {\n  createIfMissing?: bool,\n  errorIfExists?: bool,\n  compression?: bool,\n  cacheSize?: number,\n  db?: Object\n} */\n\n\nvar LevelDatastore = /*#__PURE__*/function () {\n  /* :: db: levelup */\n  function LevelDatastore(path\n  /* : string */\n  , opts\n  /* : ?LevelOptions */\n  ) {\n    _classCallCheck(this, LevelDatastore);\n\n    var database;\n\n    if (opts && opts.db) {\n      database = opts.db;\n      delete opts.db;\n    } else {\n      // Default to leveldown db\n      database = require('leveldown');\n    }\n\n    this.db = levelup(encode(database(path), {\n      valueEncoding: 'binary'\n    }), Object.assign({}, opts, {\n      compression: false // same default as go\n\n    }), function (err) {\n      // Prevent an uncaught exception error on duplicate locks\n      if (err) {\n        throw err;\n      }\n    });\n  }\n\n  _createClass(LevelDatastore, [{\n    key: \"open\",\n    value: function open(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.db.open(function (err) {\n        if (err) {\n          return callback(Errors.dbOpenFailedError(err));\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"put\",\n    value: function put(key\n    /* : Key */\n    , value\n    /* : Buffer */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.db.put(key.toString(), value, function (err) {\n        if (err) {\n          return callback(Errors.dbWriteFailedError(err));\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(key\n    /* : Key */\n    , callback\n    /* : Callback<Buffer> */\n    )\n    /* : void */\n    {\n      this.db.get(key.toString(), function (err, data) {\n        if (err) {\n          return callback(Errors.notFoundError(err));\n        }\n\n        callback(null, data);\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(key\n    /* : Key */\n    , callback\n    /* : Callback<bool> */\n    )\n    /* : void */\n    {\n      this.db.get(key.toString(), function (err, res) {\n        if (err) {\n          if (err.notFound) {\n            callback(null, false);\n            return;\n          }\n\n          callback(err);\n          return;\n        }\n\n        callback(null, true);\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key\n    /* : Key */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.db.del(key.toString(), function (err) {\n        if (err) {\n          return callback(Errors.dbDeleteFailedError(err));\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.db.close(callback);\n    }\n  }, {\n    key: \"batch\",\n    value: function batch()\n    /* : Batch<Buffer> */\n    {\n      var _this = this;\n\n      var ops = [];\n      return {\n        put: function put(key\n        /* : Key */\n        , value\n        /* : Buffer */\n        )\n        /* : void */\n        {\n          ops.push({\n            type: 'put',\n            key: key.toString(),\n            value: value\n          });\n        },\n        delete: function _delete(key\n        /* : Key */\n        )\n        /* : void */\n        {\n          ops.push({\n            type: 'del',\n            key: key.toString()\n          });\n        },\n        commit: function commit(callback\n        /* : Callback<void> */\n        )\n        /* : void */\n        {\n          _this.db.batch(ops, callback);\n        }\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q\n    /* : Query<Buffer> */\n    )\n    /* : QueryResult<Buffer> */\n    {\n      var values = true;\n\n      if (q.keysOnly != null) {\n        values = !q.keysOnly;\n      }\n\n      var iter = this.db.db.iterator({\n        keys: true,\n        values: values,\n        keyAsBuffer: true\n      });\n\n      var rawStream = function rawStream(end, cb) {\n        if (end) {\n          return iter.end(function (err) {\n            cb(err || end);\n          });\n        }\n\n        iter.next(function (err, key, value) {\n          if (err) {\n            return cb(err);\n          }\n\n          if (err == null && key == null && value == null) {\n            return iter.end(function (err) {\n              cb(err || true);\n            });\n          }\n\n          var res\n          /* : QueryEntry<Buffer> */\n          = {\n            key: new Key(key, false)\n          };\n\n          if (values) {\n            res.value = Buffer.from(value);\n          }\n\n          cb(null, res);\n        });\n      };\n\n      var tasks = [rawStream];\n      var filters = [];\n\n      if (q.prefix != null) {\n        var prefix = q.prefix;\n        filters.push(function (e, cb) {\n          return cb(null, e.key.toString().startsWith(prefix));\n        });\n      }\n\n      if (q.filters != null) {\n        filters = filters.concat(q.filters);\n      }\n\n      tasks = tasks.concat(filters.map(function (f) {\n        return asyncFilter(f);\n      }));\n\n      if (q.orders != null) {\n        tasks = tasks.concat(q.orders.map(function (o) {\n          return asyncSort(o);\n        }));\n      }\n\n      if (q.offset != null) {\n        var i = 0;\n        tasks.push(pull.filter(function () {\n          return i++ >= q.offset;\n        }));\n      }\n\n      if (q.limit != null) {\n        tasks.push(pull.take(q.limit));\n      }\n\n      return pull.apply(null, tasks);\n    }\n  }]);\n\n  return LevelDatastore;\n}();\n\nmodule.exports = LevelDatastore;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/datastore-level/src/index.js"],"names":["pull","require","levelup","asyncFilter","utils","asyncSort","Key","Errors","encode","LevelDatastore","path","opts","database","db","valueEncoding","Object","assign","compression","err","callback","open","dbOpenFailedError","key","value","put","toString","dbWriteFailedError","get","data","notFoundError","res","notFound","del","dbDeleteFailedError","close","ops","push","type","delete","commit","batch","q","values","keysOnly","iter","iterator","keys","keyAsBuffer","rawStream","end","cb","next","Buffer","from","tasks","filters","prefix","e","startsWith","concat","map","f","orders","o","offset","i","filter","limit","take","apply","module","exports"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\n/* :: import type {Callback, Batch, Query, QueryResult, QueryEntry} from 'interface-datastore' */\n\nconst pull = require('pull-stream')\nconst levelup = require('levelup')\n\nconst asyncFilter = require('interface-datastore').utils.asyncFilter\nconst asyncSort = require('interface-datastore').utils.asyncSort\nconst Key = require('interface-datastore').Key\nconst Errors = require('interface-datastore').Errors\nconst encode = require('encoding-down')\n\n/**\n * A datastore backed by leveldb.\n */\n/* :: export type LevelOptions = {\n  createIfMissing?: bool,\n  errorIfExists?: bool,\n  compression?: bool,\n  cacheSize?: number,\n  db?: Object\n} */\nclass LevelDatastore {\n  /* :: db: levelup */\n\n  constructor (path /* : string */, opts /* : ?LevelOptions */) {\n    let database\n\n    if (opts && opts.db) {\n      database = opts.db\n      delete opts.db\n    } else {\n      // Default to leveldown db\n      database = require('leveldown')\n    }\n\n    this.db = levelup(\n      encode(database(path), { valueEncoding: 'binary' }),\n      Object.assign({}, opts, {\n        compression: false // same default as go\n      }),\n      (err) => {\n        // Prevent an uncaught exception error on duplicate locks\n        if (err) {\n          throw err\n        }\n      }\n    )\n  }\n\n  open (callback /* : Callback<void> */) /* : void */ {\n    this.db.open((err) => {\n      if (err) {\n        return callback(Errors.dbOpenFailedError(err))\n      }\n      callback()\n    })\n  }\n\n  put (key /* : Key */, value /* : Buffer */, callback /* : Callback<void> */) /* : void */ {\n    this.db.put(key.toString(), value, (err) => {\n      if (err) {\n        return callback(Errors.dbWriteFailedError(err))\n      }\n      callback()\n    })\n  }\n\n  get (key /* : Key */, callback /* : Callback<Buffer> */) /* : void */ {\n    this.db.get(key.toString(), (err, data) => {\n      if (err) {\n        return callback(Errors.notFoundError(err))\n      }\n      callback(null, data)\n    })\n  }\n\n  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {\n    this.db.get(key.toString(), (err, res) => {\n      if (err) {\n        if (err.notFound) {\n          callback(null, false)\n          return\n        }\n        callback(err)\n        return\n      }\n\n      callback(null, true)\n    })\n  }\n\n  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {\n    this.db.del(key.toString(), (err) => {\n      if (err) {\n        return callback(Errors.dbDeleteFailedError(err))\n      }\n      callback()\n    })\n  }\n\n  close (callback /* : Callback<void> */) /* : void */ {\n    this.db.close(callback)\n  }\n\n  batch () /* : Batch<Buffer> */ {\n    const ops = []\n    return {\n      put: (key /* : Key */, value /* : Buffer */) /* : void */ => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        })\n      },\n      delete: (key /* : Key */) /* : void */ => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        })\n      },\n      commit: (callback /* : Callback<void> */) /* : void */ => {\n        this.db.batch(ops, callback)\n      }\n    }\n  }\n\n  query (q /* : Query<Buffer> */) /* : QueryResult<Buffer> */ {\n    let values = true\n    if (q.keysOnly != null) {\n      values = !q.keysOnly\n    }\n\n    const iter = this.db.db.iterator({\n      keys: true,\n      values: values,\n      keyAsBuffer: true\n    })\n\n    const rawStream = (end, cb) => {\n      if (end) {\n        return iter.end((err) => {\n          cb(err || end)\n        })\n      }\n\n      iter.next((err, key, value) => {\n        if (err) {\n          return cb(err)\n        }\n\n        if (err == null && key == null && value == null) {\n          return iter.end((err) => {\n            cb(err || true)\n          })\n        }\n\n        const res /* : QueryEntry<Buffer> */ = {\n          key: new Key(key, false)\n        }\n\n        if (values) {\n          res.value = Buffer.from(value)\n        }\n\n        cb(null, res)\n      })\n    }\n\n    let tasks = [rawStream]\n    let filters = []\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      filters.push((e, cb) => cb(null, e.key.toString().startsWith(prefix)))\n    }\n\n    if (q.filters != null) {\n      filters = filters.concat(q.filters)\n    }\n\n    tasks = tasks.concat(filters.map(f => asyncFilter(f)))\n\n    if (q.orders != null) {\n      tasks = tasks.concat(q.orders.map(o => asyncSort(o)))\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      tasks.push(pull.filter(() => i++ >= q.offset))\n    }\n\n    if (q.limit != null) {\n      tasks.push(pull.take(q.limit))\n    }\n\n    return pull.apply(null, tasks)\n  }\n}\n\nmodule.exports = LevelDatastore\n"]},"metadata":{},"sourceType":"script"}