{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _inherits = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Key = require('interface-datastore').Key;\n\nvar readme = require('./shard-readme'); // eslint-disable-next-line\n\n/*:: import type {Datastore, Callback} from 'interface-datastore'\n\nexport interface ShardV1 {\n  name: string;\n  param: number;\n  fun(string): string;\n  toString(): string;\n}\n*/\n\n\nvar PREFIX = exports.PREFIX = '/repo/flatfs/shard/';\nvar SHARDING_FN = exports.SHARDING_FN = 'SHARDING';\nexports.README_FN = '_README';\n\nvar Shard = /*#__PURE__*/function () {\n  /* :: name: string */\n\n  /* :: param: number */\n\n  /* :: _padding: string */\n  function Shard(param\n  /* : number */\n  ) {\n    _classCallCheck(this, Shard);\n\n    this.param = param;\n  }\n\n  _createClass(Shard, [{\n    key: \"fun\",\n    value: function fun(str\n    /* : string */\n    )\n    /* : string */\n    {\n      throw new Error('implement me');\n    }\n  }, {\n    key: \"toString\",\n    value: function toString()\n    /* : string */\n    {\n      return \"\".concat(PREFIX, \"v1/\").concat(this.name, \"/\").concat(this.param);\n    }\n  }]);\n\n  return Shard;\n}();\n\nvar Prefix = /*#__PURE__*/function (_Shard) {\n  _inherits(Prefix, _Shard);\n\n  var _super = _createSuper(Prefix);\n\n  function Prefix(prefixLen\n  /* : number */\n  ) {\n    var _this;\n\n    _classCallCheck(this, Prefix);\n\n    _this = _super.call(this, prefixLen);\n    _this._padding = ''.padStart(prefixLen, '_');\n    _this.name = 'prefix';\n    return _this;\n  }\n\n  _createClass(Prefix, [{\n    key: \"fun\",\n    value: function fun(noslash\n    /* : string */\n    )\n    /* : string */\n    {\n      return (noslash + this._padding).slice(0, this.param);\n    }\n  }]);\n\n  return Prefix;\n}(Shard);\n\nvar Suffix = /*#__PURE__*/function (_Shard2) {\n  _inherits(Suffix, _Shard2);\n\n  var _super2 = _createSuper(Suffix);\n\n  function Suffix(suffixLen\n  /* : number */\n  ) {\n    var _this2;\n\n    _classCallCheck(this, Suffix);\n\n    _this2 = _super2.call(this, suffixLen);\n    _this2._padding = ''.padStart(suffixLen, '_');\n    _this2.name = 'suffix';\n    return _this2;\n  }\n\n  _createClass(Suffix, [{\n    key: \"fun\",\n    value: function fun(noslash\n    /* : string */\n    )\n    /* : string */\n    {\n      var s = this._padding + noslash;\n      return s.slice(s.length - this.param);\n    }\n  }]);\n\n  return Suffix;\n}(Shard);\n\nvar NextToLast = /*#__PURE__*/function (_Shard3) {\n  _inherits(NextToLast, _Shard3);\n\n  var _super3 = _createSuper(NextToLast);\n\n  function NextToLast(suffixLen\n  /* : number */\n  ) {\n    var _this3;\n\n    _classCallCheck(this, NextToLast);\n\n    _this3 = _super3.call(this, suffixLen);\n    _this3._padding = ''.padStart(suffixLen + 1, '_');\n    _this3.name = 'next-to-last';\n    return _this3;\n  }\n\n  _createClass(NextToLast, [{\n    key: \"fun\",\n    value: function fun(noslash\n    /* : string */\n    )\n    /* : string */\n    {\n      var s = this._padding + noslash;\n      var offset = s.length - this.param - 1;\n      return s.slice(offset, offset + this.param);\n    }\n  }]);\n\n  return NextToLast;\n}(Shard);\n/**\n * Convert a given string to the matching sharding function.\n *\n * @param {string} str\n * @returns {ShardV1}\n */\n\n\nfunction parseShardFun(str\n/* : string */\n)\n/* : ShardV1 */\n{\n  str = str.trim();\n\n  if (str.length === 0) {\n    throw new Error('empty shard string');\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(\"invalid or no path prefix: \".concat(str));\n  }\n\n  var parts = str.slice(PREFIX.length).split('/');\n  var version = parts[0];\n\n  if (version !== 'v1') {\n    throw new Error(\"expect 'v1' version, got '\".concat(version, \"'\"));\n  }\n\n  var name = parts[1];\n\n  if (!parts[2]) {\n    throw new Error('missing param');\n  }\n\n  var param = parseInt(parts[2], 10);\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param);\n\n    case 'suffix':\n      return new Suffix(param);\n\n    case 'next-to-last':\n      return new NextToLast(param);\n\n    default:\n      throw new Error(\"unkown sharding function: \".concat(name));\n  }\n}\n\nexports.readShardFun = function (path\n/* : string */\n, store\n/* : Datastore<Buffer> */\n, callback\n/* : Callback<ShardV1> */\n)\n/* : void */\n{\n  var key = new Key(path).child(new Key(SHARDING_FN));\n  var get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n  get(key, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    var shard;\n\n    try {\n      shard = parseShardFun((res || '').toString().trim());\n    } catch (err) {\n      return callback(err);\n    }\n\n    callback(null, shard);\n  });\n};\n\nexports.readme = readme;\nexports.parseShardFun = parseShardFun;\nexports.Prefix = Prefix;\nexports.Suffix = Suffix;\nexports.NextToLast = NextToLast;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/datastore-core/src/shard.js"],"names":["Key","require","readme","PREFIX","exports","SHARDING_FN","README_FN","Shard","param","str","Error","name","Prefix","prefixLen","_padding","padStart","noslash","slice","Suffix","suffixLen","s","length","NextToLast","offset","parseShardFun","trim","startsWith","parts","split","version","parseInt","readShardFun","path","store","callback","key","child","get","getRaw","bind","err","res","shard","toString"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\nconst Key = require('interface-datastore').Key\n\nconst readme = require('./shard-readme')\n\n// eslint-disable-next-line\n/*:: import type {Datastore, Callback} from 'interface-datastore'\n\nexport interface ShardV1 {\n  name: string;\n  param: number;\n  fun(string): string;\n  toString(): string;\n}\n*/\n\nconst PREFIX = exports.PREFIX = '/repo/flatfs/shard/'\nconst SHARDING_FN = exports.SHARDING_FN = 'SHARDING'\nexports.README_FN = '_README'\n\nclass Shard {\n  /* :: name: string */\n  /* :: param: number */\n  /* :: _padding: string */\n\n  constructor (param /* : number */) {\n    this.param = param\n  }\n\n  fun (str /* : string */) /* : string */ {\n    throw new Error('implement me')\n  }\n\n  toString () /* : string */ {\n    return `${PREFIX}v1/${this.name}/${this.param}`\n  }\n}\n\nclass Prefix extends Shard {\n  constructor (prefixLen /* : number */) {\n    super(prefixLen)\n    this._padding = ''.padStart(prefixLen, '_')\n    this.name = 'prefix'\n  }\n\n  fun (noslash /* : string */) /* : string */ {\n    return (noslash + this._padding).slice(0, this.param)\n  }\n}\n\nclass Suffix extends Shard {\n  constructor (suffixLen /* : number */) {\n    super(suffixLen)\n    this._padding = ''.padStart(suffixLen, '_')\n    this.name = 'suffix'\n  }\n\n  fun (noslash /* : string */) /* : string */ {\n    const s = this._padding + noslash\n    return s.slice(s.length - this.param)\n  }\n}\n\nclass NextToLast extends Shard {\n  constructor (suffixLen /* : number */) {\n    super(suffixLen)\n    this._padding = ''.padStart(suffixLen + 1, '_')\n    this.name = 'next-to-last'\n  }\n\n  fun (noslash /* : string */) /* : string */ {\n    const s = this._padding + noslash\n    const offset = s.length - this.param - 1\n    return s.slice(offset, offset + this.param)\n  }\n}\n\n/**\n * Convert a given string to the matching sharding function.\n *\n * @param {string} str\n * @returns {ShardV1}\n */\nfunction parseShardFun (str /* : string */) /* : ShardV1 */ {\n  str = str.trim()\n\n  if (str.length === 0) {\n    throw new Error('empty shard string')\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${str}`)\n  }\n\n  const parts = str.slice(PREFIX.length).split('/')\n  const version = parts[0]\n\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${version}'`)\n  }\n\n  const name = parts[1]\n\n  if (!parts[2]) {\n    throw new Error('missing param')\n  }\n\n  const param = parseInt(parts[2], 10)\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param)\n    case 'suffix':\n      return new Suffix(param)\n    case 'next-to-last':\n      return new NextToLast(param)\n    default:\n      throw new Error(`unkown sharding function: ${name}`)\n  }\n}\n\nexports.readShardFun = (path /* : string */, store /* : Datastore<Buffer> */, callback /* : Callback<ShardV1> */) /* : void */ => {\n  const key = new Key(path).child(new Key(SHARDING_FN))\n  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store)\n\n  get(key, (err, res) => {\n    if (err) {\n      return callback(err)\n    }\n\n    let shard\n    try {\n      shard = parseShardFun((res || '').toString().trim())\n    } catch (err) {\n      return callback(err)\n    }\n\n    callback(null, shard)\n  })\n}\n\nexports.readme = readme\nexports.parseShardFun = parseShardFun\nexports.Prefix = Prefix\nexports.Suffix = Suffix\nexports.NextToLast = NextToLast\n"]},"metadata":{},"sourceType":"script"}