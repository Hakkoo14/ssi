{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events');\n\nvar pull = require('pull-stream/pull');\n\nvar empty = require('pull-stream/sources/empty');\n\nvar asyncEach = require('async/each');\n\nvar TimeCache = require('time-cache');\n\nvar debug = require('debug');\n\nvar errcode = require('err-code');\n\nvar Peer = require('./peer');\n\nvar message = require('./message');\n\nvar _require = require('./message/sign'),\n    signMessage = _require.signMessage;\n\nvar utils = require('./utils');\n\nvar nextTick = require('async/nextTick');\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\n\n\nvar PubsubBaseProtocol = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PubsubBaseProtocol, _EventEmitter);\n\n  var _super = _createSuper(PubsubBaseProtocol);\n\n  /**\n   * @param {String} debugName\n   * @param {String} multicodec\n   * @param {Object} libp2p libp2p implementation\n   * @param {Object} options\n   * @param {boolean} options.signMessages if messages should be signed, defaults to true\n   * @constructor\n   */\n  function PubsubBaseProtocol(debugName, multicodec, libp2p, options) {\n    var _this;\n\n    _classCallCheck(this, PubsubBaseProtocol);\n\n    _this = _super.call(this);\n    options = _objectSpread({\n      signMessages: true\n    }, options);\n    _this.log = debug(debugName);\n    _this.log.err = debug(\"\".concat(debugName, \":error\"));\n    _this.multicodec = multicodec;\n    _this.libp2p = libp2p;\n    _this.started = false;\n\n    if (options.signMessages) {\n      _this.peerId = _this.libp2p.peerInfo.id;\n    }\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n\n\n    _this.topics = new Map();\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    _this.seenCache = new TimeCache();\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    _this.peers = new Map(); // Dials that are currently in progress\n\n    _this._dials = new Set();\n    _this._onConnection = _this._onConnection.bind(_assertThisInitialized(_this));\n    _this._dialPeer = _this._dialPeer.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Add a new connected peer to the peers map.\n   * @private\n   * @param {PeerInfo} peer peer info\n   * @returns {PeerInfo}\n   */\n\n\n  _createClass(PubsubBaseProtocol, [{\n    key: \"_addPeer\",\n    value: function _addPeer(peer) {\n      var _this2 = this;\n\n      var id = peer.info.id.toB58String();\n      /*\n        Always use an existing peer.\n         What is happening here is: \"If the other peer has already dialed to me, we already have\n        an establish link between the two, what might be missing is a\n        Connection specifically between me and that Peer\"\n       */\n\n      var existing = this.peers.get(id);\n\n      if (!existing) {\n        this.log('new peer', id);\n        this.peers.set(id, peer);\n        existing = peer;\n        peer.once('close', function () {\n          return _this2._removePeer(peer);\n        });\n      }\n\n      ++existing._references;\n      return existing;\n    }\n    /**\n     * Remove a peer from the peers map if it has no references.\n     * @private\n     * @param {Peer} peer peer state\n     * @returns {PeerInfo}\n     */\n\n  }, {\n    key: \"_removePeer\",\n    value: function _removePeer(peer) {\n      var id = peer.info.id.toB58String();\n      this.log('remove', id, peer._references); // Only delete when no one else is referencing this peer.\n\n      if (--peer._references === 0) {\n        this.log('delete peer', id);\n        this.peers.delete(id);\n      }\n\n      return peer;\n    }\n    /**\n     * Dial a received peer.\n     * @private\n     * @param {PeerInfo} peerInfo peer info\n     * @param {function} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(peerInfo, callback) {\n      var _this3 = this;\n\n      callback = callback || function noop() {};\n\n      var idB58Str = peerInfo.id.toB58String(); // If already have a PubSub conn, ignore\n\n      var peer = this.peers.get(idB58Str);\n\n      if (peer && peer.isConnected) {\n        return nextTick(function () {\n          return callback();\n        });\n      } // If already dialing this peer, ignore\n\n\n      if (this._dials.has(idB58Str)) {\n        this.log('already dialing %s, ignoring dial attempt', idB58Str);\n        return nextTick(function () {\n          return callback();\n        });\n      }\n\n      this._dials.add(idB58Str);\n\n      this.log('dialing %s', idB58Str);\n      this.libp2p.dialProtocol(peerInfo, this.multicodec, function (err, conn) {\n        _this3.log('dial to %s complete', idB58Str); // If the dial is not in the set, it means that pubsub has been\n        // stopped\n\n\n        var pubsubStopped = !_this3._dials.has(idB58Str);\n\n        _this3._dials.delete(idB58Str);\n\n        if (err) {\n          _this3.log.err(err);\n\n          return callback();\n        } // pubsub has been stopped, so we should just bail out\n\n\n        if (pubsubStopped) {\n          _this3.log('pubsub was stopped, not processing dial to %s', idB58Str);\n\n          return callback();\n        }\n\n        _this3._onDial(peerInfo, conn, callback);\n      });\n    }\n    /**\n     * Dial a received peer.\n     * @private\n     * @param {PeerInfo} peerInfo peer info\n     * @param {Connection} conn connection to the peer\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"_onDial\",\n    value: function _onDial(peerInfo, conn, callback) {\n      var idB58Str = peerInfo.id.toB58String();\n      this.log('connected', idB58Str);\n\n      var peer = this._addPeer(new Peer(peerInfo));\n\n      peer.attachConnection(conn);\n      nextTick(function () {\n        return callback();\n      });\n    }\n    /**\n     * On successful connection event.\n     * @private\n     * @param {String} protocol connection protocol\n     * @param {Connection} conn connection to the peer\n     */\n\n  }, {\n    key: \"_onConnection\",\n    value: function _onConnection(protocol, conn) {\n      var _this4 = this;\n\n      conn.getPeerInfo(function (err, peerInfo) {\n        if (err) {\n          _this4.log.err('Failed to identify incomming conn', err);\n\n          return pull(empty(), conn);\n        }\n\n        var idB58Str = peerInfo.id.toB58String();\n\n        var peer = _this4._addPeer(new Peer(peerInfo));\n\n        _this4._processConnection(idB58Str, conn, peer);\n      });\n    }\n    /**\n     * Overriding the implementation of _processConnection should keep the connection and is\n     * responsible for processing each RPC message received by other peers.\n     * @abstract\n     * @param {string} idB58Str peer id string in base58\n     * @param {Connection} conn connection\n     * @param {PeerInfo} peer peer info\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"_processConnection\",\n    value: function _processConnection(idB58Str, conn, peer) {\n      throw errcode('_processConnection must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * On connection end event.\n     * @private\n     * @param {string} idB58Str peer id string in base58\n     * @param {PeerInfo} peer peer info\n     * @param {Error} err error for connection end\n     */\n\n  }, {\n    key: \"_onConnectionEnd\",\n    value: function _onConnectionEnd(idB58Str, peer, err) {\n      // socket hang up, means the one side canceled\n      if (err && err.message !== 'socket hang up') {\n        this.log.err(err);\n      }\n\n      this.log('connection ended', idB58Str, err ? err.message : '');\n\n      this._removePeer(peer);\n    }\n    /**\n     * Normalizes the message and signs it, if signing is enabled\n     *\n     * @param {Message} message\n     * @param {function(Error, Message)} callback\n     */\n\n  }, {\n    key: \"_buildMessage\",\n    value: function _buildMessage(message, callback) {\n      var msg = utils.normalizeOutRpcMessage(message);\n\n      if (this.peerId) {\n        signMessage(this.peerId, msg, callback);\n      } else {\n        nextTick(callback, null, msg);\n      }\n    }\n    /**\n     * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @param {Array<any>|any} messages\n     * @param {function(Error)} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"publish\",\n    value: function publish(topics, messages, callback) {\n      throw errcode('publish must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(topics) {\n      throw errcode('subscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(topics) {\n      throw errcode('unsubscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Mounts the pubsub protocol onto the libp2p node and sends our\n     * subscriptions to every peer conneceted\n     *\n     * @param {Function} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      var _this5 = this;\n\n      if (this.started) {\n        return nextTick(function () {\n          return callback(new Error('already started'));\n        });\n      }\n\n      this.log('starting');\n      this.libp2p.handle(this.multicodec, this._onConnection); // Speed up any new peer that comes in my way\n\n      this.libp2p.on('peer:connect', this._dialPeer); // Dial already connected peers\n\n      var peerInfos = Object.values(this.libp2p.peerBook.getAll());\n      asyncEach(peerInfos, function (peer, cb) {\n        return _this5._dialPeer(peer, cb);\n      }, function (err) {\n        nextTick(function () {\n          _this5.log('started');\n\n          _this5.started = true;\n          callback(err);\n        });\n      });\n    }\n    /**\n     * Unmounts the pubsub protocol and shuts down every connection\n     *\n     * @param {Function} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var _this6 = this;\n\n      if (!this.started) {\n        return nextTick(function () {\n          return callback(new Error('not started yet'));\n        });\n      }\n\n      this.libp2p.unhandle(this.multicodec);\n      this.libp2p.removeListener('peer:connect', this._dialPeer); // Prevent any dials that are in flight from being processed\n\n      this._dials = new Set();\n      this.log('stopping');\n      asyncEach(this.peers.values(), function (peer, cb) {\n        return peer.close(cb);\n      }, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this6.log('stopped');\n\n        _this6.peers = new Map();\n        _this6.started = false;\n        callback();\n      });\n    }\n  }]);\n\n  return PubsubBaseProtocol;\n}(EventEmitter);\n\nmodule.exports = PubsubBaseProtocol;\nmodule.exports.message = message;\nmodule.exports.utils = utils;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/libp2p-pubsub/src/index.js"],"names":["EventEmitter","require","pull","empty","asyncEach","TimeCache","debug","errcode","Peer","message","signMessage","utils","nextTick","PubsubBaseProtocol","debugName","multicodec","libp2p","options","signMessages","log","err","started","peerId","peerInfo","id","topics","Map","seenCache","peers","_dials","Set","_onConnection","bind","_dialPeer","peer","info","toB58String","existing","get","set","once","_removePeer","_references","delete","callback","noop","idB58Str","isConnected","has","add","dialProtocol","conn","pubsubStopped","_onDial","_addPeer","attachConnection","protocol","getPeerInfo","_processConnection","msg","normalizeOutRpcMessage","messages","Error","handle","on","peerInfos","Object","values","peerBook","getAll","cb","unhandle","removeListener","close","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\nconst pull = require('pull-stream/pull')\nconst empty = require('pull-stream/sources/empty')\nconst asyncEach = require('async/each')\nconst TimeCache = require('time-cache')\nconst debug = require('debug')\nconst errcode = require('err-code')\n\nconst Peer = require('./peer')\nconst message = require('./message')\nconst { signMessage } = require('./message/sign')\nconst utils = require('./utils')\n\nconst nextTick = require('async/nextTick')\n\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {String} debugName\n   * @param {String} multicodec\n   * @param {Object} libp2p libp2p implementation\n   * @param {Object} options\n   * @param {boolean} options.signMessages if messages should be signed, defaults to true\n   * @constructor\n   */\n  constructor (debugName, multicodec, libp2p, options) {\n    super()\n\n    options = {\n      signMessages: true,\n      ...options\n    }\n\n    this.log = debug(debugName)\n    this.log.err = debug(`${debugName}:error`)\n    this.multicodec = multicodec\n    this.libp2p = libp2p\n    this.started = false\n\n    if (options.signMessages) {\n      this.peerId = this.libp2p.peerInfo.id\n    }\n\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n    this.topics = new Map()\n\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n    this.seenCache = new TimeCache()\n\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n    this.peers = new Map()\n\n    // Dials that are currently in progress\n    this._dials = new Set()\n\n    this._onConnection = this._onConnection.bind(this)\n    this._dialPeer = this._dialPeer.bind(this)\n  }\n\n  /**\n   * Add a new connected peer to the peers map.\n   * @private\n   * @param {PeerInfo} peer peer info\n   * @returns {PeerInfo}\n   */\n  _addPeer (peer) {\n    const id = peer.info.id.toB58String()\n\n    /*\n      Always use an existing peer.\n\n      What is happening here is: \"If the other peer has already dialed to me, we already have\n      an establish link between the two, what might be missing is a\n      Connection specifically between me and that Peer\"\n     */\n    let existing = this.peers.get(id)\n    if (!existing) {\n      this.log('new peer', id)\n      this.peers.set(id, peer)\n      existing = peer\n\n      peer.once('close', () => this._removePeer(peer))\n    }\n    ++existing._references\n\n    return existing\n  }\n\n  /**\n   * Remove a peer from the peers map if it has no references.\n   * @private\n   * @param {Peer} peer peer state\n   * @returns {PeerInfo}\n   */\n  _removePeer (peer) {\n    const id = peer.info.id.toB58String()\n\n    this.log('remove', id, peer._references)\n    // Only delete when no one else is referencing this peer.\n    if (--peer._references === 0) {\n      this.log('delete peer', id)\n      this.peers.delete(id)\n    }\n\n    return peer\n  }\n\n  /**\n   * Dial a received peer.\n   * @private\n   * @param {PeerInfo} peerInfo peer info\n   * @param {function} callback\n   * @returns {void}\n   */\n  _dialPeer (peerInfo, callback) {\n    callback = callback || function noop () { }\n    const idB58Str = peerInfo.id.toB58String()\n\n    // If already have a PubSub conn, ignore\n    const peer = this.peers.get(idB58Str)\n    if (peer && peer.isConnected) {\n      return nextTick(() => callback())\n    }\n\n    // If already dialing this peer, ignore\n    if (this._dials.has(idB58Str)) {\n      this.log('already dialing %s, ignoring dial attempt', idB58Str)\n      return nextTick(() => callback())\n    }\n    this._dials.add(idB58Str)\n\n    this.log('dialing %s', idB58Str)\n    this.libp2p.dialProtocol(peerInfo, this.multicodec, (err, conn) => {\n      this.log('dial to %s complete', idB58Str)\n\n      // If the dial is not in the set, it means that pubsub has been\n      // stopped\n      const pubsubStopped = !this._dials.has(idB58Str)\n      this._dials.delete(idB58Str)\n\n      if (err) {\n        this.log.err(err)\n        return callback()\n      }\n\n      // pubsub has been stopped, so we should just bail out\n      if (pubsubStopped) {\n        this.log('pubsub was stopped, not processing dial to %s', idB58Str)\n        return callback()\n      }\n\n      this._onDial(peerInfo, conn, callback)\n    })\n  }\n\n  /**\n   * Dial a received peer.\n   * @private\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Connection} conn connection to the peer\n   * @param {function} callback\n   */\n  _onDial (peerInfo, conn, callback) {\n    const idB58Str = peerInfo.id.toB58String()\n    this.log('connected', idB58Str)\n\n    const peer = this._addPeer(new Peer(peerInfo))\n    peer.attachConnection(conn)\n\n    nextTick(() => callback())\n  }\n\n  /**\n   * On successful connection event.\n   * @private\n   * @param {String} protocol connection protocol\n   * @param {Connection} conn connection to the peer\n   */\n  _onConnection (protocol, conn) {\n    conn.getPeerInfo((err, peerInfo) => {\n      if (err) {\n        this.log.err('Failed to identify incomming conn', err)\n        return pull(empty(), conn)\n      }\n\n      const idB58Str = peerInfo.id.toB58String()\n      const peer = this._addPeer(new Peer(peerInfo))\n\n      this._processConnection(idB58Str, conn, peer)\n    })\n  }\n\n  /**\n   * Overriding the implementation of _processConnection should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @abstract\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {PeerInfo} peer peer info\n   * @returns {undefined}\n   *\n   */\n  _processConnection (idB58Str, conn, peer) {\n    throw errcode('_processConnection must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * On connection end event.\n   * @private\n   * @param {string} idB58Str peer id string in base58\n   * @param {PeerInfo} peer peer info\n   * @param {Error} err error for connection end\n   */\n  _onConnectionEnd (idB58Str, peer, err) {\n    // socket hang up, means the one side canceled\n    if (err && err.message !== 'socket hang up') {\n      this.log.err(err)\n    }\n\n    this.log('connection ended', idB58Str, err ? err.message : '')\n    this._removePeer(peer)\n  }\n\n  /**\n   * Normalizes the message and signs it, if signing is enabled\n   *\n   * @param {Message} message\n   * @param {function(Error, Message)} callback\n   */\n  _buildMessage (message, callback) {\n    const msg = utils.normalizeOutRpcMessage(message)\n    if (this.peerId) {\n      signMessage(this.peerId, msg, callback)\n    } else {\n      nextTick(callback, null, msg)\n    }\n  }\n\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   */\n  publish (topics, messages, callback) {\n    throw errcode('publish must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n  subscribe (topics) {\n    throw errcode('subscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n  unsubscribe (topics) {\n    throw errcode('unsubscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Mounts the pubsub protocol onto the libp2p node and sends our\n   * subscriptions to every peer conneceted\n   *\n   * @param {Function} callback\n   * @returns {undefined}\n   *\n   */\n  start (callback) {\n    if (this.started) {\n      return nextTick(() => callback(new Error('already started')))\n    }\n    this.log('starting')\n\n    this.libp2p.handle(this.multicodec, this._onConnection)\n\n    // Speed up any new peer that comes in my way\n    this.libp2p.on('peer:connect', this._dialPeer)\n\n    // Dial already connected peers\n    const peerInfos = Object.values(this.libp2p.peerBook.getAll())\n\n    asyncEach(peerInfos, (peer, cb) => this._dialPeer(peer, cb), (err) => {\n      nextTick(() => {\n        this.log('started')\n        this.started = true\n        callback(err)\n      })\n    })\n  }\n\n  /**\n   * Unmounts the pubsub protocol and shuts down every connection\n   *\n   * @param {Function} callback\n   * @returns {undefined}\n   *\n   */\n  stop (callback) {\n    if (!this.started) {\n      return nextTick(() => callback(new Error('not started yet')))\n    }\n\n    this.libp2p.unhandle(this.multicodec)\n    this.libp2p.removeListener('peer:connect', this._dialPeer)\n\n    // Prevent any dials that are in flight from being processed\n    this._dials = new Set()\n\n    this.log('stopping')\n    asyncEach(this.peers.values(), (peer, cb) => peer.close(cb), (err) => {\n      if (err) {\n        return callback(err)\n      }\n\n      this.log('stopped')\n      this.peers = new Map()\n      this.started = false\n      callback()\n    })\n  }\n}\n\nmodule.exports = PubsubBaseProtocol\nmodule.exports.message = message\nmodule.exports.utils = utils\n"]},"metadata":{},"sourceType":"script"}