{"ast":null,"code":"var util = require('util');\n\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator;\n\nvar ltgt = require('ltgt');\n\nvar idbReadableStream = require('idb-readable-stream');\n\nvar stream = require('stream');\n\nvar xtend = require('xtend');\n\nvar Writable = stream.Writable;\nmodule.exports = Iterator;\n/**\r\n * Open IndexedDB cursor.\r\n *\r\n * @param {Object} db  db instance\r\n * @param {Object} [options]  options\r\n *\r\n * options:\r\n *   snapshot {Boolean}  Whether to use snapshot mode, that may lead to memory\r\n *     spikes, or use back pressure, that can't guarantee the same snapshot. This\r\n *     option is true by default.\r\n */\n\nfunction Iterator(db, options) {\n  this._db = db._db;\n  this._idbOpts = db._idbOpts;\n  AbstractIterator.call(this, db);\n  this._options = xtend({\n    snapshot: true\n  }, this._idbOpts, options);\n  this._limit = this._options.limit;\n\n  if (this._limit == null || this._limit === -1) {\n    this._limit = Infinity;\n  }\n\n  if (typeof this._limit !== 'number') throw new TypeError('options.limit must be a number');\n  if (this._limit === 0) return; // skip further processing and wait for first call to _next\n\n  this._count = 0;\n\n  this._startCursor(this._options);\n}\n\nutil.inherits(Iterator, AbstractIterator);\n\nIterator.prototype._startCursor = function (options) {\n  options = xtend(this._options, options);\n  var self = this;\n  var keyRange = null;\n  var lower = ltgt.lowerBound(options);\n  var upper = ltgt.upperBound(options);\n  var lowerOpen = ltgt.lowerBoundExclusive(options);\n  var upperOpen = ltgt.upperBoundExclusive(options);\n  var direction = options.reverse ? 'prev' : 'next'; // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)\n\n  if (lower) if (options.keyEncoding === 'binary' && !Array.isArray(lower)) lower = Array.prototype.slice.call(lower);\n  if (upper) if (options.keyEncoding === 'binary' && !Array.isArray(upper)) upper = Array.prototype.slice.call(upper);\n  if (lower && upper) try {\n    keyRange = IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen);\n  } catch (err) {\n    // skip the iterator and return 0 results if IDBKeyRange throws a DataError (if keys overlap)\n    this._keyRangeError = true;\n    return;\n  } else if (lower) keyRange = IDBKeyRange.lowerBound(lower, lowerOpen);else if (upper) keyRange = IDBKeyRange.upperBound(upper, upperOpen);\n  this._reader = idbReadableStream(this._db, this._idbOpts.storeName, xtend(options, {\n    range: keyRange,\n    direction: direction\n  }));\n\n  this._reader.on('error', function (err) {\n    var cb = self._callback;\n    self._callback = false;\n    if (cb) cb(err);else // else wait for _next\n      self._readNext = function (cb) {\n        cb(err);\n      };\n  });\n\n  this._reader.pipe(new Writable({\n    objectMode: true,\n    write: function write(item, enc, cb) {\n      if (self._count++ >= self._limit) {\n        // limit reached, finish\n        self._reader.pause();\n\n        self._reader.unpipe(this);\n\n        cb();\n        this.end();\n        return;\n      }\n\n      var cb2 = self._callback;\n      self._callback = false;\n      if (cb2) self._processItem(item, function (err, key, value) {\n        cb(err); // proceed with next item\n\n        cb2(err, key, value);\n      });else // else wait for _next\n        self._readNext = function (cb2) {\n          self._processItem(item, function (err, key, value) {\n            cb(err); // proceed with next item\n\n            cb2(err, key, value);\n          });\n        };\n    }\n  })).on('finish', function () {\n    var cb = self._callback;\n    self._callback = false;\n    if (cb) cb();else // else wait for _next\n      self._readNext = function (cb) {\n        cb();\n      };\n  });\n};\n\nIterator.prototype._processItem = function (item, cb) {\n  if (typeof cb !== 'function') throw new TypeError('cb must be a function');\n  var key = item.key;\n  var value = item.value; // automatically convert Uint8Array values to Buffer\n\n  if (value instanceof Uint8Array) value = new Buffer(value);\n  if (this._options.keyEncoding === 'binary' && Array.isArray(key)) key = new Buffer(key);\n  if (this._options.valueEncoding === 'binary' && !Buffer.isBuffer(value)) value = new Buffer(value);\n\n  if (this._options.keyAsBuffer && !Buffer.isBuffer(key)) {\n    if (key == null) key = new Buffer(0);else if (typeof key === 'string') key = new Buffer(key); // defaults to utf8, should the encoding be utf16? (DOMString)\n    else if (typeof key === 'boolean') key = new Buffer(String(key)); // compatible with leveldb\n      else if (typeof key === 'number') key = new Buffer(String(key)); // compatible with leveldb\n        else if (Array.isArray(key)) key = new Buffer(String(key)); // compatible with leveldb\n          else if (key instanceof Uint8Array) key = new Buffer(key);else throw new TypeError('can\\'t coerce `' + key.constructor.name + '` into a Buffer');\n  }\n\n  if (this._options.valueAsBuffer && !Buffer.isBuffer(value)) {\n    if (value == null) value = new Buffer(0);else if (typeof value === 'string') value = new Buffer(value); // defaults to utf8, should the encoding be utf16? (DOMString)\n    else if (typeof value === 'boolean') value = new Buffer(String(value)); // compatible with leveldb\n      else if (typeof value === 'number') value = new Buffer(String(value)); // compatible with leveldb\n        else if (Array.isArray(value)) value = new Buffer(String(value)); // compatible with leveldb\n          else if (value instanceof Uint8Array) value = new Buffer(value);else throw new TypeError('can\\'t coerce `' + value.constructor.name + '` into a Buffer');\n  }\n\n  cb(null, key, value);\n}; // register a callback, only call it directly if a nextHandler is registered\n\n\nIterator.prototype._next = function (callback) {\n  if (this._callback) throw new Error('callback already exists'); // each callback should be invoked exactly once\n\n  if (this._keyRangeError || this._limit === 0) return void callback();\n  var readNext = this._readNext;\n  this._readNext = false;\n\n  if (readNext) {\n    process.nextTick(function () {\n      readNext(callback);\n    });\n  } else {\n    this._callback = callback;\n  }\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/datastore-level/node_modules/level-js/iterator.js"],"names":["util","require","AbstractIterator","ltgt","idbReadableStream","stream","xtend","Writable","module","exports","Iterator","db","options","_db","_idbOpts","call","_options","snapshot","_limit","limit","Infinity","TypeError","_count","_startCursor","inherits","prototype","self","keyRange","lower","lowerBound","upper","upperBound","lowerOpen","lowerBoundExclusive","upperOpen","upperBoundExclusive","direction","reverse","keyEncoding","Array","isArray","slice","IDBKeyRange","bound","err","_keyRangeError","_reader","storeName","range","on","cb","_callback","_readNext","pipe","objectMode","write","item","enc","pause","unpipe","end","cb2","_processItem","key","value","Uint8Array","Buffer","valueEncoding","isBuffer","keyAsBuffer","String","constructor","name","valueAsBuffer","_next","callback","Error","readNext","process","nextTick"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,gBAAgB,GAAID,OAAO,CAAC,oBAAD,CAAP,CAA8BC,gBAAtD;;AACA,IAAIC,IAAI,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIG,iBAAiB,GAAGH,OAAO,CAAC,qBAAD,CAA/B;;AACA,IAAII,MAAM,GAAGJ,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIK,KAAK,GAAGL,OAAO,CAAC,OAAD,CAAnB;;AAEA,IAAIM,QAAQ,GAAGF,MAAM,CAACE,QAAtB;AAEAC,MAAM,CAACC,OAAP,GAAiBC,QAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,QAAT,CAAkBC,EAAlB,EAAsBC,OAAtB,EAA+B;AAC7B,OAAKC,GAAL,GAAWF,EAAE,CAACE,GAAd;AACA,OAAKC,QAAL,GAAgBH,EAAE,CAACG,QAAnB;AAEAZ,EAAAA,gBAAgB,CAACa,IAAjB,CAAsB,IAAtB,EAA4BJ,EAA5B;AAEA,OAAKK,QAAL,GAAgBV,KAAK,CAAC;AACpBW,IAAAA,QAAQ,EAAE;AADU,GAAD,EAElB,KAAKH,QAFa,EAEHF,OAFG,CAArB;AAIA,OAAKM,MAAL,GAAc,KAAKF,QAAL,CAAcG,KAA5B;;AACA,MAAI,KAAKD,MAAL,IAAe,IAAf,IAAuB,KAAKA,MAAL,KAAgB,CAAC,CAA5C,EAA+C;AAC7C,SAAKA,MAAL,GAAcE,QAAd;AACD;;AACD,MAAI,OAAO,KAAKF,MAAZ,KAAuB,QAA3B,EAAqC,MAAM,IAAIG,SAAJ,CAAc,gCAAd,CAAN;AACrC,MAAI,KAAKH,MAAL,KAAgB,CAApB,EAAuB,OAfM,CAeC;;AAE9B,OAAKI,MAAL,GAAc,CAAd;;AAEA,OAAKC,YAAL,CAAkB,KAAKP,QAAvB;AACD;;AAEDhB,IAAI,CAACwB,QAAL,CAAcd,QAAd,EAAwBR,gBAAxB;;AAEAQ,QAAQ,CAACe,SAAT,CAAmBF,YAAnB,GAAkC,UAASX,OAAT,EAAkB;AAClDA,EAAAA,OAAO,GAAGN,KAAK,CAAC,KAAKU,QAAN,EAAgBJ,OAAhB,CAAf;AAEA,MAAIc,IAAI,GAAG,IAAX;AAEA,MAAIC,QAAQ,GAAG,IAAf;AACA,MAAIC,KAAK,GAAGzB,IAAI,CAAC0B,UAAL,CAAgBjB,OAAhB,CAAZ;AACA,MAAIkB,KAAK,GAAG3B,IAAI,CAAC4B,UAAL,CAAgBnB,OAAhB,CAAZ;AACA,MAAIoB,SAAS,GAAG7B,IAAI,CAAC8B,mBAAL,CAAyBrB,OAAzB,CAAhB;AACA,MAAIsB,SAAS,GAAG/B,IAAI,CAACgC,mBAAL,CAAyBvB,OAAzB,CAAhB;AAEA,MAAIwB,SAAS,GAAGxB,OAAO,CAACyB,OAAR,GAAkB,MAAlB,GAA0B,MAA1C,CAXkD,CAalD;;AACA,MAAIT,KAAJ,EACE,IAAIhB,OAAO,CAAC0B,WAAR,KAAwB,QAAxB,IAAoC,CAACC,KAAK,CAACC,OAAN,CAAcZ,KAAd,CAAzC,EAA+DA,KAAK,GAAGW,KAAK,CAACd,SAAN,CAAgBgB,KAAhB,CAAsB1B,IAAtB,CAA2Ba,KAA3B,CAAR;AACjE,MAAIE,KAAJ,EACE,IAAIlB,OAAO,CAAC0B,WAAR,KAAwB,QAAxB,IAAoC,CAACC,KAAK,CAACC,OAAN,CAAcV,KAAd,CAAzC,EAA+DA,KAAK,GAAGS,KAAK,CAACd,SAAN,CAAgBgB,KAAhB,CAAsB1B,IAAtB,CAA2Be,KAA3B,CAAR;AAEjE,MAAIF,KAAK,IAAIE,KAAb,EACE,IAAI;AACFH,IAAAA,QAAQ,GAAGe,WAAW,CAACC,KAAZ,CAAkBf,KAAlB,EAAyBE,KAAzB,EAAgCE,SAAhC,EAA2CE,SAA3C,CAAX;AACD,GAFD,CAEE,OAAOU,GAAP,EAAY;AACZ;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACA;AACD,GAPH,MAQK,IAAIjB,KAAJ,EACHD,QAAQ,GAAGe,WAAW,CAACb,UAAZ,CAAuBD,KAAvB,EAA8BI,SAA9B,CAAX,CADG,KAEA,IAAIF,KAAJ,EACHH,QAAQ,GAAGe,WAAW,CAACX,UAAZ,CAAuBD,KAAvB,EAA8BI,SAA9B,CAAX;AAEF,OAAKY,OAAL,GAAe1C,iBAAiB,CAAC,KAAKS,GAAN,EAAW,KAAKC,QAAL,CAAciC,SAAzB,EAAoCzC,KAAK,CAACM,OAAD,EAAU;AAAEoC,IAAAA,KAAK,EAAErB,QAAT;AAAmBS,IAAAA,SAAS,EAAEA;AAA9B,GAAV,CAAzC,CAAhC;;AAEA,OAAKU,OAAL,CAAaG,EAAb,CAAgB,OAAhB,EAAyB,UAASL,GAAT,EAAc;AACrC,QAAIM,EAAE,GAAGxB,IAAI,CAACyB,SAAd;AACAzB,IAAAA,IAAI,CAACyB,SAAL,GAAiB,KAAjB;AAEA,QAAID,EAAJ,EACEA,EAAE,CAACN,GAAD,CAAF,CADF,KAEK;AACHlB,MAAAA,IAAI,CAAC0B,SAAL,GAAiB,UAASF,EAAT,EAAa;AAC5BA,QAAAA,EAAE,CAACN,GAAD,CAAF;AACD,OAFD;AAGH,GAVD;;AAYA,OAAKE,OAAL,CAAaO,IAAb,CAAkB,IAAI9C,QAAJ,CAAa;AAC7B+C,IAAAA,UAAU,EAAE,IADiB;AAE7BC,IAAAA,KAAK,EAAE,eAASC,IAAT,EAAeC,GAAf,EAAoBP,EAApB,EAAwB;AAC7B,UAAIxB,IAAI,CAACJ,MAAL,MAAiBI,IAAI,CAACR,MAA1B,EAAkC;AAAE;AAClCQ,QAAAA,IAAI,CAACoB,OAAL,CAAaY,KAAb;;AACAhC,QAAAA,IAAI,CAACoB,OAAL,CAAaa,MAAb,CAAoB,IAApB;;AACAT,QAAAA,EAAE;AACF,aAAKU,GAAL;AACA;AACD;;AAED,UAAIC,GAAG,GAAGnC,IAAI,CAACyB,SAAf;AACAzB,MAAAA,IAAI,CAACyB,SAAL,GAAiB,KAAjB;AAEA,UAAIU,GAAJ,EACEnC,IAAI,CAACoC,YAAL,CAAkBN,IAAlB,EAAwB,UAASZ,GAAT,EAAcmB,GAAd,EAAmBC,KAAnB,EAA0B;AAChDd,QAAAA,EAAE,CAACN,GAAD,CAAF,CADgD,CACxC;;AACRiB,QAAAA,GAAG,CAACjB,GAAD,EAAMmB,GAAN,EAAWC,KAAX,CAAH;AACD,OAHD,EADF,KAKK;AACHtC,QAAAA,IAAI,CAAC0B,SAAL,GAAiB,UAASS,GAAT,EAAc;AAC7BnC,UAAAA,IAAI,CAACoC,YAAL,CAAkBN,IAAlB,EAAwB,UAASZ,GAAT,EAAcmB,GAAd,EAAmBC,KAAnB,EAA0B;AAChDd,YAAAA,EAAE,CAACN,GAAD,CAAF,CADgD,CACxC;;AACRiB,YAAAA,GAAG,CAACjB,GAAD,EAAMmB,GAAN,EAAWC,KAAX,CAAH;AACD,WAHD;AAID,SALD;AAOH;AA3B4B,GAAb,CAAlB,EA4BIf,EA5BJ,CA4BO,QA5BP,EA4BiB,YAAW;AAC1B,QAAIC,EAAE,GAAGxB,IAAI,CAACyB,SAAd;AACAzB,IAAAA,IAAI,CAACyB,SAAL,GAAiB,KAAjB;AAEA,QAAID,EAAJ,EACEA,EAAE,GADJ,KAEK;AACHxB,MAAAA,IAAI,CAAC0B,SAAL,GAAiB,UAASF,EAAT,EAAa;AAC5BA,QAAAA,EAAE;AACH,OAFD;AAGH,GAtCD;AAuCD,CArFD;;AAuFAxC,QAAQ,CAACe,SAAT,CAAmBqC,YAAnB,GAAkC,UAASN,IAAT,EAAeN,EAAf,EAAmB;AACnD,MAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B,MAAM,IAAI7B,SAAJ,CAAc,uBAAd,CAAN;AAE9B,MAAI0C,GAAG,GAAGP,IAAI,CAACO,GAAf;AACA,MAAIC,KAAK,GAAGR,IAAI,CAACQ,KAAjB,CAJmD,CAMnD;;AACA,MAAIA,KAAK,YAAYC,UAArB,EAAiCD,KAAK,GAAG,IAAIE,MAAJ,CAAWF,KAAX,CAAR;AACjC,MAAI,KAAKhD,QAAL,CAAcsB,WAAd,KAA8B,QAA9B,IAA0CC,KAAK,CAACC,OAAN,CAAcuB,GAAd,CAA9C,EAAkEA,GAAG,GAAG,IAAIG,MAAJ,CAAWH,GAAX,CAAN;AAClE,MAAI,KAAK/C,QAAL,CAAcmD,aAAd,KAAgC,QAAhC,IAA4C,CAACD,MAAM,CAACE,QAAP,CAAgBJ,KAAhB,CAAjD,EAAyEA,KAAK,GAAG,IAAIE,MAAJ,CAAWF,KAAX,CAAR;;AAEzE,MAAI,KAAKhD,QAAL,CAAcqD,WAAd,IAA6B,CAACH,MAAM,CAACE,QAAP,CAAgBL,GAAhB,CAAlC,EAAwD;AACtD,QAAIA,GAAG,IAAI,IAAX,EAAqCA,GAAG,GAAG,IAAIG,MAAJ,CAAW,CAAX,CAAN,CAArC,KACK,IAAI,OAAOH,GAAP,KAAe,QAAnB,EAAgCA,GAAG,GAAG,IAAIG,MAAJ,CAAWH,GAAX,CAAN,CAAhC,CAAsD;AAAtD,SACA,IAAI,OAAOA,GAAP,KAAe,SAAnB,EAAgCA,GAAG,GAAG,IAAIG,MAAJ,CAAWI,MAAM,CAACP,GAAD,CAAjB,CAAN,CAAhC,CAA8D;AAA9D,WACA,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAAgCA,GAAG,GAAG,IAAIG,MAAJ,CAAWI,MAAM,CAACP,GAAD,CAAjB,CAAN,CAAhC,CAA8D;AAA9D,aACA,IAAIxB,KAAK,CAACC,OAAN,CAAcuB,GAAd,CAAJ,EAAgCA,GAAG,GAAG,IAAIG,MAAJ,CAAWI,MAAM,CAACP,GAAD,CAAjB,CAAN,CAAhC,CAA8D;AAA9D,eACA,IAAIA,GAAG,YAAYE,UAAnB,EAAgCF,GAAG,GAAG,IAAIG,MAAJ,CAAWH,GAAX,CAAN,CAAhC,KACA,MAAM,IAAI1C,SAAJ,CAAc,oBAAoB0C,GAAG,CAACQ,WAAJ,CAAgBC,IAApC,GAA2C,iBAAzD,CAAN;AACN;;AAED,MAAI,KAAKxD,QAAL,CAAcyD,aAAd,IAA+B,CAACP,MAAM,CAACE,QAAP,CAAgBJ,KAAhB,CAApC,EAA4D;AAC1D,QAAIA,KAAK,IAAI,IAAb,EAAuCA,KAAK,GAAG,IAAIE,MAAJ,CAAW,CAAX,CAAR,CAAvC,KACK,IAAI,OAAOF,KAAP,KAAiB,QAArB,EAAkCA,KAAK,GAAG,IAAIE,MAAJ,CAAWF,KAAX,CAAR,CAAlC,CAA4D;AAA5D,SACA,IAAI,OAAOA,KAAP,KAAiB,SAArB,EAAkCA,KAAK,GAAG,IAAIE,MAAJ,CAAWI,MAAM,CAACN,KAAD,CAAjB,CAAR,CAAlC,CAAoE;AAApE,WACA,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAAkCA,KAAK,GAAG,IAAIE,MAAJ,CAAWI,MAAM,CAACN,KAAD,CAAjB,CAAR,CAAlC,CAAoE;AAApE,aACA,IAAIzB,KAAK,CAACC,OAAN,CAAcwB,KAAd,CAAJ,EAAkCA,KAAK,GAAG,IAAIE,MAAJ,CAAWI,MAAM,CAACN,KAAD,CAAjB,CAAR,CAAlC,CAAoE;AAApE,eACA,IAAIA,KAAK,YAAYC,UAArB,EAAkCD,KAAK,GAAG,IAAIE,MAAJ,CAAWF,KAAX,CAAR,CAAlC,KACA,MAAM,IAAI3C,SAAJ,CAAc,oBAAoB2C,KAAK,CAACO,WAAN,CAAkBC,IAAtC,GAA6C,iBAA3D,CAAN;AACN;;AAEDtB,EAAAA,EAAE,CAAC,IAAD,EAAOa,GAAP,EAAYC,KAAZ,CAAF;AACD,CAhCD,C,CAkCA;;;AACAtD,QAAQ,CAACe,SAAT,CAAmBiD,KAAnB,GAA2B,UAASC,QAAT,EAAmB;AAC5C,MAAI,KAAKxB,SAAT,EAAoB,MAAM,IAAIyB,KAAJ,CAAU,yBAAV,CAAN,CADwB,CACmB;;AAC/D,MAAI,KAAK/B,cAAL,IAAuB,KAAK3B,MAAL,KAAgB,CAA3C,EAA8C,OAAO,KAAKyD,QAAQ,EAApB;AAE9C,MAAIE,QAAQ,GAAG,KAAKzB,SAApB;AACA,OAAKA,SAAL,GAAiB,KAAjB;;AAEA,MAAIyB,QAAJ,EAAc;AACZC,IAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1BF,MAAAA,QAAQ,CAACF,QAAD,CAAR;AACD,KAFD;AAGD,GAJD,MAIO;AACL,SAAKxB,SAAL,GAAiBwB,QAAjB;AACD;AACF,CAdD","sourcesContent":["var util = require('util')\r\nvar AbstractIterator  = require('abstract-leveldown').AbstractIterator\r\nvar ltgt = require('ltgt')\r\nvar idbReadableStream = require('idb-readable-stream')\r\nvar stream = require('stream')\r\nvar xtend = require('xtend')\r\n\r\nvar Writable = stream.Writable\r\n\r\nmodule.exports = Iterator\r\n\r\n/**\r\n * Open IndexedDB cursor.\r\n *\r\n * @param {Object} db  db instance\r\n * @param {Object} [options]  options\r\n *\r\n * options:\r\n *   snapshot {Boolean}  Whether to use snapshot mode, that may lead to memory\r\n *     spikes, or use back pressure, that can't guarantee the same snapshot. This\r\n *     option is true by default.\r\n */\r\nfunction Iterator(db, options) {\r\n  this._db = db._db\r\n  this._idbOpts = db._idbOpts\r\n\r\n  AbstractIterator.call(this, db)\r\n\r\n  this._options = xtend({\r\n    snapshot: true\r\n  }, this._idbOpts, options)\r\n\r\n  this._limit = this._options.limit\r\n  if (this._limit == null || this._limit === -1) {\r\n    this._limit = Infinity\r\n  }\r\n  if (typeof this._limit !== 'number') throw new TypeError('options.limit must be a number')\r\n  if (this._limit === 0) return // skip further processing and wait for first call to _next\r\n\r\n  this._count = 0\r\n\r\n  this._startCursor(this._options)\r\n}\r\n\r\nutil.inherits(Iterator, AbstractIterator)\r\n\r\nIterator.prototype._startCursor = function(options) {\r\n  options = xtend(this._options, options)\r\n\r\n  var self = this\r\n\r\n  var keyRange = null\r\n  var lower = ltgt.lowerBound(options)\r\n  var upper = ltgt.upperBound(options)\r\n  var lowerOpen = ltgt.lowerBoundExclusive(options)\r\n  var upperOpen = ltgt.upperBoundExclusive(options)\r\n\r\n  var direction = options.reverse ? 'prev': 'next'\r\n\r\n  // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)\r\n  if (lower)\r\n    if (options.keyEncoding === 'binary' && !Array.isArray(lower)) lower = Array.prototype.slice.call(lower)\r\n  if (upper)\r\n    if (options.keyEncoding === 'binary' && !Array.isArray(upper)) upper = Array.prototype.slice.call(upper)\r\n\r\n  if (lower && upper)\r\n    try {\r\n      keyRange = IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)\r\n    } catch (err) {\r\n      // skip the iterator and return 0 results if IDBKeyRange throws a DataError (if keys overlap)\r\n      this._keyRangeError = true\r\n      return\r\n    }\r\n  else if (lower)\r\n    keyRange = IDBKeyRange.lowerBound(lower, lowerOpen)\r\n  else if (upper)\r\n    keyRange = IDBKeyRange.upperBound(upper, upperOpen)\r\n\r\n  this._reader = idbReadableStream(this._db, this._idbOpts.storeName, xtend(options, { range: keyRange, direction: direction }))\r\n\r\n  this._reader.on('error', function(err) {\r\n    var cb = self._callback\r\n    self._callback = false\r\n\r\n    if (cb)\r\n      cb(err)\r\n    else // else wait for _next\r\n      self._readNext = function(cb) {\r\n        cb(err)\r\n      }\r\n  })\r\n\r\n  this._reader.pipe(new Writable({\r\n    objectMode: true,\r\n    write: function(item, enc, cb) {\r\n      if (self._count++ >= self._limit) { // limit reached, finish\r\n        self._reader.pause()\r\n        self._reader.unpipe(this)\r\n        cb()\r\n        this.end()\r\n        return\r\n      }\r\n\r\n      var cb2 = self._callback\r\n      self._callback = false\r\n\r\n      if (cb2)\r\n        self._processItem(item, function(err, key, value) {\r\n          cb(err) // proceed with next item\r\n          cb2(err, key, value)\r\n        })\r\n      else // else wait for _next\r\n        self._readNext = function(cb2) {\r\n          self._processItem(item, function(err, key, value) {\r\n            cb(err) // proceed with next item\r\n            cb2(err, key, value)\r\n          })\r\n        }\r\n\r\n    }\r\n  })).on('finish', function() {\r\n    var cb = self._callback\r\n    self._callback = false\r\n\r\n    if (cb)\r\n      cb()\r\n    else // else wait for _next\r\n      self._readNext = function(cb) {\r\n        cb()\r\n      }\r\n  })\r\n}\r\n\r\nIterator.prototype._processItem = function(item, cb) {\r\n  if (typeof cb !== 'function') throw new TypeError('cb must be a function')\r\n\r\n  var key = item.key\r\n  var value = item.value\r\n\r\n  // automatically convert Uint8Array values to Buffer\r\n  if (value instanceof Uint8Array) value = new Buffer(value)\r\n  if (this._options.keyEncoding === 'binary' && Array.isArray(key)) key = new Buffer(key)\r\n  if (this._options.valueEncoding === 'binary' && !Buffer.isBuffer(value)) value = new Buffer(value)\r\n\r\n  if (this._options.keyAsBuffer && !Buffer.isBuffer(key)) {\r\n    if (key == null)                     key = new Buffer(0)\r\n    else if (typeof key === 'string')    key = new Buffer(key) // defaults to utf8, should the encoding be utf16? (DOMString)\r\n    else if (typeof key === 'boolean')   key = new Buffer(String(key)) // compatible with leveldb\r\n    else if (typeof key === 'number')    key = new Buffer(String(key)) // compatible with leveldb\r\n    else if (Array.isArray(key))         key = new Buffer(String(key)) // compatible with leveldb\r\n    else if (key instanceof Uint8Array)  key = new Buffer(key)\r\n    else throw new TypeError('can\\'t coerce `' + key.constructor.name + '` into a Buffer')\r\n  }\r\n\r\n  if (this._options.valueAsBuffer && !Buffer.isBuffer(value)) {\r\n    if (value == null)                     value = new Buffer(0)\r\n    else if (typeof value === 'string')    value = new Buffer(value) // defaults to utf8, should the encoding be utf16? (DOMString)\r\n    else if (typeof value === 'boolean')   value = new Buffer(String(value)) // compatible with leveldb\r\n    else if (typeof value === 'number')    value = new Buffer(String(value)) // compatible with leveldb\r\n    else if (Array.isArray(value))         value = new Buffer(String(value)) // compatible with leveldb\r\n    else if (value instanceof Uint8Array)  value = new Buffer(value)\r\n    else throw new TypeError('can\\'t coerce `' + value.constructor.name + '` into a Buffer')\r\n  }\r\n\r\n  cb(null, key, value)\r\n}\r\n\r\n// register a callback, only call it directly if a nextHandler is registered\r\nIterator.prototype._next = function(callback) {\r\n  if (this._callback) throw new Error('callback already exists') // each callback should be invoked exactly once\r\n  if (this._keyRangeError || this._limit === 0) return void callback()\r\n\r\n  var readNext = this._readNext\r\n  this._readNext = false\r\n\r\n  if (readNext) {\r\n    process.nextTick(function() {\r\n      readNext(callback)\r\n    })\r\n  } else {\r\n    this._callback = callback\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}