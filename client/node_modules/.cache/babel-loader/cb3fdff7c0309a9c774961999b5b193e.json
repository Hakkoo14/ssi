{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar sanitize = require('sanitize-filename');\n\nvar mergeOptions = require('merge-options');\n\nvar crypto = require('libp2p-crypto');\n\nvar DS = require('interface-datastore');\n\nvar collect = require('pull-stream/sinks/collect');\n\nvar pull = require('pull-stream/pull');\n\nvar CMS = require('./cms');\n\nvar errcode = require('err-code');\n\nvar keyPrefix = '/pkcs8/';\nvar infoPrefix = '/info/'; // NIST SP 800-132\n\nvar NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n};\nvar defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n};\n\nfunction validateKeyName(name) {\n  if (!name) return false;\n  if (typeof name !== 'string') return false;\n  return name === sanitize(name.trim());\n}\n/**\n * Returns an error to the caller, after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {function(Error)} callback - The caller\n * @param {string | Error} err - The error\n * @returns {undefined}\n * @private\n */\n\n\nfunction _error(callback, err) {\n  var min = 200;\n  var max = 1000;\n  var delay = Math.random() * (max - min) + min;\n  setTimeout(callback, delay, err, null);\n}\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction DsName(name) {\n  return new DS.Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction DsInfoName(name) {\n  return new DS.Key(infoPrefix + name);\n}\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n *\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\n\n\nvar Keychain = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {DS} store - where the key are.\n   * @param {object} options - ???\n   */\n  function Keychain(store, options) {\n    _classCallCheck(this, Keychain);\n\n    if (!store) {\n      throw new Error('store is required');\n    }\n\n    this.store = store;\n    var opts = mergeOptions(defaultOptions, options); // Enforce NIST SP 800-132\n\n    if (!opts.passPhrase || opts.passPhrase.length < 20) {\n      throw new Error('passPhrase must be least 20 characters');\n    }\n\n    if (opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(\"dek.keyLength must be least \".concat(NIST.minKeyLength, \" bytes\"));\n    }\n\n    if (opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(\"dek.saltLength must be least \".concat(NIST.minSaltLength, \" bytes\"));\n    }\n\n    if (opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(\"dek.iterationCount must be least \".concat(NIST.minIterationCount));\n    } // Create the derived encrypting key\n\n\n    var dek = crypto.pbkdf2(opts.passPhrase, opts.dek.salt, opts.dek.iterationCount, opts.dek.keyLength, opts.dek.hash);\n    Object.defineProperty(this, '_', {\n      value: function value() {\n        return dek;\n      }\n    });\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n\n\n  _createClass(Keychain, [{\n    key: \"cms\",\n    get: function get() {\n      return new CMS(this);\n    }\n    /**\n     * Generates the options for a keychain.  A random salt is produced.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"createKey\",\n    value:\n    /**\n     * Create a new key.\n     *\n     * @param {string} name - The local key name; cannot already exist.\n     * @param {string} type - One of the key types; 'rsa'.\n     * @param {int} size - The key size in bits.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n    function createKey(name, type, size, callback) {\n      var _this = this;\n\n      var self = this;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return _error(callback, errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (typeof type !== 'string') {\n        return _error(callback, errcode(new Error(\"Invalid key type '\".concat(type, \"'\")), 'ERR_INVALID_KEY_TYPE'));\n      }\n\n      if (!Number.isSafeInteger(size)) {\n        return _error(callback, errcode(new Error(\"Invalid key size '\".concat(size, \"'\")), 'ERR_INVALID_KEY_SIZE'));\n      }\n\n      var dsname = DsName(name);\n      self.store.has(dsname, function (err, exists) {\n        if (err) return _error(callback, err);\n        if (exists) return _error(callback, errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS'));\n\n        switch (type.toLowerCase()) {\n          case 'rsa':\n            if (size < 2048) {\n              return _error(callback, errcode(new Error(\"Invalid RSA key size \".concat(size)), 'ERR_INVALID_KEY_SIZE'));\n            }\n\n            break;\n\n          default:\n            break;\n        }\n\n        crypto.keys.generateKeyPair(type, size, function (err, keypair) {\n          if (err) return _error(callback, err);\n          keypair.id(function (err, kid) {\n            if (err) return _error(callback, err);\n            keypair.export(_this._(), function (err, pem) {\n              if (err) return _error(callback, err);\n              var keyInfo = {\n                name: name,\n                id: kid\n              };\n              var batch = self.store.batch();\n              batch.put(dsname, pem);\n              batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n              batch.commit(function (err) {\n                if (err) return _error(callback, err);\n                callback(null, keyInfo);\n              });\n            });\n          });\n        });\n      });\n    }\n    /**\n     * List all the keys.\n     *\n     * @param {function(Error, KeyInfo[])} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"listKeys\",\n    value: function listKeys(callback) {\n      var self = this;\n      var query = {\n        prefix: infoPrefix\n      };\n      pull(self.store.query(query), collect(function (err, res) {\n        if (err) return _error(callback, err);\n        var info = res.map(function (r) {\n          return JSON.parse(r.value);\n        });\n        callback(null, info);\n      }));\n    }\n    /**\n     * Find a key by it's id.\n     *\n     * @param {string} id - The universally unique key identifier.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"findKeyById\",\n    value: function findKeyById(id, callback) {\n      this.listKeys(function (err, keys) {\n        if (err) return _error(callback, err);\n        var key = keys.find(function (k) {\n          return k.id === id;\n        });\n        callback(null, key);\n      });\n    }\n    /**\n     * Find a key by it's name.\n     *\n     * @param {string} name - The local key name.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"findKeyByName\",\n    value: function findKeyByName(name, callback) {\n      if (!validateKeyName(name)) {\n        return _error(callback, errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      var dsname = DsInfoName(name);\n      this.store.get(dsname, function (err, res) {\n        if (err) {\n          return _error(callback, errcode(new Error(\"Key '\".concat(name, \"' does not exist. \").concat(err.message)), 'ERR_KEY_NOT_FOUND'));\n        }\n\n        callback(null, JSON.parse(res.toString()));\n      });\n    }\n    /**\n     * Remove an existing key.\n     *\n     * @param {string} name - The local key name; must already exist.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"removeKey\",\n    value: function removeKey(name, callback) {\n      var self = this;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return _error(callback, errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      var dsname = DsName(name);\n      self.findKeyByName(name, function (err, keyinfo) {\n        if (err) return _error(callback, err);\n        var batch = self.store.batch();\n        batch.delete(dsname);\n        batch.delete(DsInfoName(name));\n        batch.commit(function (err) {\n          if (err) return _error(callback, err);\n          callback(null, keyinfo);\n        });\n      });\n    }\n    /**\n     * Rename a key\n     *\n     * @param {string} oldName - The old local key name; must already exist.\n     * @param {string} newName - The new local key name; must not already exist.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"renameKey\",\n    value: function renameKey(oldName, newName, callback) {\n      var self = this;\n\n      if (!validateKeyName(oldName) || oldName === 'self') {\n        return _error(callback, errcode(new Error(\"Invalid old key name '\".concat(oldName, \"'\")), 'ERR_OLD_KEY_NAME_INVALID'));\n      }\n\n      if (!validateKeyName(newName) || newName === 'self') {\n        return _error(callback, errcode(new Error(\"Invalid new key name '\".concat(newName, \"'\")), 'ERR_NEW_KEY_NAME_INVALID'));\n      }\n\n      var oldDsname = DsName(oldName);\n      var newDsname = DsName(newName);\n      var oldInfoName = DsInfoName(oldName);\n      var newInfoName = DsInfoName(newName);\n      this.store.get(oldDsname, function (err, res) {\n        if (err) {\n          return _error(callback, errcode(new Error(\"Key '\".concat(oldName, \"' does not exist. \").concat(err.message)), 'ERR_KEY_NOT_FOUND'));\n        }\n\n        var pem = res.toString();\n        self.store.has(newDsname, function (err, exists) {\n          if (err) return _error(callback, err);\n          if (exists) return _error(callback, errcode(new Error(\"Key '\".concat(newName, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS'));\n          self.store.get(oldInfoName, function (err, res) {\n            if (err) return _error(callback, err);\n            var keyInfo = JSON.parse(res.toString());\n            keyInfo.name = newName;\n            var batch = self.store.batch();\n            batch.put(newDsname, pem);\n            batch.put(newInfoName, JSON.stringify(keyInfo));\n            batch.delete(oldDsname);\n            batch.delete(oldInfoName);\n            batch.commit(function (err) {\n              if (err) return _error(callback, err);\n              callback(null, keyInfo);\n            });\n          });\n        });\n      });\n    }\n    /**\n     * Export an existing key as a PEM encrypted PKCS #8 string\n     *\n     * @param {string} name - The local key name; must already exist.\n     * @param {string} password - The password\n     * @param {function(Error, string)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"exportKey\",\n    value: function exportKey(name, password, callback) {\n      var _this2 = this;\n\n      if (!validateKeyName(name)) {\n        return _error(callback, errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (!password) {\n        return _error(callback, errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'));\n      }\n\n      var dsname = DsName(name);\n      this.store.get(dsname, function (err, res) {\n        if (err) {\n          return _error(callback, errcode(new Error(\"Key '\".concat(name, \"' does not exist. \").concat(err.message)), 'ERR_KEY_NOT_FOUND'));\n        }\n\n        var pem = res.toString();\n        crypto.keys.import(pem, _this2._(), function (err, privateKey) {\n          if (err) return _error(callback, err);\n          privateKey.export(password, callback);\n        });\n      });\n    }\n    /**\n     * Import a new key from a PEM encoded PKCS #8 string\n     *\n     * @param {string} name - The local key name; must not already exist.\n     * @param {string} pem - The PEM encoded PKCS #8 string\n     * @param {string} password - The password.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"importKey\",\n    value: function importKey(name, pem, password, callback) {\n      var _this3 = this;\n\n      var self = this;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return _error(callback, errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (!pem) {\n        return _error(callback, 'PEM encoded key is required');\n      }\n\n      var dsname = DsName(name);\n      self.store.has(dsname, function (err, exists) {\n        if (err) return _error(callback, err);\n        if (exists) return _error(callback, errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS'));\n        crypto.keys.import(pem, password, function (err, privateKey) {\n          if (err) return _error(callback, errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'));\n          privateKey.id(function (err, kid) {\n            if (err) return _error(callback, err);\n            privateKey.export(_this3._(), function (err, pem) {\n              if (err) return _error(callback, err);\n              var keyInfo = {\n                name: name,\n                id: kid\n              };\n              var batch = self.store.batch();\n              batch.put(dsname, pem);\n              batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n              batch.commit(function (err) {\n                if (err) return _error(callback, err);\n                callback(null, keyInfo);\n              });\n            });\n          });\n        });\n      });\n    }\n  }, {\n    key: \"importPeer\",\n    value: function importPeer(name, peer, callback) {\n      var _this4 = this;\n\n      var self = this;\n\n      if (!validateKeyName(name)) {\n        return _error(callback, errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      if (!peer || !peer.privKey) {\n        return _error(callback, errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'));\n      }\n\n      var privateKey = peer.privKey;\n      var dsname = DsName(name);\n      self.store.has(dsname, function (err, exists) {\n        if (err) return _error(callback, err);\n        if (exists) return _error(callback, errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS'));\n        privateKey.id(function (err, kid) {\n          if (err) return _error(callback, err);\n          privateKey.export(_this4._(), function (err, pem) {\n            if (err) return _error(callback, err);\n            var keyInfo = {\n              name: name,\n              id: kid\n            };\n            var batch = self.store.batch();\n            batch.put(dsname, pem);\n            batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n            batch.commit(function (err) {\n              if (err) return _error(callback, err);\n              callback(null, keyInfo);\n            });\n          });\n        });\n      });\n    }\n    /**\n     * Gets the private key as PEM encoded PKCS #8 string.\n     *\n     * @param {string} name\n     * @param {function(Error, string)} callback\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_getPrivateKey\",\n    value: function _getPrivateKey(name, callback) {\n      if (!validateKeyName(name)) {\n        return _error(callback, errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME'));\n      }\n\n      this.store.get(DsName(name), function (err, res) {\n        if (err) {\n          return _error(callback, errcode(new Error(\"Key '\".concat(name, \"' does not exist. \").concat(err.message)), 'ERR_KEY_NOT_FOUND'));\n        }\n\n        callback(null, res.toString());\n      });\n    }\n  }], [{\n    key: \"generateOptions\",\n    value: function generateOptions() {\n      var options = Object.assign({}, defaultOptions);\n      var saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n\n      options.dek.salt = crypto.randomBytes(saltLength).toString('base64');\n      return options;\n    }\n    /**\n     * Gets an object that can encrypt/decrypt protected data.\n     * The default options for a keychain.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return defaultOptions;\n    }\n  }]);\n\n  return Keychain;\n}();\n\nmodule.exports = Keychain;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-keychain/src/keychain.js"],"names":["sanitize","require","mergeOptions","crypto","DS","collect","pull","CMS","errcode","keyPrefix","infoPrefix","NIST","minKeyLength","minSaltLength","minIterationCount","defaultOptions","dek","keyLength","iterationCount","salt","hash","validateKeyName","name","trim","_error","callback","err","min","max","delay","Math","random","setTimeout","DsName","Key","DsInfoName","Keychain","store","options","Error","opts","passPhrase","length","pbkdf2","Object","defineProperty","value","type","size","self","Number","isSafeInteger","dsname","has","exists","toLowerCase","keys","generateKeyPair","keypair","id","kid","export","_","pem","keyInfo","batch","put","JSON","stringify","commit","query","prefix","res","info","map","r","parse","listKeys","key","find","k","get","message","toString","findKeyByName","keyinfo","delete","oldName","newName","oldDsname","newDsname","oldInfoName","newInfoName","password","import","privateKey","peer","privKey","assign","saltLength","ceil","randomBytes","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict'\n\nconst sanitize = require('sanitize-filename')\nconst mergeOptions = require('merge-options')\nconst crypto = require('libp2p-crypto')\nconst DS = require('interface-datastore')\nconst collect = require('pull-stream/sinks/collect')\nconst pull = require('pull-stream/pull')\nconst CMS = require('./cms')\nconst errcode = require('err-code')\n\nconst keyPrefix = '/pkcs8/'\nconst infoPrefix = '/info/'\n\n// NIST SP 800-132\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n}\n\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n}\n\nfunction validateKeyName (name) {\n  if (!name) return false\n  if (typeof name !== 'string') return false\n  return name === sanitize(name.trim())\n}\n\n/**\n * Returns an error to the caller, after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {function(Error)} callback - The caller\n * @param {string | Error} err - The error\n * @returns {undefined}\n * @private\n */\nfunction _error (callback, err) {\n  const min = 200\n  const max = 1000\n  const delay = Math.random() * (max - min) + min\n\n  setTimeout(callback, delay, err, null)\n}\n\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\nfunction DsName (name) {\n  return new DS.Key(keyPrefix + name)\n}\n\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\nfunction DsInfoName (name) {\n  return new DS.Key(infoPrefix + name)\n}\n\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n *\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\nclass Keychain {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {DS} store - where the key are.\n   * @param {object} options - ???\n   */\n  constructor (store, options) {\n    if (!store) {\n      throw new Error('store is required')\n    }\n    this.store = store\n\n    const opts = mergeOptions(defaultOptions, options)\n\n    // Enforce NIST SP 800-132\n    if (!opts.passPhrase || opts.passPhrase.length < 20) {\n      throw new Error('passPhrase must be least 20 characters')\n    }\n    if (opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`)\n    }\n    if (opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`)\n    }\n    if (opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`)\n    }\n\n    // Create the derived encrypting key\n    const dek = crypto.pbkdf2(\n      opts.passPhrase,\n      opts.dek.salt,\n      opts.dek.iterationCount,\n      opts.dek.keyLength,\n      opts.dek.hash)\n    Object.defineProperty(this, '_', { value: () => dek })\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n  get cms () {\n    return new CMS(this)\n  }\n\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {object}\n   */\n  static generateOptions () {\n    const options = Object.assign({}, defaultOptions)\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3 // no base64 padding\n    options.dek.salt = crypto.randomBytes(saltLength).toString('base64')\n    return options\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {object}\n   */\n  static get options () {\n    return defaultOptions\n  }\n\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {int} size - The key size in bits.\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n  createKey (name, type, size, callback) {\n    const self = this\n\n    if (!validateKeyName(name) || name === 'self') {\n      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    if (typeof type !== 'string') {\n      return _error(callback, errcode(new Error(`Invalid key type '${type}'`), 'ERR_INVALID_KEY_TYPE'))\n    }\n\n    if (!Number.isSafeInteger(size)) {\n      return _error(callback, errcode(new Error(`Invalid key size '${size}'`), 'ERR_INVALID_KEY_SIZE'))\n    }\n\n    const dsname = DsName(name)\n    self.store.has(dsname, (err, exists) => {\n      if (err) return _error(callback, err)\n      if (exists) return _error(callback, errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n      switch (type.toLowerCase()) {\n        case 'rsa':\n          if (size < 2048) {\n            return _error(callback, errcode(new Error(`Invalid RSA key size ${size}`), 'ERR_INVALID_KEY_SIZE'))\n          }\n          break\n        default:\n          break\n      }\n\n      crypto.keys.generateKeyPair(type, size, (err, keypair) => {\n        if (err) return _error(callback, err)\n        keypair.id((err, kid) => {\n          if (err) return _error(callback, err)\n          keypair.export(this._(), (err, pem) => {\n            if (err) return _error(callback, err)\n            const keyInfo = {\n              name: name,\n              id: kid\n            }\n            const batch = self.store.batch()\n            batch.put(dsname, pem)\n            batch.put(DsInfoName(name), JSON.stringify(keyInfo))\n            batch.commit((err) => {\n              if (err) return _error(callback, err)\n\n              callback(null, keyInfo)\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * List all the keys.\n   *\n   * @param {function(Error, KeyInfo[])} callback\n   * @returns {undefined}\n   */\n  listKeys (callback) {\n    const self = this\n    const query = {\n      prefix: infoPrefix\n    }\n    pull(\n      self.store.query(query),\n      collect((err, res) => {\n        if (err) return _error(callback, err)\n\n        const info = res.map(r => JSON.parse(r.value))\n        callback(null, info)\n      })\n    )\n  }\n\n  /**\n   * Find a key by it's id.\n   *\n   * @param {string} id - The universally unique key identifier.\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n  findKeyById (id, callback) {\n    this.listKeys((err, keys) => {\n      if (err) return _error(callback, err)\n\n      const key = keys.find((k) => k.id === id)\n      callback(null, key)\n    })\n  }\n\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n  findKeyByName (name, callback) {\n    if (!validateKeyName(name)) {\n      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    const dsname = DsInfoName(name)\n    this.store.get(dsname, (err, res) => {\n      if (err) {\n        return _error(callback, errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n      }\n\n      callback(null, JSON.parse(res.toString()))\n    })\n  }\n\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n  removeKey (name, callback) {\n    const self = this\n    if (!validateKeyName(name) || name === 'self') {\n      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    const dsname = DsName(name)\n    self.findKeyByName(name, (err, keyinfo) => {\n      if (err) return _error(callback, err)\n      const batch = self.store.batch()\n      batch.delete(dsname)\n      batch.delete(DsInfoName(name))\n      batch.commit((err) => {\n        if (err) return _error(callback, err)\n        callback(null, keyinfo)\n      })\n    })\n  }\n\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n  renameKey (oldName, newName, callback) {\n    const self = this\n    if (!validateKeyName(oldName) || oldName === 'self') {\n      return _error(callback, errcode(new Error(`Invalid old key name '${oldName}'`), 'ERR_OLD_KEY_NAME_INVALID'))\n    }\n    if (!validateKeyName(newName) || newName === 'self') {\n      return _error(callback, errcode(new Error(`Invalid new key name '${newName}'`), 'ERR_NEW_KEY_NAME_INVALID'))\n    }\n    const oldDsname = DsName(oldName)\n    const newDsname = DsName(newName)\n    const oldInfoName = DsInfoName(oldName)\n    const newInfoName = DsInfoName(newName)\n    this.store.get(oldDsname, (err, res) => {\n      if (err) {\n        return _error(callback, errcode(new Error(`Key '${oldName}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n      }\n      const pem = res.toString()\n      self.store.has(newDsname, (err, exists) => {\n        if (err) return _error(callback, err)\n        if (exists) return _error(callback, errcode(new Error(`Key '${newName}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n        self.store.get(oldInfoName, (err, res) => {\n          if (err) return _error(callback, err)\n\n          const keyInfo = JSON.parse(res.toString())\n          keyInfo.name = newName\n          const batch = self.store.batch()\n          batch.put(newDsname, pem)\n          batch.put(newInfoName, JSON.stringify(keyInfo))\n          batch.delete(oldDsname)\n          batch.delete(oldInfoName)\n          batch.commit((err) => {\n            if (err) return _error(callback, err)\n            callback(null, keyInfo)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @param {string} password - The password\n   * @param {function(Error, string)} callback\n   * @returns {undefined}\n   */\n  exportKey (name, password, callback) {\n    if (!validateKeyName(name)) {\n      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!password) {\n      return _error(callback, errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'))\n    }\n\n    const dsname = DsName(name)\n    this.store.get(dsname, (err, res) => {\n      if (err) {\n        return _error(callback, errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n      }\n      const pem = res.toString()\n      crypto.keys.import(pem, this._(), (err, privateKey) => {\n        if (err) return _error(callback, err)\n        privateKey.export(password, callback)\n      })\n    })\n  }\n\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n  importKey (name, pem, password, callback) {\n    const self = this\n    if (!validateKeyName(name) || name === 'self') {\n      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!pem) {\n      return _error(callback, 'PEM encoded key is required')\n    }\n    const dsname = DsName(name)\n    self.store.has(dsname, (err, exists) => {\n      if (err) return _error(callback, err)\n      if (exists) return _error(callback, errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n      crypto.keys.import(pem, password, (err, privateKey) => {\n        if (err) return _error(callback, errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'))\n        privateKey.id((err, kid) => {\n          if (err) return _error(callback, err)\n          privateKey.export(this._(), (err, pem) => {\n            if (err) return _error(callback, err)\n            const keyInfo = {\n              name: name,\n              id: kid\n            }\n            const batch = self.store.batch()\n            batch.put(dsname, pem)\n            batch.put(DsInfoName(name), JSON.stringify(keyInfo))\n            batch.commit((err) => {\n              if (err) return _error(callback, err)\n\n              callback(null, keyInfo)\n            })\n          })\n        })\n      })\n    })\n  }\n\n  importPeer (name, peer, callback) {\n    const self = this\n    if (!validateKeyName(name)) {\n      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!peer || !peer.privKey) {\n      return _error(callback, errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'))\n    }\n\n    const privateKey = peer.privKey\n    const dsname = DsName(name)\n    self.store.has(dsname, (err, exists) => {\n      if (err) return _error(callback, err)\n      if (exists) return _error(callback, errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n      privateKey.id((err, kid) => {\n        if (err) return _error(callback, err)\n        privateKey.export(this._(), (err, pem) => {\n          if (err) return _error(callback, err)\n          const keyInfo = {\n            name: name,\n            id: kid\n          }\n          const batch = self.store.batch()\n          batch.put(dsname, pem)\n          batch.put(DsInfoName(name), JSON.stringify(keyInfo))\n          batch.commit((err) => {\n            if (err) return _error(callback, err)\n\n            callback(null, keyInfo)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string.\n   *\n   * @param {string} name\n   * @param {function(Error, string)} callback\n   * @returns {undefined}\n   * @private\n   */\n  _getPrivateKey (name, callback) {\n    if (!validateKeyName(name)) {\n      return _error(callback, errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    this.store.get(DsName(name), (err, res) => {\n      if (err) {\n        return _error(callback, errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n      }\n      callback(null, res.toString())\n    })\n  }\n}\n\nmodule.exports = Keychain\n"]},"metadata":{},"sourceType":"script"}