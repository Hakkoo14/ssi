{"ast":null,"code":"'use strict';\n\nvar multihashes = require('multihashes');\n\nvar CID = require('cids');\n\nvar protobuf = require('protons');\n\nvar fnv1a = require('fnv1a');\n\nvar varint = require('varint');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar multicodec = require('multicodec');\n\nvar someSeries = require('async/someSeries');\n\nvar eachOfSeries = require('async/eachOfSeries');\n\nvar pbSchema = require('./pin.proto');\n\nvar emptyKeyHash = 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n';\nvar emptyKey = multihashes.fromB58String(emptyKeyHash);\nvar defaultFanout = 256;\nvar maxItems = 8192;\nvar pb = protobuf(pbSchema);\n\nfunction toB58String(hash) {\n  return new CID(hash).toBaseEncodedString();\n}\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  var rootData = rootNode.Data;\n  var hdrLength = varint.decode(rootData);\n  var vBytes = varint.decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  var hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  var header = pb.Set.decode(hdrSlice);\n\n  if (header.version !== 1) {\n    throw new Error(\"Unsupported Set version: \".concat(header.version));\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n\nfunction hash(seed, key) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32LE(seed, 0);\n  var data = Buffer.concat([buf, Buffer.from(toB58String(key))]);\n  return fnv1a(data.toString('binary'));\n}\n\nexports = module.exports = function (dag) {\n  var pinSet = {\n    // should this be part of `object` API?\n    hasDescendant: function hasDescendant(root, childhash, callback) {\n      var seen = {};\n\n      if (CID.isCID(childhash) || Buffer.isBuffer(childhash)) {\n        childhash = toB58String(childhash);\n      }\n\n      return searchChildren(root, callback);\n\n      function searchChildren(root, cb) {\n        someSeries(root.Links, function (link, done) {\n          var cid = link.Hash;\n          var bs58Link = toB58String(cid);\n\n          if (bs58Link === childhash) {\n            return done(null, true);\n          }\n\n          if (bs58Link in seen) {\n            return done(null, false);\n          }\n\n          seen[bs58Link] = true;\n          dag.get(cid, '', {\n            preload: false\n          }, function (err, res) {\n            if (err) {\n              return done(err);\n            }\n\n            searchChildren(res.value, done);\n          });\n        }, cb);\n      }\n    },\n    storeSet: function storeSet(keys, callback) {\n      var pins = keys.map(function (key) {\n        if (typeof key === 'string' || Buffer.isBuffer(key)) {\n          key = new CID(key);\n        }\n\n        return {\n          key: key,\n          data: null\n        };\n      });\n      pinSet.storeItems(pins, function (err, rootNode) {\n        if (err) {\n          return callback(err);\n        }\n\n        dag.put(rootNode, {\n          version: 0,\n          format: multicodec.DAG_PB,\n          hashAlg: multicodec.SHA2_256,\n          preload: false\n        }, function (err, cid) {\n          if (err) {\n            return callback(err, cid);\n          }\n\n          callback(null, {\n            node: rootNode,\n            cid: cid\n          });\n        });\n      });\n    },\n    storeItems: function storeItems(items, callback) {\n      return storePins(items, 0, callback);\n\n      function storePins(pins, depth, storePinsCb) {\n        var pbHeader = pb.Set.encode({\n          version: 1,\n          fanout: defaultFanout,\n          seed: depth\n        });\n        var headerBuf = Buffer.concat([Buffer.from(varint.encode(pbHeader.length)), pbHeader]);\n        var fanoutLinks = [];\n\n        for (var i = 0; i < defaultFanout; i++) {\n          fanoutLinks.push(new DAGLink('', 1, emptyKey));\n        }\n\n        if (pins.length <= maxItems) {\n          var nodes = pins.map(function (item) {\n            return {\n              link: new DAGLink('', 1, item.key),\n              data: item.data || Buffer.alloc(0)\n            };\n          }) // sorting makes any ordering of `pins` produce the same DAGNode\n          .sort(function (a, b) {\n            return Buffer.compare(a.link.Hash.buffer, b.link.Hash.buffer);\n          });\n          var rootLinks = fanoutLinks.concat(nodes.map(function (item) {\n            return item.link;\n          }));\n          var rootData = Buffer.concat([headerBuf].concat(nodes.map(function (item) {\n            return item.data;\n          })));\n          var rootNode;\n\n          try {\n            rootNode = DAGNode.create(rootData, rootLinks);\n          } catch (err) {\n            return storePinsCb(err);\n          }\n\n          return storePinsCb(null, rootNode);\n        } else {\n          // If the array of pins is > maxItems, we:\n          //  - distribute the pins among `defaultFanout` bins\n          //    - create a DAGNode for each bin\n          //      - add each pin as a DAGLink to that bin\n          //  - create a root DAGNode\n          //    - add each bin as a DAGLink\n          //  - send that root DAGNode via callback\n          // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n          // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n          var bins = pins.reduce(function (bins, pin) {\n            var n = hash(depth, pin.key) % defaultFanout;\n            bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n            return bins;\n          }, {});\n          eachOfSeries(bins, function (bin, idx, eachCb) {\n            storePins(bin, depth + 1, function (err, child) {\n              return storeChild(err, child, idx, eachCb);\n            });\n          }, function (err) {\n            if (err) {\n              return storePinsCb(err);\n            }\n\n            var rootNode;\n\n            try {\n              rootNode = DAGNode.create(headerBuf, fanoutLinks);\n            } catch (err) {\n              return storePinsCb(err);\n            }\n\n            return storePinsCb(null, rootNode);\n          });\n        }\n\n        function storeChild(err, child, binIdx, cb) {\n          if (err) {\n            return cb(err);\n          }\n\n          var opts = {\n            version: 0,\n            format: multicodec.DAG_PB,\n            hashAlg: multicodec.SHA2_256,\n            preload: false\n          };\n          dag.put(child, opts, function (err, cid) {\n            if (err) {\n              return cb(err);\n            }\n\n            fanoutLinks[binIdx] = new DAGLink('', child.size, cid);\n            cb(null);\n          });\n        }\n      }\n    },\n    loadSet: function loadSet(rootNode, name, callback) {\n      var link = rootNode.Links.find(function (l) {\n        return l.Name === name;\n      });\n\n      if (!link) {\n        return callback(new Error('No link found with name ' + name));\n      }\n\n      dag.get(link.Hash, '', {\n        preload: false\n      }, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        var keys = [];\n\n        var step = function step(link) {\n          return keys.push(link.Hash.buffer);\n        };\n\n        pinSet.walkItems(res.value, step, function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          return callback(null, keys);\n        });\n      });\n    },\n    walkItems: function walkItems(node, step, callback) {\n      var pbh;\n\n      try {\n        pbh = readHeader(node);\n      } catch (err) {\n        return callback(err);\n      }\n\n      eachOfSeries(node.Links, function (link, idx, eachCb) {\n        if (idx < pbh.header.fanout) {\n          // the first pbh.header.fanout links are fanout bins\n          // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n          var linkHash = link.Hash.buffer;\n\n          if (!emptyKey.equals(linkHash)) {\n            // walk the links of this fanout bin\n            return dag.get(linkHash, '', {\n              preload: false\n            }, function (err, res) {\n              if (err) {\n                return eachCb(err);\n              }\n\n              pinSet.walkItems(res.value, step, eachCb);\n            });\n          }\n        } else {\n          // otherwise, the link is a pin\n          step(link, idx, pbh.data);\n        }\n\n        eachCb(null);\n      }, callback);\n    }\n  };\n  return pinSet;\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs/src/core/components/pin-set.js"],"names":["multihashes","require","CID","protobuf","fnv1a","varint","DAGNode","DAGLink","multicodec","someSeries","eachOfSeries","pbSchema","emptyKeyHash","emptyKey","fromB58String","defaultFanout","maxItems","pb","toB58String","hash","toBaseEncodedString","readHeader","rootNode","rootData","Data","hdrLength","decode","vBytes","bytes","Error","length","hdrSlice","slice","header","Set","version","fanout","Links","data","seed","key","buf","Buffer","alloc","writeUInt32LE","concat","from","toString","exports","module","dag","pinSet","hasDescendant","root","childhash","callback","seen","isCID","isBuffer","searchChildren","cb","link","done","cid","Hash","bs58Link","get","preload","err","res","value","storeSet","keys","pins","map","storeItems","put","format","DAG_PB","hashAlg","SHA2_256","node","items","storePins","depth","storePinsCb","pbHeader","encode","headerBuf","fanoutLinks","i","push","nodes","item","sort","a","b","compare","buffer","rootLinks","create","bins","reduce","pin","n","bin","idx","eachCb","child","storeChild","binIdx","opts","size","loadSet","name","find","l","Name","step","walkItems","pbh","linkHash","equals"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multihashes = require('multihashes')\nconst CID = require('cids')\nconst protobuf = require('protons')\nconst fnv1a = require('fnv1a')\nconst varint = require('varint')\nconst { DAGNode, DAGLink } = require('ipld-dag-pb')\nconst multicodec = require('multicodec')\nconst someSeries = require('async/someSeries')\nconst eachOfSeries = require('async/eachOfSeries')\n\nconst pbSchema = require('./pin.proto')\n\nconst emptyKeyHash = 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'\nconst emptyKey = multihashes.fromB58String(emptyKeyHash)\nconst defaultFanout = 256\nconst maxItems = 8192\nconst pb = protobuf(pbSchema)\n\nfunction toB58String (hash) {\n  return new CID(hash).toBaseEncodedString()\n}\n\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = pb.Set.decode(hdrSlice)\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\nfunction hash (seed, key) {\n  const buf = Buffer.alloc(4)\n  buf.writeUInt32LE(seed, 0)\n  const data = Buffer.concat([\n    buf, Buffer.from(toB58String(key))\n  ])\n  return fnv1a(data.toString('binary'))\n}\n\nexports = module.exports = function (dag) {\n  const pinSet = {\n    // should this be part of `object` API?\n    hasDescendant: (root, childhash, callback) => {\n      const seen = {}\n\n      if (CID.isCID(childhash) || Buffer.isBuffer(childhash)) {\n        childhash = toB58String(childhash)\n      }\n\n      return searchChildren(root, callback)\n\n      function searchChildren (root, cb) {\n        someSeries(root.Links, (link, done) => {\n          const cid = link.Hash\n          const bs58Link = toB58String(cid)\n\n          if (bs58Link === childhash) {\n            return done(null, true)\n          }\n\n          if (bs58Link in seen) {\n            return done(null, false)\n          }\n\n          seen[bs58Link] = true\n\n          dag.get(cid, '', { preload: false }, (err, res) => {\n            if (err) {\n              return done(err)\n            }\n\n            searchChildren(res.value, done)\n          })\n        }, cb)\n      }\n    },\n\n    storeSet: (keys, callback) => {\n      const pins = keys.map(key => {\n        if (typeof key === 'string' || Buffer.isBuffer(key)) {\n          key = new CID(key)\n        }\n\n        return {\n          key: key,\n          data: null\n        }\n      })\n\n      pinSet.storeItems(pins, (err, rootNode) => {\n        if (err) { return callback(err) }\n\n        dag.put(rootNode, {\n          version: 0,\n          format: multicodec.DAG_PB,\n          hashAlg: multicodec.SHA2_256,\n          preload: false\n        }, (err, cid) => {\n          if (err) { return callback(err, cid) }\n          callback(null, { node: rootNode, cid })\n        })\n      })\n    },\n\n    storeItems: (items, callback) => {\n      return storePins(items, 0, callback)\n\n      function storePins (pins, depth, storePinsCb) {\n        const pbHeader = pb.Set.encode({\n          version: 1,\n          fanout: defaultFanout,\n          seed: depth\n        })\n        const headerBuf = Buffer.concat([\n          Buffer.from(varint.encode(pbHeader.length)), pbHeader\n        ])\n        const fanoutLinks = []\n        for (let i = 0; i < defaultFanout; i++) {\n          fanoutLinks.push(new DAGLink('', 1, emptyKey))\n        }\n\n        if (pins.length <= maxItems) {\n          const nodes = pins\n            .map(item => {\n              return ({\n                link: new DAGLink('', 1, item.key),\n                data: item.data || Buffer.alloc(0)\n              })\n            })\n            // sorting makes any ordering of `pins` produce the same DAGNode\n            .sort((a, b) => Buffer.compare(a.link.Hash.buffer, b.link.Hash.buffer))\n\n          const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n          const rootData = Buffer.concat(\n            [headerBuf].concat(nodes.map(item => item.data))\n          )\n\n          let rootNode\n\n          try {\n            rootNode = DAGNode.create(rootData, rootLinks)\n          } catch (err) {\n            return storePinsCb(err)\n          }\n\n          return storePinsCb(null, rootNode)\n        } else {\n          // If the array of pins is > maxItems, we:\n          //  - distribute the pins among `defaultFanout` bins\n          //    - create a DAGNode for each bin\n          //      - add each pin as a DAGLink to that bin\n          //  - create a root DAGNode\n          //    - add each bin as a DAGLink\n          //  - send that root DAGNode via callback\n          // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n          // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n          const bins = pins.reduce((bins, pin) => {\n            const n = hash(depth, pin.key) % defaultFanout\n            bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n            return bins\n          }, {})\n\n          eachOfSeries(bins, (bin, idx, eachCb) => {\n            storePins(\n              bin,\n              depth + 1,\n              (err, child) => storeChild(err, child, idx, eachCb)\n            )\n          }, err => {\n            if (err) { return storePinsCb(err) }\n\n            let rootNode\n\n            try {\n              rootNode = DAGNode.create(headerBuf, fanoutLinks)\n            } catch (err) {\n              return storePinsCb(err)\n            }\n\n            return storePinsCb(null, rootNode)\n          })\n        }\n\n        function storeChild (err, child, binIdx, cb) {\n          if (err) { return cb(err) }\n\n          const opts = {\n            version: 0,\n            format: multicodec.DAG_PB,\n            hashAlg: multicodec.SHA2_256,\n            preload: false\n          }\n\n          dag.put(child, opts, (err, cid) => {\n            if (err) { return cb(err) }\n            fanoutLinks[binIdx] = new DAGLink('', child.size, cid)\n            cb(null)\n          })\n        }\n      }\n    },\n\n    loadSet: (rootNode, name, callback) => {\n      const link = rootNode.Links.find(l => l.Name === name)\n      if (!link) {\n        return callback(new Error('No link found with name ' + name))\n      }\n\n      dag.get(link.Hash, '', { preload: false }, (err, res) => {\n        if (err) { return callback(err) }\n        const keys = []\n        const step = link => keys.push(link.Hash.buffer)\n        pinSet.walkItems(res.value, step, err => {\n          if (err) { return callback(err) }\n          return callback(null, keys)\n        })\n      })\n    },\n\n    walkItems: (node, step, callback) => {\n      let pbh\n      try {\n        pbh = readHeader(node)\n      } catch (err) {\n        return callback(err)\n      }\n\n      eachOfSeries(node.Links, (link, idx, eachCb) => {\n        if (idx < pbh.header.fanout) {\n          // the first pbh.header.fanout links are fanout bins\n          // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n          const linkHash = link.Hash.buffer\n\n          if (!emptyKey.equals(linkHash)) {\n            // walk the links of this fanout bin\n            return dag.get(linkHash, '', { preload: false }, (err, res) => {\n              if (err) { return eachCb(err) }\n              pinSet.walkItems(res.value, step, eachCb)\n            })\n          }\n        } else {\n          // otherwise, the link is a pin\n          step(link, idx, pbh.data)\n        }\n\n        eachCb(null)\n      }, callback)\n    }\n  }\n  return pinSet\n}\n"]},"metadata":{},"sourceType":"script"}