{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar each = require('async/each');\n\nvar whilst = require('async/whilst');\n\nvar Errors = require('interface-datastore').Errors;\n/* ::\nimport type {Key, Datastore, Callback, Batch, Query, QueryResult} from 'interface-datastore'\n*/\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\n\n\nvar TieredDatastore\n/* :: <Value> */\n= /*#__PURE__*/function () {\n  /* :: stores: Array<Datastore<Value>> */\n  function TieredDatastore(stores\n  /* : Array<Datastore<Value>> */\n  ) {\n    _classCallCheck(this, TieredDatastore);\n\n    this.stores = stores.slice();\n  }\n\n  _createClass(TieredDatastore, [{\n    key: \"open\",\n    value: function open(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.stores, function (store, cb) {\n        store.open(cb);\n      }, function (err) {\n        if (err) {\n          return callback(Errors.dbOpenFailedError());\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"put\",\n    value: function put(key\n    /* : Key */\n    , value\n    /* : Value */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.stores, function (store, cb) {\n        store.put(key, value, cb);\n      }, function (err) {\n        if (err) {\n          return callback(Errors.dbWriteFailedError());\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(key\n    /* : Key */\n    , callback\n    /* : Callback<Value> */\n    )\n    /* : void */\n    {\n      var _this = this;\n\n      var storeLength = this.stores.length;\n      var done = false;\n      var i = 0;\n      whilst(function () {\n        return !done && i < storeLength;\n      }, function (cb) {\n        var store = _this.stores[i++];\n        store.get(key, function (err, res) {\n          if (err == null) {\n            done = true;\n            return cb(null, res);\n          }\n\n          cb();\n        });\n      }, function (err, res) {\n        if (err || !res) {\n          return callback(Errors.notFoundError());\n        }\n\n        callback(null, res);\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(key\n    /* : Key */\n    , callback\n    /* : Callback<bool> */\n    )\n    /* : void */\n    {\n      var _this2 = this;\n\n      var storeLength = this.stores.length;\n      var done = false;\n      var i = 0;\n      whilst(function () {\n        return !done && i < storeLength;\n      }, function (cb) {\n        var store = _this2.stores[i++];\n        store.has(key, function (err, exists) {\n          if (err == null) {\n            done = true;\n            return cb(null, exists);\n          }\n\n          cb();\n        });\n      }, callback);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key\n    /* : Key */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.stores, function (store, cb) {\n        store.delete(key, cb);\n      }, function (err) {\n        if (err) {\n          return callback(Errors.dbDeleteFailedError());\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.stores, function (store, cb) {\n        store.close(cb);\n      }, callback);\n    }\n  }, {\n    key: \"batch\",\n    value: function batch()\n    /* : Batch<Value> */\n    {\n      var batches = this.stores.map(function (store) {\n        return store.batch();\n      });\n      return {\n        put: function put(key\n        /* : Key */\n        , value\n        /* : Value */\n        )\n        /* : void */\n        {\n          batches.forEach(function (b) {\n            return b.put(key, value);\n          });\n        },\n        delete: function _delete(key\n        /* : Key */\n        )\n        /* : void */\n        {\n          batches.forEach(function (b) {\n            return b.delete(key);\n          });\n        },\n        commit: function commit(callback\n        /* : Callback<void> */\n        )\n        /* : void */\n        {\n          each(batches, function (b, cb) {\n            b.commit(cb);\n          }, callback);\n        }\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q\n    /* : Query<Value> */\n    )\n    /* : QueryResult<Value> */\n    {\n      return this.stores[this.stores.length - 1].query(q);\n    }\n  }]);\n\n  return TieredDatastore;\n}();\n\nmodule.exports = TieredDatastore;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/datastore-core/src/tiered.js"],"names":["each","require","whilst","Errors","TieredDatastore","stores","slice","callback","store","cb","open","err","dbOpenFailedError","key","value","put","dbWriteFailedError","storeLength","length","done","i","get","res","notFoundError","has","exists","delete","dbDeleteFailedError","close","batches","map","batch","forEach","b","commit","q","query","module","exports"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\nconst each = require('async/each')\nconst whilst = require('async/whilst')\nconst Errors = require('interface-datastore').Errors\n\n/* ::\nimport type {Key, Datastore, Callback, Batch, Query, QueryResult} from 'interface-datastore'\n*/\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nclass TieredDatastore /* :: <Value> */ {\n  /* :: stores: Array<Datastore<Value>> */\n\n  constructor (stores /* : Array<Datastore<Value>> */) {\n    this.stores = stores.slice()\n  }\n\n  open (callback /* : Callback<void> */) /* : void */ {\n    each(this.stores, (store, cb) => {\n      store.open(cb)\n    }, (err) => {\n      if (err) {\n        return callback(Errors.dbOpenFailedError())\n      }\n      callback()\n    })\n  }\n\n  put (key /* : Key */, value /* : Value */, callback /* : Callback<void> */) /* : void */ {\n    each(this.stores, (store, cb) => {\n      store.put(key, value, cb)\n    }, (err) => {\n      if (err) {\n        return callback(Errors.dbWriteFailedError())\n      }\n      callback()\n    })\n  }\n\n  get (key /* : Key */, callback /* : Callback<Value> */) /* : void */ {\n    const storeLength = this.stores.length\n    let done = false\n    let i = 0\n    whilst(() => !done && i < storeLength, cb => {\n      const store = this.stores[i++]\n      store.get(key, (err, res) => {\n        if (err == null) {\n          done = true\n          return cb(null, res)\n        }\n        cb()\n      })\n    }, (err, res) => {\n      if (err || !res) {\n        return callback(Errors.notFoundError())\n      }\n      callback(null, res)\n    })\n  }\n\n  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {\n    const storeLength = this.stores.length\n    let done = false\n    let i = 0\n    whilst(() => !done && i < storeLength, cb => {\n      const store = this.stores[i++]\n      store.has(key, (err, exists) => {\n        if (err == null) {\n          done = true\n          return cb(null, exists)\n        }\n        cb()\n      })\n    }, callback)\n  }\n\n  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {\n    each(this.stores, (store, cb) => {\n      store.delete(key, cb)\n    }, (err) => {\n      if (err) {\n        return callback(Errors.dbDeleteFailedError())\n      }\n      callback()\n    })\n  }\n\n  close (callback /* : Callback<void> */) /* : void */ {\n    each(this.stores, (store, cb) => {\n      store.close(cb)\n    }, callback)\n  }\n\n  batch () /* : Batch<Value> */ {\n    const batches = this.stores.map(store => store.batch())\n\n    return {\n      put: (key /* : Key */, value /* : Value */) /* : void */ => {\n        batches.forEach(b => b.put(key, value))\n      },\n      delete: (key /* : Key */) /* : void */ => {\n        batches.forEach(b => b.delete(key))\n      },\n      commit: (callback /* : Callback<void> */) /* : void */ => {\n        each(batches, (b, cb) => {\n          b.commit(cb)\n        }, callback)\n      }\n    }\n  }\n\n  query (q /* : Query<Value> */) /* : QueryResult<Value> */ {\n    return this.stores[this.stores.length - 1].query(q)\n  }\n}\n\nmodule.exports = TieredDatastore\n"]},"metadata":{},"sourceType":"script"}