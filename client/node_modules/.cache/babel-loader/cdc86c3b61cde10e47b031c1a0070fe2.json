{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('./constants'),\n    FILE_SEPARATOR = _require.FILE_SEPARATOR;\n\nvar loadMfsRoot = require('./with-mfs-root');\n\nvar toPathComponents = require('./to-path-components');\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar errCode = require('err-code');\n\nvar IPFS_PREFIX = 'ipfs';\n\nvar toMfsPath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, path) {\n    var outputArray, paths, root;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            outputArray = Array.isArray(path);\n            paths = Array.isArray(path) ? path : [path];\n            _context2.next = 4;\n            return loadMfsRoot(context);\n\n          case 4:\n            root = _context2.sent;\n            paths = paths.map(function (path) {\n              path = (path || '').trim();\n              path = path.replace(/(\\/\\/+)/g, '/');\n\n              if (path.endsWith('/') && path.length > 1) {\n                path = path.substring(0, path.length - 1);\n              }\n\n              if (!path) {\n                throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n              }\n\n              if (path.substring(0, 1) !== FILE_SEPARATOR) {\n                throw errCode(new Error(\"paths must start with a leading \".concat(FILE_SEPARATOR)), 'ERR_INVALID_PATH');\n              }\n\n              if (path.substring(path.length - FILE_SEPARATOR.length) === FILE_SEPARATOR) {\n                path = path.substring(0, path.length - FILE_SEPARATOR.length);\n              }\n\n              var pathComponents = toPathComponents(path);\n\n              if (pathComponents[0] === IPFS_PREFIX) {\n                // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n                var _mfsDirectory;\n\n                if (pathComponents.length === 2) {\n                  _mfsDirectory = \"\".concat(FILE_SEPARATOR).concat(pathComponents.join(FILE_SEPARATOR));\n                } else {\n                  _mfsDirectory = \"\".concat(FILE_SEPARATOR).concat(pathComponents.slice(0, pathComponents.length - 1).join(FILE_SEPARATOR));\n                }\n\n                return {\n                  type: 'ipfs',\n                  depth: pathComponents.length - 2,\n                  mfsPath: \"\".concat(FILE_SEPARATOR).concat(pathComponents.join(FILE_SEPARATOR)),\n                  mfsDirectory: _mfsDirectory,\n                  parts: pathComponents,\n                  path: \"\".concat(FILE_SEPARATOR).concat(pathComponents.join(FILE_SEPARATOR)),\n                  name: pathComponents[pathComponents.length - 1]\n                };\n              }\n\n              var mfsPath = \"/\".concat(IPFS_PREFIX, \"/\").concat(root).concat(pathComponents.length ? '/' + pathComponents.join(FILE_SEPARATOR) : '');\n              var mfsDirectory = \"/\".concat(IPFS_PREFIX, \"/\").concat(root, \"/\").concat(pathComponents.slice(0, pathComponents.length - 1).join(FILE_SEPARATOR));\n              return {\n                type: 'mfs',\n                depth: pathComponents.length,\n                mfsDirectory: mfsDirectory,\n                mfsPath: mfsPath,\n                parts: pathComponents,\n                path: \"\".concat(FILE_SEPARATOR).concat(pathComponents.join(FILE_SEPARATOR)),\n                name: pathComponents[pathComponents.length - 1]\n              };\n            });\n            _context2.next = 8;\n            return Promise.all(paths.map( /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path) {\n                var cidPath, res;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        cidPath = path.type === 'mfs' ? path.mfsPath : path.path;\n                        _context.prev = 1;\n                        _context.next = 4;\n                        return exporter(cidPath, context.ipld);\n\n                      case 4:\n                        res = _context.sent;\n                        path.cid = res.cid;\n                        path.mfsPath = \"/ipfs/\".concat(res.path);\n                        path.unixfs = res.unixfs;\n                        path.content = res.content;\n                        _context.next = 15;\n                        break;\n\n                      case 11:\n                        _context.prev = 11;\n                        _context.t0 = _context[\"catch\"](1);\n\n                        if (!(_context.t0.code !== 'ERR_NOT_FOUND')) {\n                          _context.next = 15;\n                          break;\n                        }\n\n                        throw _context.t0;\n\n                      case 15:\n                        path.exists = Boolean(path.cid);\n\n                      case 16:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 11]]);\n              }));\n\n              return function (_x3) {\n                return _ref2.apply(this, arguments);\n              };\n            }()));\n\n          case 8:\n            if (!outputArray) {\n              _context2.next = 10;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", paths);\n\n          case 10:\n            return _context2.abrupt(\"return\", paths[0]);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function toMfsPath(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = toMfsPath;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js"],"names":["require","FILE_SEPARATOR","loadMfsRoot","toPathComponents","exporter","errCode","IPFS_PREFIX","toMfsPath","context","path","outputArray","Array","isArray","paths","root","map","trim","replace","endsWith","length","substring","Error","pathComponents","mfsDirectory","join","slice","type","depth","mfsPath","parts","name","Promise","all","cidPath","ipld","res","cid","unixfs","content","code","exists","Boolean","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {\n  FILE_SEPARATOR\n} = require('./constants')\nconst loadMfsRoot = require('./with-mfs-root')\nconst toPathComponents = require('./to-path-components')\nconst exporter = require('ipfs-unixfs-exporter')\nconst errCode = require('err-code')\n\nconst IPFS_PREFIX = 'ipfs'\n\nconst toMfsPath = async (context, path) => {\n  let outputArray = Array.isArray(path)\n  let paths = Array.isArray(path) ? path : [path]\n  const root = await loadMfsRoot(context)\n\n  paths = paths.map(path => {\n    path = (path || '').trim()\n    path = path.replace(/(\\/\\/+)/g, '/')\n\n    if (path.endsWith('/') && path.length > 1) {\n      path = path.substring(0, path.length - 1)\n    }\n\n    if (!path) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH')\n    }\n\n    if (path.substring(0, 1) !== FILE_SEPARATOR) {\n      throw errCode(new Error(`paths must start with a leading ${FILE_SEPARATOR}`), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(path.length - FILE_SEPARATOR.length) === FILE_SEPARATOR) {\n      path = path.substring(0, path.length - FILE_SEPARATOR.length)\n    }\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`\n      } else {\n        mfsDirectory = `${FILE_SEPARATOR}${pathComponents.slice(0, pathComponents.length - 1).join(FILE_SEPARATOR)}`\n      }\n\n      return {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n\n        mfsPath: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,\n        name: pathComponents[pathComponents.length - 1]\n      }\n    }\n\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join(FILE_SEPARATOR) : ''}`\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join(FILE_SEPARATOR)}`\n\n    return {\n      type: 'mfs',\n      depth: pathComponents.length,\n\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  })\n\n  await Promise.all(\n    paths.map(async (path) => {\n      const cidPath = path.type === 'mfs' ? path.mfsPath : path.path\n\n      try {\n        const res = await exporter(cidPath, context.ipld)\n\n        path.cid = res.cid\n        path.mfsPath = `/ipfs/${res.path}`\n        path.unixfs = res.unixfs\n        path.content = res.content\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n\n      path.exists = Boolean(path.cid)\n    })\n  )\n\n  if (outputArray) {\n    return paths\n  }\n\n  return paths[0]\n}\n\nmodule.exports = toMfsPath\n"]},"metadata":{},"sourceType":"script"}