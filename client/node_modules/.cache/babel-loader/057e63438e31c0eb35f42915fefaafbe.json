{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _slicedToArray = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar promisify = require('promisify-es6');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink,\n    util = _require.util;\n\nvar CID = require('cids');\n\nvar map = require('async/map');\n\nvar mapSeries = require('async/mapSeries');\n\nvar series = require('async/series');\n\nvar parallel = require('async/parallel');\n\nvar eachLimit = require('async/eachLimit');\n\nvar waterfall = require('async/waterfall');\n\nvar detectLimit = require('async/detectLimit');\n\nvar setImmediate = require('async/setImmediate');\n\nvar _require2 = require('interface-datastore'),\n    Key = _require2.Key;\n\nvar errCode = require('err-code');\n\nvar multibase = require('multibase');\n\nvar multicodec = require('multicodec');\n\nvar createPinSet = require('./pin-set');\n\nvar _require3 = require('../utils'),\n    resolvePath = _require3.resolvePath; // arbitrary limit to the number of concurrent dag operations\n\n\nvar concurrencyLimit = 300;\nvar pinDataStoreKey = new Key('/local/pins');\n\nfunction toB58String(hash) {\n  return new CID(hash).toBaseEncodedString();\n}\n\nfunction invalidPinTypeErr(type) {\n  var errMsg = \"Invalid type '\".concat(type, \"', must be one of {direct, indirect, recursive, all}\");\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nmodule.exports = function (self) {\n  var repo = self._repo;\n  var dag = self.dag;\n  var pinset = createPinSet(dag);\n  var types = {\n    direct: 'direct',\n    recursive: 'recursive',\n    indirect: 'indirect',\n    all: 'all'\n  };\n  var directPins = new Set();\n  var recursivePins = new Set();\n\n  var directKeys = function directKeys() {\n    return Array.from(directPins).map(function (key) {\n      return new CID(key).buffer;\n    });\n  };\n\n  var recursiveKeys = function recursiveKeys() {\n    return Array.from(recursivePins).map(function (key) {\n      return new CID(key).buffer;\n    });\n  };\n\n  function getIndirectKeys(callback) {\n    var indirectKeys = new Set();\n    eachLimit(recursiveKeys(), concurrencyLimit, function (multihash, cb) {\n      dag._getRecursive(multihash, function (err, nodes) {\n        if (err) {\n          return cb(err);\n        }\n\n        map(nodes, function (node, cb) {\n          return util.cid(util.serialize(node), {\n            cidVersion: 0\n          }).then(function (cid) {\n            return cb(null, cid);\n          }, cb);\n        }, function (err, cids) {\n          if (err) {\n            return cb(err);\n          }\n\n          cids.map(function (cid) {\n            return cid.toString();\n          }) // recursive pins pre-empt indirect pins\n          .filter(function (key) {\n            return !recursivePins.has(key);\n          }).forEach(function (key) {\n            return indirectKeys.add(key);\n          });\n          cb();\n        });\n      });\n    }, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, Array.from(indirectKeys));\n    });\n  } // Encode and write pin key sets to the datastore:\n  // a DAGLink for each of the recursive and direct pinsets\n  // a DAGNode holding those as DAGLinks, a kind of root pin\n\n\n  function flushPins(callback) {\n    var dLink, rLink, root;\n    series([// create a DAGLink to the node with direct pins\n    function (cb) {\n      return waterfall([function (cb) {\n        return pinset.storeSet(directKeys(), cb);\n      }, function (_ref, cb) {\n        var node = _ref.node,\n            cid = _ref.cid;\n\n        try {\n          cb(null, new DAGLink(types.direct, node.size, cid));\n        } catch (err) {\n          cb(err);\n        }\n      }, function (link, cb) {\n        dLink = link;\n        cb(null);\n      }], cb);\n    }, // create a DAGLink to the node with recursive pins\n    function (cb) {\n      return waterfall([function (cb) {\n        return pinset.storeSet(recursiveKeys(), cb);\n      }, function (_ref2, cb) {\n        var node = _ref2.node,\n            cid = _ref2.cid;\n\n        try {\n          cb(null, new DAGLink(types.recursive, node.size, cid));\n        } catch (err) {\n          cb(err);\n        }\n      }, function (link, cb) {\n        rLink = link;\n        cb(null);\n      }], cb);\n    }, // the pin-set nodes link to a special 'empty' node, so make sure it exists\n    function (cb) {\n      var empty;\n\n      try {\n        empty = DAGNode.create(Buffer.alloc(0));\n      } catch (err) {\n        return cb(err);\n      }\n\n      dag.put(empty, {\n        version: 0,\n        format: multicodec.DAG_PB,\n        hashAlg: multicodec.SHA2_256,\n        preload: false\n      }, cb);\n    }, // create a root node with DAGLinks to the direct and recursive DAGs\n    function (cb) {\n      var node;\n\n      try {\n        node = DAGNode.create(Buffer.alloc(0), [dLink, rLink]);\n      } catch (err) {\n        return cb(err);\n      }\n\n      root = node;\n      dag.put(root, {\n        version: 0,\n        format: multicodec.DAG_PB,\n        hashAlg: multicodec.SHA2_256,\n        preload: false\n      }, function (err, cid) {\n        if (!err) {\n          root.multihash = cid.buffer;\n        }\n\n        cb(err);\n      });\n    }, // hack for CLI tests\n    function (cb) {\n      return repo.closed ? repo.open(cb) : cb(null, null);\n    }, // save root to datastore under a consistent key\n    function (cb) {\n      return repo.datastore.put(pinDataStoreKey, root.multihash, cb);\n    }], function (err, res) {\n      if (err) {\n        return callback(err);\n      }\n\n      self.log(\"Flushed pins with root: \".concat(root));\n      return callback(null, root);\n    });\n  }\n\n  var pin = {\n    add: promisify(function (paths, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var recursive = options.recursive == null ? true : options.recursive;\n      resolvePath(self.object, paths, function (err, mhs) {\n        if (err) {\n          return callback(err);\n        } // verify that each hash can be pinned\n\n\n        map(mhs, function (multihash, cb) {\n          var key = toB58String(multihash);\n\n          if (recursive) {\n            if (recursivePins.has(key)) {\n              // it's already pinned recursively\n              return cb(null, key);\n            } // entire graph of nested links should be pinned,\n            // so make sure we have all the objects\n\n\n            dag._getRecursive(key, {\n              preload: options.preload\n            }, function (err) {\n              if (err) {\n                return cb(err);\n              } // found all objects, we can add the pin\n\n\n              return cb(null, key);\n            });\n          } else {\n            if (recursivePins.has(key)) {\n              // recursive supersedes direct, can't have both\n              return cb(new Error(\"\".concat(key, \" already pinned recursively\")));\n            }\n\n            if (directPins.has(key)) {\n              // already directly pinned\n              return cb(null, key);\n            } // make sure we have the object\n\n\n            dag.get(new CID(multihash), {\n              preload: options.preload\n            }, function (err) {\n              if (err) {\n                return cb(err);\n              } // found the object, we can add the pin\n\n\n              return cb(null, key);\n            });\n          }\n        }, function (err, results) {\n          if (err) {\n            return callback(err);\n          } // update the pin sets in memory\n\n\n          var pinset = recursive ? recursivePins : directPins;\n          results.forEach(function (key) {\n            return pinset.add(key);\n          }); // persist updated pin sets to datastore\n\n          flushPins(function (err, root) {\n            if (err) {\n              return callback(err);\n            }\n\n            callback(null, results.map(function (hash) {\n              return {\n                hash: hash\n              };\n            }));\n          });\n        });\n      });\n    }),\n    rm: promisify(function (paths, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n      }\n\n      options = options || {};\n      var recursive = options.recursive == null ? true : options.recursive;\n\n      if (options.cidBase && !multibase.names.includes(options.cidBase)) {\n        return setImmediate(function () {\n          callback(errCode(new Error('invalid multibase'), 'ERR_INVALID_MULTIBASE'));\n        });\n      }\n\n      resolvePath(self.object, paths, function (err, mhs) {\n        if (err) {\n          return callback(err);\n        } // verify that each hash can be unpinned\n\n\n        map(mhs, function (multihash, cb) {\n          pin._isPinnedWithType(multihash, types.all, function (err, res) {\n            if (err) {\n              return cb(err);\n            }\n\n            var pinned = res.pinned,\n                reason = res.reason;\n            var key = toB58String(multihash);\n\n            if (!pinned) {\n              return cb(new Error(\"\".concat(key, \" is not pinned\")));\n            }\n\n            switch (reason) {\n              case types.recursive:\n                if (recursive) {\n                  return cb(null, key);\n                } else {\n                  return cb(new Error(\"\".concat(key, \" is pinned recursively\")));\n                }\n\n              case types.direct:\n                return cb(null, key);\n\n              default:\n                return cb(new Error(\"\".concat(key, \" is pinned indirectly under \").concat(reason)));\n            }\n          });\n        }, function (err, results) {\n          if (err) {\n            return callback(err);\n          } // update the pin sets in memory\n\n\n          results.forEach(function (key) {\n            if (recursive && recursivePins.has(key)) {\n              recursivePins.delete(key);\n            } else {\n              directPins.delete(key);\n            }\n          }); // persist updated pin sets to datastore\n\n          flushPins(function (err, root) {\n            if (err) {\n              return callback(err);\n            }\n\n            self.log(\"Removed pins: \".concat(results));\n            callback(null, results.map(function (hash) {\n              return {\n                hash: hash\n              };\n            }));\n          });\n        });\n      });\n    }),\n    ls: promisify(function (paths, options, callback) {\n      var type = types.all;\n\n      if (typeof paths === 'function') {\n        callback = paths;\n        options = {};\n        paths = null;\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n      }\n\n      if (paths && paths.type) {\n        options = paths;\n        paths = null;\n      }\n\n      options = options || {};\n\n      if (options.type) {\n        if (typeof options.type !== 'string') {\n          return setImmediate(function () {\n            return callback(invalidPinTypeErr(options.type));\n          });\n        }\n\n        type = options.type.toLowerCase();\n      }\n\n      if (!Object.keys(types).includes(type)) {\n        return setImmediate(function () {\n          return callback(invalidPinTypeErr(type));\n        });\n      }\n\n      if (paths) {\n        // check the pinned state of specific hashes\n        waterfall([function (cb) {\n          return resolvePath(self.object, paths, cb);\n        }, function (hashes, cb) {\n          return mapSeries(hashes, function (hash, done) {\n            return pin._isPinnedWithType(hash, types.all, done);\n          }, cb);\n        }, function (results, cb) {\n          results = results.filter(function (result) {\n            return result.pinned;\n          }).map(function (_ref3) {\n            var key = _ref3.key,\n                reason = _ref3.reason;\n\n            switch (reason) {\n              case types.direct:\n              case types.recursive:\n                return {\n                  hash: key,\n                  type: reason\n                };\n\n              default:\n                return {\n                  hash: key,\n                  type: \"\".concat(types.indirect, \" through \").concat(reason)\n                };\n            }\n          });\n\n          if (!results.length) {\n            return cb(new Error(\"Path is not pinned\"));\n          }\n\n          cb(null, results);\n        }], callback);\n      } else {\n        // show all pinned items of type\n        var pins = [];\n\n        if (type === types.direct || type === types.all) {\n          pins = pins.concat(Array.from(directPins).map(function (hash) {\n            return {\n              type: types.direct,\n              hash: hash\n            };\n          }));\n        }\n\n        if (type === types.recursive || type === types.all) {\n          pins = pins.concat(Array.from(recursivePins).map(function (hash) {\n            return {\n              type: types.recursive,\n              hash: hash\n            };\n          }));\n        }\n\n        if (type === types.indirect || type === types.all) {\n          getIndirectKeys(function (err, indirects) {\n            if (err) {\n              return callback(err);\n            }\n\n            pins = pins // if something is pinned both directly and indirectly,\n            // report the indirect entry\n            .filter(function (_ref4) {\n              var hash = _ref4.hash;\n              return !indirects.includes(hash) || indirects.includes(hash) && !directPins.has(hash);\n            }).concat(indirects.map(function (hash) {\n              return {\n                type: types.indirect,\n                hash: hash\n              };\n            }));\n            return callback(null, pins);\n          });\n        } else {\n          callback(null, pins);\n        }\n      }\n    }),\n    _isPinnedWithType: promisify(function (multihash, type, callback) {\n      var key = toB58String(multihash);\n      var recursive = types.recursive,\n          direct = types.direct,\n          all = types.all; // recursive\n\n      if ((type === recursive || type === all) && recursivePins.has(key)) {\n        return callback(null, {\n          key: key,\n          pinned: true,\n          reason: recursive\n        });\n      }\n\n      if (type === recursive) {\n        return callback(null, {\n          key: key,\n          pinned: false\n        });\n      } // direct\n\n\n      if ((type === direct || type === all) && directPins.has(key)) {\n        return callback(null, {\n          key: key,\n          pinned: true,\n          reason: direct\n        });\n      }\n\n      if (type === direct) {\n        return callback(null, {\n          key: key,\n          pinned: false\n        });\n      } // indirect (default)\n      // check each recursive key to see if multihash is under it\n      // arbitrary limit, enables handling 1000s of pins.\n\n\n      detectLimit(recursiveKeys().map(function (key) {\n        return new CID(key);\n      }), concurrencyLimit, function (cid, cb) {\n        waterfall([function (done) {\n          return dag.get(cid, '', {\n            preload: false\n          }, done);\n        }, function (result, done) {\n          return done(null, result.value);\n        }, function (node, done) {\n          return pinset.hasDescendant(node, key, done);\n        }], cb);\n      }, function (err, cid) {\n        return callback(err, {\n          key: key,\n          pinned: Boolean(cid),\n          reason: cid\n        });\n      });\n    }),\n    _load: promisify(function (callback) {\n      waterfall([// hack for CLI tests\n      function (cb) {\n        return repo.closed ? repo.datastore.open(cb) : cb(null, null);\n      }, function (_, cb) {\n        return repo.datastore.has(pinDataStoreKey, cb);\n      }, function (has, cb) {\n        return has ? cb() : cb(new Error('No pins to load'));\n      }, function (cb) {\n        return repo.datastore.get(pinDataStoreKey, cb);\n      }, function (mh, cb) {\n        dag.get(new CID(mh), '', {\n          preload: false\n        }, cb);\n      }], function (err, pinRoot) {\n        if (err) {\n          if (err.message === 'No pins to load') {\n            self.log('No pins to load');\n            return callback();\n          } else {\n            return callback(err);\n          }\n        }\n\n        parallel([function (cb) {\n          return pinset.loadSet(pinRoot.value, types.recursive, cb);\n        }, function (cb) {\n          return pinset.loadSet(pinRoot.value, types.direct, cb);\n        }], function (err, keys) {\n          if (err) {\n            return callback(err);\n          }\n\n          var _keys = _slicedToArray(keys, 2),\n              rKeys = _keys[0],\n              dKeys = _keys[1];\n\n          directPins = new Set(dKeys.map(toB58String));\n          recursivePins = new Set(rKeys.map(toB58String));\n          self.log('Loaded pins from the datastore');\n          return callback(null);\n        });\n      });\n    })\n  };\n  return pin;\n};","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs/src/core/components/pin.js"],"names":["promisify","require","DAGNode","DAGLink","util","CID","map","mapSeries","series","parallel","eachLimit","waterfall","detectLimit","setImmediate","Key","errCode","multibase","multicodec","createPinSet","resolvePath","concurrencyLimit","pinDataStoreKey","toB58String","hash","toBaseEncodedString","invalidPinTypeErr","type","errMsg","Error","module","exports","self","repo","_repo","dag","pinset","types","direct","recursive","indirect","all","directPins","Set","recursivePins","directKeys","Array","from","key","buffer","recursiveKeys","getIndirectKeys","callback","indirectKeys","multihash","cb","_getRecursive","err","nodes","node","cid","serialize","cidVersion","then","cids","toString","filter","has","forEach","add","flushPins","dLink","rLink","root","storeSet","size","link","empty","create","Buffer","alloc","put","version","format","DAG_PB","hashAlg","SHA2_256","preload","closed","open","datastore","res","log","pin","paths","options","object","mhs","get","results","rm","cidBase","names","includes","_isPinnedWithType","pinned","reason","delete","ls","toLowerCase","Object","keys","hashes","done","result","length","pins","concat","indirects","value","hasDescendant","Boolean","_load","_","mh","pinRoot","message","loadSet","rKeys","dKeys"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst promisify = require('promisify-es6')\nconst { DAGNode, DAGLink, util } = require('ipld-dag-pb')\nconst CID = require('cids')\nconst map = require('async/map')\nconst mapSeries = require('async/mapSeries')\nconst series = require('async/series')\nconst parallel = require('async/parallel')\nconst eachLimit = require('async/eachLimit')\nconst waterfall = require('async/waterfall')\nconst detectLimit = require('async/detectLimit')\nconst setImmediate = require('async/setImmediate')\nconst { Key } = require('interface-datastore')\nconst errCode = require('err-code')\nconst multibase = require('multibase')\nconst multicodec = require('multicodec')\n\nconst createPinSet = require('./pin-set')\nconst { resolvePath } = require('../utils')\n\n// arbitrary limit to the number of concurrent dag operations\nconst concurrencyLimit = 300\nconst pinDataStoreKey = new Key('/local/pins')\n\nfunction toB58String (hash) {\n  return new CID(hash).toBaseEncodedString()\n}\n\nfunction invalidPinTypeErr (type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE')\n}\n\nmodule.exports = (self) => {\n  const repo = self._repo\n  const dag = self.dag\n  const pinset = createPinSet(dag)\n  const types = {\n    direct: 'direct',\n    recursive: 'recursive',\n    indirect: 'indirect',\n    all: 'all'\n  }\n\n  let directPins = new Set()\n  let recursivePins = new Set()\n\n  const directKeys = () =>\n    Array.from(directPins).map(key => new CID(key).buffer)\n  const recursiveKeys = () =>\n    Array.from(recursivePins).map(key => new CID(key).buffer)\n\n  function getIndirectKeys (callback) {\n    const indirectKeys = new Set()\n    eachLimit(recursiveKeys(), concurrencyLimit, (multihash, cb) => {\n      dag._getRecursive(multihash, (err, nodes) => {\n        if (err) {\n          return cb(err)\n        }\n\n        map(nodes, (node, cb) => util.cid(util.serialize(node), {\n          cidVersion: 0\n        }).then(cid => cb(null, cid), cb), (err, cids) => {\n          if (err) {\n            return cb(err)\n          }\n\n          cids\n            .map(cid => cid.toString())\n            // recursive pins pre-empt indirect pins\n            .filter(key => !recursivePins.has(key))\n            .forEach(key => indirectKeys.add(key))\n\n          cb()\n        })\n      })\n    }, (err) => {\n      if (err) { return callback(err) }\n      callback(null, Array.from(indirectKeys))\n    })\n  }\n\n  // Encode and write pin key sets to the datastore:\n  // a DAGLink for each of the recursive and direct pinsets\n  // a DAGNode holding those as DAGLinks, a kind of root pin\n  function flushPins (callback) {\n    let dLink, rLink, root\n    series([\n      // create a DAGLink to the node with direct pins\n      cb => waterfall([\n        cb => pinset.storeSet(directKeys(), cb),\n        ({ node, cid }, cb) => {\n          try {\n            cb(null, new DAGLink(types.direct, node.size, cid))\n          } catch (err) {\n            cb(err)\n          }\n        },\n        (link, cb) => { dLink = link; cb(null) }\n      ], cb),\n\n      // create a DAGLink to the node with recursive pins\n      cb => waterfall([\n        cb => pinset.storeSet(recursiveKeys(), cb),\n        ({ node, cid }, cb) => {\n          try {\n            cb(null, new DAGLink(types.recursive, node.size, cid))\n          } catch (err) {\n            cb(err)\n          }\n        },\n        (link, cb) => { rLink = link; cb(null) }\n      ], cb),\n\n      // the pin-set nodes link to a special 'empty' node, so make sure it exists\n      cb => {\n        let empty\n\n        try {\n          empty = DAGNode.create(Buffer.alloc(0))\n        } catch (err) {\n          return cb(err)\n        }\n\n        dag.put(empty, {\n          version: 0,\n          format: multicodec.DAG_PB,\n          hashAlg: multicodec.SHA2_256,\n          preload: false\n        }, cb)\n      },\n\n      // create a root node with DAGLinks to the direct and recursive DAGs\n      cb => {\n        let node\n\n        try {\n          node = DAGNode.create(Buffer.alloc(0), [dLink, rLink])\n        } catch (err) {\n          return cb(err)\n        }\n\n        root = node\n        dag.put(root, {\n          version: 0,\n          format: multicodec.DAG_PB,\n          hashAlg: multicodec.SHA2_256,\n          preload: false\n        }, (err, cid) => {\n          if (!err) {\n            root.multihash = cid.buffer\n          }\n          cb(err)\n        })\n      },\n\n      // hack for CLI tests\n      cb => repo.closed ? repo.open(cb) : cb(null, null),\n\n      // save root to datastore under a consistent key\n      cb => repo.datastore.put(pinDataStoreKey, root.multihash, cb)\n    ], (err, res) => {\n      if (err) { return callback(err) }\n      self.log(`Flushed pins with root: ${root}`)\n      return callback(null, root)\n    })\n  }\n\n  const pin = {\n    add: promisify((paths, options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      options = options || {}\n\n      const recursive = options.recursive == null ? true : options.recursive\n\n      resolvePath(self.object, paths, (err, mhs) => {\n        if (err) { return callback(err) }\n\n        // verify that each hash can be pinned\n        map(mhs, (multihash, cb) => {\n          const key = toB58String(multihash)\n          if (recursive) {\n            if (recursivePins.has(key)) {\n              // it's already pinned recursively\n              return cb(null, key)\n            }\n\n            // entire graph of nested links should be pinned,\n            // so make sure we have all the objects\n            dag._getRecursive(key, { preload: options.preload }, (err) => {\n              if (err) { return cb(err) }\n              // found all objects, we can add the pin\n              return cb(null, key)\n            })\n          } else {\n            if (recursivePins.has(key)) {\n              // recursive supersedes direct, can't have both\n              return cb(new Error(`${key} already pinned recursively`))\n            }\n            if (directPins.has(key)) {\n              // already directly pinned\n              return cb(null, key)\n            }\n\n            // make sure we have the object\n            dag.get(new CID(multihash), { preload: options.preload }, (err) => {\n              if (err) { return cb(err) }\n              // found the object, we can add the pin\n              return cb(null, key)\n            })\n          }\n        }, (err, results) => {\n          if (err) { return callback(err) }\n\n          // update the pin sets in memory\n          const pinset = recursive ? recursivePins : directPins\n          results.forEach(key => pinset.add(key))\n\n          // persist updated pin sets to datastore\n          flushPins((err, root) => {\n            if (err) { return callback(err) }\n            callback(null, results.map(hash => ({ hash })))\n          })\n        })\n      })\n    }),\n\n    rm: promisify((paths, options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n      }\n\n      options = options || {}\n\n      const recursive = options.recursive == null ? true : options.recursive\n\n      if (options.cidBase && !multibase.names.includes(options.cidBase)) {\n        return setImmediate(() => {\n          callback(errCode(new Error('invalid multibase'), 'ERR_INVALID_MULTIBASE'))\n        })\n      }\n\n      resolvePath(self.object, paths, (err, mhs) => {\n        if (err) { return callback(err) }\n\n        // verify that each hash can be unpinned\n        map(mhs, (multihash, cb) => {\n          pin._isPinnedWithType(multihash, types.all, (err, res) => {\n            if (err) { return cb(err) }\n            const { pinned, reason } = res\n            const key = toB58String(multihash)\n            if (!pinned) {\n              return cb(new Error(`${key} is not pinned`))\n            }\n\n            switch (reason) {\n              case (types.recursive):\n                if (recursive) {\n                  return cb(null, key)\n                } else {\n                  return cb(new Error(`${key} is pinned recursively`))\n                }\n              case (types.direct):\n                return cb(null, key)\n              default:\n                return cb(new Error(\n                  `${key} is pinned indirectly under ${reason}`\n                ))\n            }\n          })\n        }, (err, results) => {\n          if (err) { return callback(err) }\n\n          // update the pin sets in memory\n          results.forEach(key => {\n            if (recursive && recursivePins.has(key)) {\n              recursivePins.delete(key)\n            } else {\n              directPins.delete(key)\n            }\n          })\n\n          // persist updated pin sets to datastore\n          flushPins((err, root) => {\n            if (err) { return callback(err) }\n            self.log(`Removed pins: ${results}`)\n            callback(null, results.map(hash => ({ hash })))\n          })\n        })\n      })\n    }),\n\n    ls: promisify((paths, options, callback) => {\n      let type = types.all\n      if (typeof paths === 'function') {\n        callback = paths\n        options = {}\n        paths = null\n      }\n      if (typeof options === 'function') {\n        callback = options\n      }\n      if (paths && paths.type) {\n        options = paths\n        paths = null\n      }\n\n      options = options || {}\n\n      if (options.type) {\n        if (typeof options.type !== 'string') {\n          return setImmediate(() => callback(invalidPinTypeErr(options.type)))\n        }\n        type = options.type.toLowerCase()\n      }\n      if (!Object.keys(types).includes(type)) {\n        return setImmediate(() => callback(invalidPinTypeErr(type)))\n      }\n\n      if (paths) {\n        // check the pinned state of specific hashes\n        waterfall([\n          (cb) => resolvePath(self.object, paths, cb),\n          (hashes, cb) => mapSeries(hashes, (hash, done) => pin._isPinnedWithType(hash, types.all, done), cb),\n          (results, cb) => {\n            results = results\n              .filter(result => result.pinned)\n              .map(({ key, reason }) => {\n                switch (reason) {\n                  case types.direct:\n                  case types.recursive:\n                    return {\n                      hash: key,\n                      type: reason\n                    }\n                  default:\n                    return {\n                      hash: key,\n                      type: `${types.indirect} through ${reason}`\n                    }\n                }\n              })\n\n            if (!results.length) {\n              return cb(new Error(`Path is not pinned`))\n            }\n\n            cb(null, results)\n          }\n        ], callback)\n      } else {\n        // show all pinned items of type\n        let pins = []\n        if (type === types.direct || type === types.all) {\n          pins = pins.concat(\n            Array.from(directPins).map(hash => ({\n              type: types.direct,\n              hash\n            }))\n          )\n        }\n        if (type === types.recursive || type === types.all) {\n          pins = pins.concat(\n            Array.from(recursivePins).map(hash => ({\n              type: types.recursive,\n              hash\n            }))\n          )\n        }\n        if (type === types.indirect || type === types.all) {\n          getIndirectKeys((err, indirects) => {\n            if (err) { return callback(err) }\n            pins = pins\n              // if something is pinned both directly and indirectly,\n              // report the indirect entry\n              .filter(({ hash }) =>\n                !indirects.includes(hash) ||\n                (indirects.includes(hash) && !directPins.has(hash))\n              )\n              .concat(indirects.map(hash => ({\n                type: types.indirect,\n                hash\n              })))\n            return callback(null, pins)\n          })\n        } else {\n          callback(null, pins)\n        }\n      }\n    }),\n\n    _isPinnedWithType: promisify((multihash, type, callback) => {\n      const key = toB58String(multihash)\n      const { recursive, direct, all } = types\n\n      // recursive\n      if ((type === recursive || type === all) && recursivePins.has(key)) {\n        return callback(null, {\n          key,\n          pinned: true,\n          reason: recursive\n        })\n      }\n\n      if (type === recursive) {\n        return callback(null, {\n          key,\n          pinned: false\n        })\n      }\n\n      // direct\n      if ((type === direct || type === all) && directPins.has(key)) {\n        return callback(null, {\n          key,\n          pinned: true,\n          reason: direct\n        })\n      }\n\n      if (type === direct) {\n        return callback(null, {\n          key,\n          pinned: false\n        })\n      }\n\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n      // arbitrary limit, enables handling 1000s of pins.\n      detectLimit(recursiveKeys().map(key => new CID(key)), concurrencyLimit, (cid, cb) => {\n        waterfall([\n          (done) => dag.get(cid, '', { preload: false }, done),\n          (result, done) => done(null, result.value),\n          (node, done) => pinset.hasDescendant(node, key, done)\n        ], cb)\n      }, (err, cid) => callback(err, {\n        key,\n        pinned: Boolean(cid),\n        reason: cid\n      }))\n    }),\n\n    _load: promisify(callback => {\n      waterfall([\n        // hack for CLI tests\n        (cb) => repo.closed ? repo.datastore.open(cb) : cb(null, null),\n        (_, cb) => repo.datastore.has(pinDataStoreKey, cb),\n        (has, cb) => has ? cb() : cb(new Error('No pins to load')),\n        (cb) => repo.datastore.get(pinDataStoreKey, cb),\n        (mh, cb) => {\n          dag.get(new CID(mh), '', { preload: false }, cb)\n        }\n      ], (err, pinRoot) => {\n        if (err) {\n          if (err.message === 'No pins to load') {\n            self.log('No pins to load')\n            return callback()\n          } else {\n            return callback(err)\n          }\n        }\n\n        parallel([\n          cb => pinset.loadSet(pinRoot.value, types.recursive, cb),\n          cb => pinset.loadSet(pinRoot.value, types.direct, cb)\n        ], (err, keys) => {\n          if (err) { return callback(err) }\n          const [ rKeys, dKeys ] = keys\n\n          directPins = new Set(dKeys.map(toB58String))\n          recursivePins = new Set(rKeys.map(toB58String))\n\n          self.log('Loaded pins from the datastore')\n          return callback(null)\n        })\n      })\n    })\n  }\n\n  return pin\n}\n"]},"metadata":{},"sourceType":"script"}