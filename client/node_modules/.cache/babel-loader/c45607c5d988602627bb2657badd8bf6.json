{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar libp2pRecord = require('libp2p-record');\n\nvar MemoryStore = require('interface-datastore').MemoryDatastore;\n\nvar waterfall = require('async/waterfall');\n\nvar each = require('async/each');\n\nvar filter = require('async/filter');\n\nvar timeout = require('async/timeout');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar crypto = require('libp2p-crypto');\n\nvar promiseToCallback = require('promise-to-callback');\n\nvar errcode = require('err-code');\n\nvar RoutingTable = require('./routing');\n\nvar utils = require('./utils');\n\nvar c = require('./constants');\n\nvar Query = require('./query');\n\nvar Network = require('./network');\n\nvar privateApi = require('./private');\n\nvar Providers = require('./providers');\n\nvar Message = require('./message');\n\nvar RandomWalk = require('./random-walk');\n\nvar QueryManager = require('./query-manager');\n\nvar assert = require('assert');\n/**\n * A DHT implementation modeled after Kademlia with S/Kademlia modifications.\n *\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\n\n\nvar KadDHT = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(KadDHT, _EventEmitter);\n\n  var _super = _createSuper(KadDHT);\n\n  /**\n   * Random walk options\n   *\n   * @typedef {Object} randomWalkOptions\n   * @property {boolean} enabled discovery enabled (default: true)\n   * @property {number} queriesPerPeriod how many queries to run per period (default: 1)\n   * @property {number} interval how often to run the the random-walk process, in milliseconds (default: 300000)\n   * @property {number} timeout how long to wait for the the random-walk query to run, in milliseconds (default: 30000)\n   * @property {number} delay how long to wait before starting the first random walk, in milliseconds (default: 10000)\n   */\n\n  /**\n   * Create a new KadDHT.\n   *\n   * @param {Switch} sw libp2p-switch instance\n   * @param {object} options DHT options\n   * @param {number} options.kBucketSize k-bucket size (default 20)\n   * @param {number} options.concurrency alpha concurrency of queries (default 3)\n   * @param {Datastore} options.datastore datastore (default MemoryDatastore)\n   * @param {object} options.validators validators object with namespace as keys and function(key, record, callback)\n   * @param {object} options.selectors selectors object with namespace as keys and function(key, records)\n   * @param {randomWalkOptions} options.randomWalk randomWalk options\n   */\n  function KadDHT(sw, options) {\n    var _this;\n\n    _classCallCheck(this, KadDHT);\n\n    _this = _super.call(this);\n    assert(sw, 'libp2p-kad-dht requires a instance of Switch');\n    options = options || {};\n    options.validators = options.validators || {};\n    options.selectors = options.selectors || {};\n    /**\n     * Local reference to the libp2p-switch instance\n     *\n     * @type {Switch}\n     */\n\n    _this.switch = sw;\n    /**\n     * k-bucket size, defaults to 20\n     *\n     * @type {number}\n     */\n\n    _this.kBucketSize = options.kBucketSize || c.K;\n    /**\n     * ALPHA concurrency at which each query path with run, defaults to 3\n     * @type {number}\n     */\n\n    _this.concurrency = options.concurrency || c.ALPHA;\n    /**\n     * Number of disjoint query paths to use\n     * This is set to `kBucketSize`/2 per the S/Kademlia paper\n     * @type {number}\n     */\n\n    _this.disjointPaths = Math.ceil(_this.kBucketSize / 2);\n    /**\n     * The routing table.\n     *\n     * @type {RoutingTable}\n     */\n\n    _this.routingTable = new RoutingTable(_this.peerInfo.id, _this.kBucketSize);\n    /**\n     * Reference to the datastore, uses an in-memory store if none given.\n     *\n     * @type {Datastore}\n     */\n\n    _this.datastore = options.datastore || new MemoryStore();\n    /**\n     * Provider management\n     *\n     * @type {Providers}\n     */\n\n    _this.providers = new Providers(_this.datastore, _this.peerInfo.id);\n    _this.validators = _objectSpread({\n      pk: libp2pRecord.validator.validators.pk\n    }, options.validators);\n    _this.selectors = _objectSpread({\n      pk: libp2pRecord.selection.selectors.pk\n    }, options.selectors);\n    _this.network = new Network(_assertThisInitialized(_this));\n    _this._log = utils.logger(_this.peerInfo.id); // Inject private apis so we don't clutter up this file\n\n    var pa = privateApi(_assertThisInitialized(_this));\n    Object.keys(pa).forEach(function (name) {\n      _this[name] = pa[name];\n    });\n    /**\n     * Random walk management\n     *\n     * @type {RandomWalk}\n     */\n\n    _this.randomWalk = new RandomWalk(_assertThisInitialized(_this), options.randomWalk);\n    /**\n     * Keeps track of running queries\n     *\n     * @type {QueryManager}\n     */\n\n    _this._queryManager = new QueryManager();\n    return _this;\n  }\n  /**\n   * Is this DHT running.\n   *\n   * @type {bool}\n   */\n\n\n  _createClass(KadDHT, [{\n    key: \"isStarted\",\n    get: function get() {\n      return this._running;\n    }\n    /**\n     * Start listening to incoming connections.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      var _this2 = this;\n\n      this._running = true;\n\n      this._queryManager.start();\n\n      this.network.start(function (err) {\n        if (err) {\n          return callback(err);\n        } // Start random walk, it will not run if it's disabled\n\n\n        _this2.randomWalk.start();\n\n        callback();\n      });\n    }\n    /**\n     * Stop accepting incoming connections and sending outgoing\n     * messages.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      this._running = false;\n      this.randomWalk.stop();\n      this.providers.stop();\n\n      this._queryManager.stop();\n\n      this.network.stop(callback);\n    }\n    /**\n     * Local peer (yourself)\n     *\n     * @type {PeerInfo}\n     */\n\n  }, {\n    key: \"peerInfo\",\n    get: function get() {\n      return this.switch._peerInfo;\n    }\n  }, {\n    key: \"peerBook\",\n    get: function get() {\n      return this.switch._peerBook;\n    }\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} options - get options\n     * @param {number} options.minPeers - minimum peers that must be put to to consider this a successful operation\n     * (default: closestPeers.length)\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(key, value, options, callback) {\n      var _this3 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n\n      this._log('PutValue %b', key);\n\n      waterfall([function (cb) {\n        return utils.createPutRecord(key, value, cb);\n      }, function (rec, cb) {\n        return waterfall([function (cb) {\n          return _this3._putLocal(key, rec, cb);\n        }, function (cb) {\n          return _this3.getClosestPeers(key, {\n            shallow: true\n          }, cb);\n        }, function (peers, cb) {\n          // Ensure we have a default `minPeers`\n          options.minPeers = options.minPeers || peers.length; // filter out the successful puts\n\n          filter(peers, function (peer, cb) {\n            _this3._putValueToPeer(key, rec, peer, function (err) {\n              if (err) {\n                _this3._log.error('Failed to put to peer (%b): %s', peer.id, err);\n\n                return cb(null, false);\n              }\n\n              cb(null, true);\n            });\n          }, function (err, results) {\n            if (err) return cb(err); // Did we put to enough peers?\n\n            if (options.minPeers > results.length) {\n              var error = errcode(new Error('Failed to put value to enough peers'), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n              _this3._log.error(error);\n\n              return cb(error);\n            }\n\n            cb();\n          });\n        }], cb);\n      }], callback);\n    }\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute.\n     *\n     * @param {Buffer} key\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout (default: 60000)\n     * @param {function(Error, Buffer)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n\n      if (!options.maxTimeout && !options.timeout) {\n        options.timeout = c.minute; // default\n      } else if (options.maxTimeout && !options.timeout) {\n        // TODO this will be deprecated in a next release\n        options.timeout = options.maxTimeout;\n      }\n\n      this._get(key, options, callback);\n    }\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Buffer} key\n     * @param {number} nvals\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout (default: 60000)\n     * @param {function(Error, Array<{from: PeerId, val: Buffer}>)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(key, nvals, options, callback) {\n      var _this4 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n\n      if (!options.maxTimeout && !options.timeout) {\n        options.timeout = c.minute; // default\n      } else if (options.maxTimeout && !options.timeout) {\n        // TODO this will be deprecated in a next release\n        options.timeout = options.maxTimeout;\n      }\n\n      this._log('getMany %b (%s)', key, nvals);\n\n      var vals = [];\n\n      this._getLocal(key, function (err, localRec) {\n        if (err && nvals === 0) {\n          return callback(err);\n        }\n\n        if (err == null) {\n          vals.push({\n            val: localRec.value,\n            from: _this4.peerInfo.id\n          });\n        }\n\n        if (vals.length >= nvals) {\n          return callback(null, vals);\n        }\n\n        var paths = [];\n        waterfall([function (cb) {\n          return utils.convertBuffer(key, cb);\n        }, function (id, cb) {\n          var rtp = _this4.routingTable.closestPeers(id, _this4.kBucketSize);\n\n          _this4._log('peers in rt: %d', rtp.length);\n\n          if (rtp.length === 0) {\n            var errMsg = 'Failed to lookup key! No peers from routing table!';\n\n            _this4._log.error(errMsg);\n\n            return cb(errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE'));\n          } // we have peers, lets do the actual query to them\n\n\n          var query = new Query(_this4, key, function (pathIndex, numPaths) {\n            // This function body runs once per disjoint path\n            var pathSize = utils.pathSize(nvals - vals.length, numPaths);\n            var pathVals = [];\n            paths.push(pathVals); // Here we return the query function to use on this particular disjoint path\n\n            return /*#__PURE__*/function () {\n              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peer) {\n                var rec, peers, lookupErr, results, res;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.prev = 0;\n                        _context.next = 3;\n                        return _this4._getValueOrPeersAsync(peer, key);\n\n                      case 3:\n                        results = _context.sent;\n                        rec = results.record;\n                        peers = results.peers;\n                        _context.next = 13;\n                        break;\n\n                      case 8:\n                        _context.prev = 8;\n                        _context.t0 = _context[\"catch\"](0);\n\n                        if (!(_context.t0.code !== 'ERR_INVALID_RECORD')) {\n                          _context.next = 12;\n                          break;\n                        }\n\n                        throw _context.t0;\n\n                      case 12:\n                        lookupErr = _context.t0;\n\n                      case 13:\n                        res = {\n                          closerPeers: peers\n                        };\n\n                        if (rec && rec.value || lookupErr) {\n                          pathVals.push({\n                            val: rec && rec.value,\n                            from: peer\n                          });\n                        } // enough is enough\n\n\n                        if (pathVals.length >= pathSize) {\n                          res.pathComplete = true;\n                        }\n\n                        return _context.abrupt(\"return\", res);\n\n                      case 17:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[0, 8]]);\n              }));\n\n              return function (_x) {\n                return _ref.apply(this, arguments);\n              };\n            }();\n          }); // run our query\n\n          timeout(function (_cb) {\n            promiseToCallback(query.run(rtp))(_cb);\n          }, options.timeout)(function (err, res) {\n            query.stop();\n            cb(err, res);\n          });\n        }], function (err) {\n          // combine vals from each path\n          vals = [].concat.apply(vals, paths).slice(0, nvals);\n\n          if (err && vals.length === 0) {\n            return callback(err);\n          }\n\n          callback(null, vals);\n        });\n      });\n    }\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Buffer} key\n     * @param {Object} options\n     * @param {boolean} options.shallow shallow query\n     * @param {function(Error, Array<PeerId>)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getClosestPeers\",\n    value: function getClosestPeers(key, options, callback) {\n      var _this5 = this;\n\n      this._log('getClosestPeers to %b', key);\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {\n          shallow: false\n        };\n      }\n\n      utils.convertBuffer(key, function (err, id) {\n        if (err) {\n          return callback(err);\n        }\n\n        var tablePeers = _this5.routingTable.closestPeers(id, _this5.kBucketSize);\n\n        var q = new Query(_this5, key, function () {\n          // There is no distinction between the disjoint paths,\n          // so there are no per-path variables in this scope.\n          // Just return the actual query function.\n          return /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(peer) {\n              var closer;\n              return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                      _context2.next = 2;\n                      return _this5._closerPeersSingleAsync(key, peer);\n\n                    case 2:\n                      closer = _context2.sent;\n                      return _context2.abrupt(\"return\", {\n                        closerPeers: closer,\n                        pathComplete: options.shallow ? true : undefined\n                      });\n\n                    case 4:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _callee2);\n            }));\n\n            return function (_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          }();\n        });\n        promiseToCallback(q.run(tablePeers))(function (err, res) {\n          if (err) {\n            return callback(err);\n          }\n\n          if (!res || !res.finalSet) {\n            return callback(null, []);\n          }\n\n          waterfall([function (cb) {\n            return utils.sortClosestPeers(Array.from(res.finalSet), id, cb);\n          }, function (sorted, cb) {\n            return cb(null, sorted.slice(0, _this5.kBucketSize));\n          }], callback);\n        });\n      });\n    }\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error, PubKey)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getPublicKey\",\n    value: function getPublicKey(peer, callback) {\n      var _this6 = this;\n\n      this._log('getPublicKey %s', peer.toB58String()); // local check\n\n\n      var info;\n\n      if (this.peerBook.has(peer)) {\n        info = this.peerBook.get(peer);\n\n        if (info && info.id.pubKey) {\n          this._log('getPublicKey: found local copy');\n\n          return callback(null, info.id.pubKey);\n        }\n      } else {\n        info = this.peerBook.put(new PeerInfo(peer));\n      } // try the node directly\n\n\n      this._getPublicKeyFromNode(peer, function (err, pk) {\n        if (!err) {\n          info.id = new PeerId(peer.id, null, pk);\n\n          _this6.peerBook.put(info);\n\n          return callback(null, pk);\n        } // dht directly\n\n\n        var pkKey = utils.keyForPublicKey(peer);\n\n        _this6.get(pkKey, function (err, value) {\n          if (err) {\n            return callback(err);\n          }\n\n          var pk = crypto.unmarshalPublicKey(value);\n          info.id = new PeerId(peer, null, pk);\n\n          _this6.peerBook.put(info);\n\n          callback(null, pk);\n        });\n      });\n    }\n    /**\n     * Look if we are connected to a peer with the given id.\n     * Returns the `PeerInfo` for it, if found, otherwise `undefined`.\n     *\n     * @param {PeerId} peer\n     * @param {function(Error, PeerInfo)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"findPeerLocal\",\n    value: function findPeerLocal(peer, callback) {\n      var _this7 = this;\n\n      this._log('findPeerLocal %s', peer.toB58String());\n\n      this.routingTable.find(peer, function (err, p) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!p || !_this7.peerBook.has(p)) {\n          return callback();\n        }\n\n        callback(null, _this7.peerBook.get(p));\n      });\n    } // ----------- Content Routing\n\n    /**\n     * Announce to the network that we can provide given key's value.\n     *\n     * @param {CID} key\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"provide\",\n    value: function provide(key, callback) {\n      var _this8 = this;\n\n      this._log('provide: %s', key.toBaseEncodedString());\n\n      var errors = [];\n      waterfall([// TODO: refactor this in method in async and remove this wrapper\n      function (cb) {\n        return promiseToCallback(_this8.providers.addProvider(key, _this8.peerInfo.id))(function (err) {\n          return cb(err);\n        });\n      }, function (cb) {\n        return _this8.getClosestPeers(key.buffer, cb);\n      }, function (peers, cb) {\n        var msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0);\n        msg.providerPeers = [_this8.peerInfo];\n        each(peers, function (peer, cb) {\n          _this8._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String());\n\n          _this8.network.sendMessage(peer, msg, function (err) {\n            if (err) errors.push(err);\n            cb();\n          });\n        }, cb);\n      }], function (err) {\n        if (errors.length) {\n          // This should be infrequent. This means a peer we previously connected\n          // to failed to exchange the provide message. If getClosestPeers was an\n          // iterator, we could continue to pull until we announce to kBucketSize peers.\n          err = errcode(\"Failed to provide to \".concat(errors.length, \" of \").concat(_this8.kBucketSize, \" peers\"), 'ERR_SOME_PROVIDES_FAILED', {\n            errors: errors\n          });\n        }\n\n        callback(err);\n      });\n    }\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     *\n     * @param {CID} key\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @param {function(Error, Array<PeerInfo>)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"findProviders\",\n    value: function findProviders(key, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n\n      if (!options.maxTimeout && !options.timeout) {\n        options.timeout = c.minute; // default\n      } else if (options.maxTimeout && !options.timeout) {\n        // TODO this will be deprecated in a next release\n        options.timeout = options.maxTimeout;\n      }\n\n      options.maxNumProviders = options.maxNumProviders || c.K;\n\n      this._log('findProviders %s', key.toBaseEncodedString());\n\n      this._findNProviders(key, options.timeout, options.maxNumProviders, callback);\n    } // ----------- Peer Routing\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} options - findPeer options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {function(Error, PeerInfo)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"findPeer\",\n    value: function findPeer(id, options, callback) {\n      var _this9 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n\n      if (!options.maxTimeout && !options.timeout) {\n        options.timeout = c.minute; // default\n      } else if (options.maxTimeout && !options.timeout) {\n        // TODO this will be deprecated in a next release\n        options.timeout = options.maxTimeout;\n      }\n\n      this._log('findPeer %s', id.toB58String());\n\n      this.findPeerLocal(id, function (err, pi) {\n        if (err) {\n          return callback(err);\n        } // already got it\n\n\n        if (pi != null) {\n          _this9._log('found local');\n\n          return callback(null, pi);\n        }\n\n        waterfall([function (cb) {\n          return utils.convertPeerId(id, cb);\n        }, function (key, cb) {\n          var peers = _this9.routingTable.closestPeers(key, _this9.kBucketSize);\n\n          if (peers.length === 0) {\n            return cb(errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED'));\n          } // sanity check\n\n\n          var match = peers.find(function (p) {\n            return p.isEqual(id);\n          });\n\n          if (match && _this9.peerBook.has(id)) {\n            _this9._log('found in peerbook');\n\n            return cb(null, _this9.peerBook.get(id));\n          } // query the network\n\n\n          var query = new Query(_this9, id.id, function () {\n            // There is no distinction between the disjoint paths,\n            // so there are no per-path variables in this scope.\n            // Just return the actual query function.\n            return /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peer) {\n                var msg, match;\n                return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.next = 2;\n                        return _this9._findPeerSingleAsync(peer, id);\n\n                      case 2:\n                        msg = _context3.sent;\n                        match = msg.closerPeers.find(function (p) {\n                          return p.id.isEqual(id);\n                        }); // found it\n\n                        if (!match) {\n                          _context3.next = 6;\n                          break;\n                        }\n\n                        return _context3.abrupt(\"return\", {\n                          peer: match,\n                          queryComplete: true\n                        });\n\n                      case 6:\n                        return _context3.abrupt(\"return\", {\n                          closerPeers: msg.closerPeers\n                        });\n\n                      case 7:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n\n              return function (_x3) {\n                return _ref3.apply(this, arguments);\n              };\n            }();\n          });\n          timeout(function (_cb) {\n            promiseToCallback(query.run(peers))(_cb);\n          }, options.timeout)(function (err, res) {\n            query.stop();\n            cb(err, res);\n          });\n        }, function (result, cb) {\n          var success = false;\n          result.paths.forEach(function (result) {\n            if (result.success) {\n              success = true;\n\n              _this9.peerBook.put(result.peer);\n            }\n          });\n\n          _this9._log('findPeer %s: %s', id.toB58String(), success);\n\n          if (!success) {\n            return cb(errcode(new Error('No peer found'), 'ERR_NOT_FOUND'));\n          }\n\n          cb(null, _this9.peerBook.get(id));\n        }], callback);\n      });\n    }\n  }, {\n    key: \"_peerDiscovered\",\n    value: function _peerDiscovered(peerInfo) {\n      this.emit('peer', peerInfo);\n    }\n  }]);\n\n  return KadDHT;\n}(EventEmitter);\n\nmodule.exports = KadDHT;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/libp2p-kad-dht/src/index.js"],"names":["require","EventEmitter","libp2pRecord","MemoryStore","MemoryDatastore","waterfall","each","filter","timeout","PeerId","PeerInfo","crypto","promiseToCallback","errcode","RoutingTable","utils","c","Query","Network","privateApi","Providers","Message","RandomWalk","QueryManager","assert","KadDHT","sw","options","validators","selectors","switch","kBucketSize","K","concurrency","ALPHA","disjointPaths","Math","ceil","routingTable","peerInfo","id","datastore","providers","pk","validator","selection","network","_log","logger","pa","Object","keys","forEach","name","randomWalk","_queryManager","_running","callback","start","err","stop","_peerInfo","_peerBook","key","value","cb","createPutRecord","rec","_putLocal","getClosestPeers","shallow","peers","minPeers","length","peer","_putValueToPeer","error","results","Error","maxTimeout","minute","_get","nvals","vals","_getLocal","localRec","push","val","from","paths","convertBuffer","rtp","closestPeers","errMsg","query","pathIndex","numPaths","pathSize","pathVals","_getValueOrPeersAsync","record","code","lookupErr","res","closerPeers","pathComplete","_cb","run","concat","apply","slice","tablePeers","q","_closerPeersSingleAsync","closer","undefined","finalSet","sortClosestPeers","Array","sorted","toB58String","info","peerBook","has","get","pubKey","put","_getPublicKeyFromNode","pkKey","keyForPublicKey","unmarshalPublicKey","find","p","toBaseEncodedString","errors","addProvider","buffer","msg","TYPES","ADD_PROVIDER","providerPeers","sendMessage","maxNumProviders","_findNProviders","findPeerLocal","pi","convertPeerId","match","isEqual","_findPeerSingleAsync","queryComplete","result","success","emit","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst libp2pRecord = require('libp2p-record')\nconst MemoryStore = require('interface-datastore').MemoryDatastore\nconst waterfall = require('async/waterfall')\nconst each = require('async/each')\nconst filter = require('async/filter')\nconst timeout = require('async/timeout')\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst crypto = require('libp2p-crypto')\nconst promiseToCallback = require('promise-to-callback')\n\nconst errcode = require('err-code')\n\nconst RoutingTable = require('./routing')\nconst utils = require('./utils')\nconst c = require('./constants')\nconst Query = require('./query')\nconst Network = require('./network')\nconst privateApi = require('./private')\nconst Providers = require('./providers')\nconst Message = require('./message')\nconst RandomWalk = require('./random-walk')\nconst QueryManager = require('./query-manager')\nconst assert = require('assert')\n\n/**\n * A DHT implementation modeled after Kademlia with S/Kademlia modifications.\n *\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\nclass KadDHT extends EventEmitter {\n  /**\n   * Random walk options\n   *\n   * @typedef {Object} randomWalkOptions\n   * @property {boolean} enabled discovery enabled (default: true)\n   * @property {number} queriesPerPeriod how many queries to run per period (default: 1)\n   * @property {number} interval how often to run the the random-walk process, in milliseconds (default: 300000)\n   * @property {number} timeout how long to wait for the the random-walk query to run, in milliseconds (default: 30000)\n   * @property {number} delay how long to wait before starting the first random walk, in milliseconds (default: 10000)\n   */\n\n  /**\n   * Create a new KadDHT.\n   *\n   * @param {Switch} sw libp2p-switch instance\n   * @param {object} options DHT options\n   * @param {number} options.kBucketSize k-bucket size (default 20)\n   * @param {number} options.concurrency alpha concurrency of queries (default 3)\n   * @param {Datastore} options.datastore datastore (default MemoryDatastore)\n   * @param {object} options.validators validators object with namespace as keys and function(key, record, callback)\n   * @param {object} options.selectors selectors object with namespace as keys and function(key, records)\n   * @param {randomWalkOptions} options.randomWalk randomWalk options\n   */\n  constructor (sw, options) {\n    super()\n    assert(sw, 'libp2p-kad-dht requires a instance of Switch')\n    options = options || {}\n    options.validators = options.validators || {}\n    options.selectors = options.selectors || {}\n\n    /**\n     * Local reference to the libp2p-switch instance\n     *\n     * @type {Switch}\n     */\n    this.switch = sw\n\n    /**\n     * k-bucket size, defaults to 20\n     *\n     * @type {number}\n     */\n    this.kBucketSize = options.kBucketSize || c.K\n\n    /**\n     * ALPHA concurrency at which each query path with run, defaults to 3\n     * @type {number}\n     */\n    this.concurrency = options.concurrency || c.ALPHA\n\n    /**\n     * Number of disjoint query paths to use\n     * This is set to `kBucketSize`/2 per the S/Kademlia paper\n     * @type {number}\n     */\n    this.disjointPaths = Math.ceil(this.kBucketSize / 2)\n\n    /**\n     * The routing table.\n     *\n     * @type {RoutingTable}\n     */\n    this.routingTable = new RoutingTable(this.peerInfo.id, this.kBucketSize)\n\n    /**\n     * Reference to the datastore, uses an in-memory store if none given.\n     *\n     * @type {Datastore}\n     */\n    this.datastore = options.datastore || new MemoryStore()\n\n    /**\n     * Provider management\n     *\n     * @type {Providers}\n     */\n    this.providers = new Providers(this.datastore, this.peerInfo.id)\n\n    this.validators = {\n      pk: libp2pRecord.validator.validators.pk,\n      ...options.validators\n    }\n\n    this.selectors = {\n      pk: libp2pRecord.selection.selectors.pk,\n      ...options.selectors\n    }\n\n    this.network = new Network(this)\n\n    this._log = utils.logger(this.peerInfo.id)\n\n    // Inject private apis so we don't clutter up this file\n    const pa = privateApi(this)\n    Object.keys(pa).forEach((name) => { this[name] = pa[name] })\n\n    /**\n     * Random walk management\n     *\n     * @type {RandomWalk}\n     */\n    this.randomWalk = new RandomWalk(this, options.randomWalk)\n\n    /**\n     * Keeps track of running queries\n     *\n     * @type {QueryManager}\n     */\n    this._queryManager = new QueryManager()\n  }\n\n  /**\n   * Is this DHT running.\n   *\n   * @type {bool}\n   */\n  get isStarted () {\n    return this._running\n  }\n\n  /**\n   * Start listening to incoming connections.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  start (callback) {\n    this._running = true\n    this._queryManager.start()\n    this.network.start((err) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // Start random walk, it will not run if it's disabled\n      this.randomWalk.start()\n      callback()\n    })\n  }\n\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  stop (callback) {\n    this._running = false\n    this.randomWalk.stop()\n    this.providers.stop()\n    this._queryManager.stop()\n    this.network.stop(callback)\n  }\n\n  /**\n   * Local peer (yourself)\n   *\n   * @type {PeerInfo}\n   */\n  get peerInfo () {\n    return this.switch._peerInfo\n  }\n\n  get peerBook () {\n    return this.switch._peerBook\n  }\n\n  /**\n   * Store the given key/value  pair in the DHT.\n   *\n   * @param {Buffer} key\n   * @param {Buffer} value\n   * @param {Object} options - get options\n   * @param {number} options.minPeers - minimum peers that must be put to to consider this a successful operation\n   * (default: closestPeers.length)\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  put (key, value, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    } else {\n      options = options || {}\n    }\n\n    this._log('PutValue %b', key)\n\n    waterfall([\n      (cb) => utils.createPutRecord(key, value, cb),\n      (rec, cb) => waterfall([\n        (cb) => this._putLocal(key, rec, cb),\n        (cb) => this.getClosestPeers(key, { shallow: true }, cb),\n        (peers, cb) => {\n          // Ensure we have a default `minPeers`\n          options.minPeers = options.minPeers || peers.length\n          // filter out the successful puts\n          filter(peers, (peer, cb) => {\n            this._putValueToPeer(key, rec, peer, (err) => {\n              if (err) {\n                this._log.error('Failed to put to peer (%b): %s', peer.id, err)\n                return cb(null, false)\n              }\n              cb(null, true)\n            })\n          }, (err, results) => {\n            if (err) return cb(err)\n\n            // Did we put to enough peers?\n            if (options.minPeers > results.length) {\n              const error = errcode(new Error('Failed to put value to enough peers'), 'ERR_NOT_ENOUGH_PUT_PEERS')\n              this._log.error(error)\n              return cb(error)\n            }\n\n            cb()\n          })\n        }\n      ], cb)\n    ], callback)\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute.\n   *\n   * @param {Buffer} key\n   * @param {Object} options - get options\n   * @param {number} options.timeout - optional timeout (default: 60000)\n   * @param {function(Error, Buffer)} callback\n   * @returns {void}\n   */\n  get (key, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    } else {\n      options = options || {}\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute // default\n    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout\n    }\n\n    this._get(key, options, callback)\n  }\n\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Buffer} key\n   * @param {number} nvals\n   * @param {Object} options - get options\n   * @param {number} options.timeout - optional timeout (default: 60000)\n   * @param {function(Error, Array<{from: PeerId, val: Buffer}>)} callback\n   * @returns {void}\n   */\n  getMany (key, nvals, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    } else {\n      options = options || {}\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute // default\n    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout\n    }\n\n    this._log('getMany %b (%s)', key, nvals)\n    let vals = []\n\n    this._getLocal(key, (err, localRec) => {\n      if (err && nvals === 0) {\n        return callback(err)\n      }\n\n      if (err == null) {\n        vals.push({\n          val: localRec.value,\n          from: this.peerInfo.id\n        })\n      }\n\n      if (vals.length >= nvals) {\n        return callback(null, vals)\n      }\n\n      const paths = []\n      waterfall([\n        (cb) => utils.convertBuffer(key, cb),\n        (id, cb) => {\n          const rtp = this.routingTable.closestPeers(id, this.kBucketSize)\n\n          this._log('peers in rt: %d', rtp.length)\n          if (rtp.length === 0) {\n            const errMsg = 'Failed to lookup key! No peers from routing table!'\n\n            this._log.error(errMsg)\n            return cb(errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE'))\n          }\n\n          // we have peers, lets do the actual query to them\n          const query = new Query(this, key, (pathIndex, numPaths) => {\n            // This function body runs once per disjoint path\n            const pathSize = utils.pathSize(nvals - vals.length, numPaths)\n            const pathVals = []\n            paths.push(pathVals)\n\n            // Here we return the query function to use on this particular disjoint path\n            return async (peer) => {\n              let rec, peers, lookupErr\n              try {\n                const results = await this._getValueOrPeersAsync(peer, key)\n                rec = results.record\n                peers = results.peers\n              } catch (err) {\n                // If we have an invalid record we just want to continue and fetch a new one.\n                if (err.code !== 'ERR_INVALID_RECORD') {\n                  throw err\n                }\n                lookupErr = err\n              }\n\n              const res = { closerPeers: peers }\n\n              if ((rec && rec.value) || lookupErr) {\n                pathVals.push({\n                  val: rec && rec.value,\n                  from: peer\n                })\n              }\n\n              // enough is enough\n              if (pathVals.length >= pathSize) {\n                res.pathComplete = true\n              }\n\n              return res\n            }\n          })\n\n          // run our query\n          timeout((_cb) => {\n            promiseToCallback(query.run(rtp))(_cb)\n          }, options.timeout)((err, res) => {\n            query.stop()\n            cb(err, res)\n          })\n        }\n      ], (err) => {\n        // combine vals from each path\n        vals = [].concat.apply(vals, paths).slice(0, nvals)\n\n        if (err && vals.length === 0) {\n          return callback(err)\n        }\n\n        callback(null, vals)\n      })\n    })\n  }\n\n  /**\n   * Kademlia 'node lookup' operation.\n   *\n   * @param {Buffer} key\n   * @param {Object} options\n   * @param {boolean} options.shallow shallow query\n   * @param {function(Error, Array<PeerId>)} callback\n   * @returns {void}\n   */\n  getClosestPeers (key, options, callback) {\n    this._log('getClosestPeers to %b', key)\n\n    if (typeof options === 'function') {\n      callback = options\n      options = {\n        shallow: false\n      }\n    }\n\n    utils.convertBuffer(key, (err, id) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const tablePeers = this.routingTable.closestPeers(id, this.kBucketSize)\n\n      const q = new Query(this, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in this scope.\n        // Just return the actual query function.\n        return async (peer) => {\n          const closer = await this._closerPeersSingleAsync(key, peer)\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          }\n        }\n      })\n\n      promiseToCallback(q.run(tablePeers))((err, res) => {\n        if (err) {\n          return callback(err)\n        }\n\n        if (!res || !res.finalSet) {\n          return callback(null, [])\n        }\n\n        waterfall([\n          (cb) => utils.sortClosestPeers(Array.from(res.finalSet), id, cb),\n          (sorted, cb) => cb(null, sorted.slice(0, this.kBucketSize))\n        ], callback)\n      })\n    })\n  }\n\n  /**\n   * Get the public key for the given peer id.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PubKey)} callback\n   * @returns {void}\n   */\n  getPublicKey (peer, callback) {\n    this._log('getPublicKey %s', peer.toB58String())\n    // local check\n    let info\n    if (this.peerBook.has(peer)) {\n      info = this.peerBook.get(peer)\n\n      if (info && info.id.pubKey) {\n        this._log('getPublicKey: found local copy')\n        return callback(null, info.id.pubKey)\n      }\n    } else {\n      info = this.peerBook.put(new PeerInfo(peer))\n    }\n    // try the node directly\n    this._getPublicKeyFromNode(peer, (err, pk) => {\n      if (!err) {\n        info.id = new PeerId(peer.id, null, pk)\n        this.peerBook.put(info)\n\n        return callback(null, pk)\n      }\n\n      // dht directly\n      const pkKey = utils.keyForPublicKey(peer)\n      this.get(pkKey, (err, value) => {\n        if (err) {\n          return callback(err)\n        }\n\n        const pk = crypto.unmarshalPublicKey(value)\n        info.id = new PeerId(peer, null, pk)\n        this.peerBook.put(info)\n\n        callback(null, pk)\n      })\n    })\n  }\n\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns the `PeerInfo` for it, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PeerInfo)} callback\n   * @returns {void}\n   */\n  findPeerLocal (peer, callback) {\n    this._log('findPeerLocal %s', peer.toB58String())\n    this.routingTable.find(peer, (err, p) => {\n      if (err) {\n        return callback(err)\n      }\n      if (!p || !this.peerBook.has(p)) {\n        return callback()\n      }\n      callback(null, this.peerBook.get(p))\n    })\n  }\n\n  // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value.\n   *\n   * @param {CID} key\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  provide (key, callback) {\n    this._log('provide: %s', key.toBaseEncodedString())\n\n    const errors = []\n    waterfall([\n      // TODO: refactor this in method in async and remove this wrapper\n      (cb) => promiseToCallback(this.providers.addProvider(key, this.peerInfo.id))(err => cb(err)),\n      (cb) => this.getClosestPeers(key.buffer, cb),\n      (peers, cb) => {\n        const msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0)\n        msg.providerPeers = [this.peerInfo]\n\n        each(peers, (peer, cb) => {\n          this._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String())\n          this.network.sendMessage(peer, msg, (err) => {\n            if (err) errors.push(err)\n            cb()\n          })\n        }, cb)\n      }\n    ], (err) => {\n      if (errors.length) {\n        // This should be infrequent. This means a peer we previously connected\n        // to failed to exchange the provide message. If getClosestPeers was an\n        // iterator, we could continue to pull until we announce to kBucketSize peers.\n        err = errcode(`Failed to provide to ${errors.length} of ${this.kBucketSize} peers`, 'ERR_SOME_PROVIDES_FAILED', { errors })\n      }\n      callback(err)\n    })\n  }\n\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {Object} options - findProviders options\n   * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n   * @param {number} options.maxNumProviders - maximum number of providers to find\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {void}\n   */\n  findProviders (key, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    } else {\n      options = options || {}\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute // default\n    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout\n    }\n\n    options.maxNumProviders = options.maxNumProviders || c.K\n\n    this._log('findProviders %s', key.toBaseEncodedString())\n    this._findNProviders(key, options.timeout, options.maxNumProviders, callback)\n  }\n\n  // ----------- Peer Routing\n\n  /**\n   * Search for a peer with the given ID.\n   *\n   * @param {PeerId} id\n   * @param {Object} options - findPeer options\n   * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n   * @param {function(Error, PeerInfo)} callback\n   * @returns {void}\n   */\n  findPeer (id, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    } else {\n      options = options || {}\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute // default\n    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout\n    }\n\n    this._log('findPeer %s', id.toB58String())\n\n    this.findPeerLocal(id, (err, pi) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // already got it\n      if (pi != null) {\n        this._log('found local')\n        return callback(null, pi)\n      }\n\n      waterfall([\n        (cb) => utils.convertPeerId(id, cb),\n        (key, cb) => {\n          const peers = this.routingTable.closestPeers(key, this.kBucketSize)\n\n          if (peers.length === 0) {\n            return cb(errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED'))\n          }\n\n          // sanity check\n          const match = peers.find((p) => p.isEqual(id))\n          if (match && this.peerBook.has(id)) {\n            this._log('found in peerbook')\n            return cb(null, this.peerBook.get(id))\n          }\n\n          // query the network\n          const query = new Query(this, id.id, () => {\n            // There is no distinction between the disjoint paths,\n            // so there are no per-path variables in this scope.\n            // Just return the actual query function.\n            return async (peer) => {\n              const msg = await this._findPeerSingleAsync(peer, id)\n              const match = msg.closerPeers.find((p) => p.id.isEqual(id))\n\n              // found it\n              if (match) {\n                return {\n                  peer: match,\n                  queryComplete: true\n                }\n              }\n\n              return {\n                closerPeers: msg.closerPeers\n              }\n            }\n          })\n\n          timeout((_cb) => {\n            promiseToCallback(query.run(peers))(_cb)\n          }, options.timeout)((err, res) => {\n            query.stop()\n            cb(err, res)\n          })\n        },\n        (result, cb) => {\n          let success = false\n          result.paths.forEach((result) => {\n            if (result.success) {\n              success = true\n              this.peerBook.put(result.peer)\n            }\n          })\n          this._log('findPeer %s: %s', id.toB58String(), success)\n          if (!success) {\n            return cb(errcode(new Error('No peer found'), 'ERR_NOT_FOUND'))\n          }\n          cb(null, this.peerBook.get(id))\n        }\n      ], callback)\n    })\n  }\n\n  _peerDiscovered (peerInfo) {\n    this.emit('peer', peerInfo)\n  }\n}\n\nmodule.exports = KadDHT\n"]},"metadata":{},"sourceType":"script"}