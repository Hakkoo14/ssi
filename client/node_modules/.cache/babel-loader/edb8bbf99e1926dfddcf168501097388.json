{"ast":null,"code":"'use strict';\n\nvar base32Encode = require('base32-encode');\n\nvar NanoDate = require('timestamp-nano');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar multihash = require('multihashes');\n\nvar debug = require('debug');\n\nvar log = debug('jsipns');\nlog.error = debug('jsipns:error');\n\nvar ipnsEntryProto = require('./pb/ipns.proto');\n\nvar _require2 = require('./utils'),\n    parseRFC3339 = _require2.parseRFC3339;\n\nvar ERRORS = require('./errors');\n\nvar ID_MULTIHASH_CODE = multihash.names.id;\nvar namespace = '/ipns/';\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {number|string} lifetime lifetime of the record (in milliseconds).\n * @param {function(Error, entry)} [callback]\n */\n\nvar create = function create(privateKey, value, seq, lifetime, callback) {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  var isoValidity = new NanoDate(Date.now() + Number(lifetime)).toString();\n  var validityType = ipnsEntryProto.ValidityType.EOL;\n\n  _create(privateKey, value, seq, isoValidity, validityType, callback);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {string} expiration expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * @param {function(Error, entry)} [callback]\n */\n\n\nvar createWithExpiration = function createWithExpiration(privateKey, value, seq, expiration, callback) {\n  var validityType = ipnsEntryProto.ValidityType.EOL;\n\n  _create(privateKey, value, seq, expiration, validityType, callback);\n};\n\nvar _create = function _create(privateKey, value, seq, isoValidity, validityType, callback) {\n  sign(privateKey, value, validityType, isoValidity, function (error, signature) {\n    if (error) {\n      log.error('record signature creation failed');\n      return callback(Object.assign(new Error('record signature verification failed'), {\n        code: ERRORS.ERR_SIGNATURE_CREATION\n      }));\n    }\n\n    var entry = {\n      value: value,\n      signature: signature,\n      validityType: validityType,\n      validity: isoValidity,\n      sequence: seq\n    };\n    log(\"ipns entry for \".concat(value, \" created\"));\n    return callback(null, entry);\n  });\n};\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {Object} publicKey public key for validating the record.\n * @param {Object} entry ipns entry record.\n * @param {function(Error)} [callback]\n */\n\n\nvar _validate = function validate(publicKey, entry, callback) {\n  var value = entry.value,\n      validityType = entry.validityType,\n      validity = entry.validity;\n  var dataForSignature = ipnsEntryDataForSig(value, validityType, validity); // Validate Signature\n\n  publicKey.verify(dataForSignature, entry.signature, function (err, isValid) {\n    if (err || !isValid) {\n      log.error('record signature verification failed');\n      return callback(Object.assign(new Error('record signature verification failed'), {\n        code: ERRORS.ERR_SIGNATURE_VERIFICATION\n      }));\n    } // Validate according to the validity type\n\n\n    if (validityType === ipnsEntryProto.ValidityType.EOL) {\n      var validityDate;\n\n      try {\n        validityDate = parseRFC3339(validity.toString());\n      } catch (e) {\n        log.error('unrecognized validity format (not an rfc3339 format)');\n        return callback(Object.assign(new Error('unrecognized validity format (not an rfc3339 format)'), {\n          code: ERRORS.ERR_UNRECOGNIZED_FORMAT\n        }));\n      }\n\n      if (validityDate < Date.now()) {\n        log.error('record has expired');\n        return callback(Object.assign(new Error('record has expired'), {\n          code: ERRORS.ERR_IPNS_EXPIRED_RECORD\n        }));\n      }\n    } else if (validityType) {\n      log.error('unrecognized validity type');\n      return callback(Object.assign(new Error('unrecognized validity type'), {\n        code: ERRORS.ERR_UNRECOGNIZED_VALIDITY\n      }));\n    }\n\n    log(\"ipns entry for \".concat(value, \" is valid\"));\n    return callback(null, null);\n  });\n};\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validade a record upon receipt, they need\n * the public key associated with it. For olde RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {Object} publicKey public key to embed.\n * @param {Object} entry ipns entry record.\n * @param {function(Error)} [callback]\n * @return {Void}\n */\n\n\nvar embedPublicKey = function embedPublicKey(publicKey, entry, callback) {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    var error = 'one or more of the provided parameters are not defined';\n    log.error(error);\n    return callback(Object.assign(new Error(error), {\n      code: ERRORS.ERR_UNDEFINED_PARAMETER\n    }));\n  } // Create a peer id from the public key.\n\n\n  PeerId.createFromPubKey(publicKey.bytes, function (err, peerId) {\n    if (err) {\n      log.error(err);\n      return callback(Object.assign(new Error(err), {\n        code: ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY\n      }));\n    } // Try to extract the public key from the ID. If we can, no need to embed it\n\n\n    var extractedPublicKey;\n\n    try {\n      extractedPublicKey = extractPublicKeyFromId(peerId);\n    } catch (err) {\n      log.error(err);\n      return callback(Object.assign(new Error(err), {\n        code: ERRORS.ERR_PUBLIC_KEY_FROM_ID\n      }));\n    }\n\n    if (extractedPublicKey) {\n      return callback(null, null);\n    } // If we failed to extract the public key from the peer ID, embed it in the record.\n\n\n    try {\n      entry.pubKey = crypto.keys.marshalPublicKey(publicKey);\n    } catch (err) {\n      log.error(err);\n      return callback(err);\n    }\n\n    callback(null, entry);\n  });\n};\n/**\n * Extracts a public key matching `pid` from the ipns record.\n *\n * @param {Object} peerId peer identifier object.\n * @param {Object} entry ipns entry record.\n * @param {function(Error)} [callback]\n * @return {Void}\n */\n\n\nvar extractPublicKey = function extractPublicKey(peerId, entry, callback) {\n  if (!entry || !peerId) {\n    var error = 'one or more of the provided parameters are not defined';\n    log.error(error);\n    return callback(Object.assign(new Error(error), {\n      code: ERRORS.ERR_UNDEFINED_PARAMETER\n    }));\n  }\n\n  if (entry.pubKey) {\n    var pubKey;\n\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      return callback(err);\n    }\n\n    return callback(null, pubKey);\n  }\n\n  if (peerId.pubKey) {\n    callback(null, peerId.pubKey);\n  } else {\n    callback(Object.assign(new Error('no public key is available'), {\n      code: ERRORS.ERR_UNDEFINED_PARAMETER\n    }));\n  }\n}; // rawStdEncoding with RFC4648\n\n\nvar rawStdEncoding = function rawStdEncoding(key) {\n  return base32Encode(key, 'RFC4648', {\n    padding: false\n  });\n};\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Buffer} key peer identifier object.\n * @returns {string}\n */\n\n\nvar getLocalKey = function getLocalKey(key) {\n  return new Key(\"/ipns/\".concat(rawStdEncoding(key)));\n};\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Buffer} pid peer identifier represented by the multihash of the public key as Buffer.\n * @returns {Object} containing the `nameKey` and the `ipnsKey`.\n */\n\n\nvar getIdKeys = function getIdKeys(pid) {\n  var pkBuffer = Buffer.from('/pk/');\n  var ipnsBuffer = Buffer.from('/ipns/');\n  return {\n    routingPubKey: new Key(Buffer.concat([pkBuffer, pid])),\n    // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(Buffer.concat([pkBuffer, pid]))),\n    routingKey: new Key(Buffer.concat([ipnsBuffer, pid])),\n    // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(Buffer.concat([ipnsBuffer, pid])))\n  };\n}; // Sign ipns record data\n\n\nvar sign = function sign(privateKey, value, validityType, validity, callback) {\n  var dataForSignature = ipnsEntryDataForSig(value, validityType, validity);\n  privateKey.sign(dataForSignature, function (err, signature) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null, signature);\n  });\n}; // Utility for getting the validity type code name of a validity\n\n\nvar getValidityType = function getValidityType(validityType) {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  } else {\n    var error = \"unrecognized validity type \".concat(validityType.toString());\n    log.error(error);\n    throw Object.assign(new Error(error), {\n      code: ERRORS.ERR_UNRECOGNIZED_VALIDITY\n    });\n  }\n}; // Utility for creating the record data for being signed\n\n\nvar ipnsEntryDataForSig = function ipnsEntryDataForSig(value, validityType, validity) {\n  var valueBuffer = Buffer.from(value);\n  var validityTypeBuffer = Buffer.from(getValidityType(validityType));\n  var validityBuffer = Buffer.from(validity);\n  return Buffer.concat([valueBuffer, validityBuffer, validityTypeBuffer]);\n}; // Utility for extracting the public key from a peer-id\n\n\nvar extractPublicKeyFromId = function extractPublicKeyFromId(peerId) {\n  var decodedId = multihash.decode(peerId.id);\n\n  if (decodedId.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n\n  return crypto.keys.unmarshalPublicKey(decodedId.digest);\n};\n\nvar marshal = ipnsEntryProto.encode;\nvar unmarshal = ipnsEntryProto.decode;\nvar validator = {\n  validate: function validate(marshalledData, key, callback) {\n    var receivedEntry = unmarshal(marshalledData);\n    var bufferId = key.slice('/ipns/'.length);\n    var peerId;\n\n    try {\n      peerId = PeerId.createFromBytes(bufferId);\n    } catch (err) {\n      return callback(err);\n    } // extract public key\n\n\n    extractPublicKey(peerId, receivedEntry, function (err, pubKey) {\n      if (err) {\n        return callback(err);\n      } // Record validation\n\n\n      _validate(pubKey, receivedEntry, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, true);\n      });\n    });\n  },\n  select: function select(dataA, dataB, callback) {\n    var entryA = unmarshal(dataA);\n    var entryB = unmarshal(dataB);\n    var index = entryA.sequence > entryB.sequence ? 0 : 1;\n\n    if (typeof callback !== 'function') {\n      return index;\n    }\n\n    callback(null, index);\n  }\n};\nmodule.exports = {\n  // create ipns entry record\n  create: create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration: createWithExpiration,\n  // validate ipns entry record\n  validate: _validate,\n  // embed public key in the record\n  embedPublicKey: embedPublicKey,\n  // extract public key from the record\n  extractPublicKey: extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey: getLocalKey,\n  // get keys for routing\n  getIdKeys: getIdKeys,\n  // marshal\n  marshal: marshal,\n  // unmarshal\n  unmarshal: unmarshal,\n  // validator\n  validator: validator,\n  // namespace\n  namespace: namespace,\n  namespaceLength: namespace.length\n};","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipns/src/index.js"],"names":["base32Encode","require","NanoDate","Key","crypto","PeerId","multihash","debug","log","error","ipnsEntryProto","parseRFC3339","ERRORS","ID_MULTIHASH_CODE","names","id","namespace","create","privateKey","value","seq","lifetime","callback","isoValidity","Date","now","Number","toString","validityType","ValidityType","EOL","_create","createWithExpiration","expiration","sign","signature","Object","assign","Error","code","ERR_SIGNATURE_CREATION","entry","validity","sequence","validate","publicKey","dataForSignature","ipnsEntryDataForSig","verify","err","isValid","ERR_SIGNATURE_VERIFICATION","validityDate","e","ERR_UNRECOGNIZED_FORMAT","ERR_IPNS_EXPIRED_RECORD","ERR_UNRECOGNIZED_VALIDITY","embedPublicKey","bytes","ERR_UNDEFINED_PARAMETER","createFromPubKey","peerId","ERR_PEER_ID_FROM_PUBLIC_KEY","extractedPublicKey","extractPublicKeyFromId","ERR_PUBLIC_KEY_FROM_ID","pubKey","keys","marshalPublicKey","extractPublicKey","unmarshalPublicKey","rawStdEncoding","key","padding","getLocalKey","getIdKeys","pid","pkBuffer","Buffer","from","ipnsBuffer","routingPubKey","concat","pkKey","routingKey","ipnsKey","getValidityType","valueBuffer","validityTypeBuffer","validityBuffer","decodedId","decode","digest","marshal","encode","unmarshal","validator","marshalledData","receivedEntry","bufferId","slice","length","createFromBytes","select","dataA","dataB","entryA","entryB","index","module","exports","namespaceLength"],"mappings":"AAAA;;AAEA,IAAMA,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA5B;;AACA,IAAMC,QAAQ,GAAGD,OAAO,CAAC,gBAAD,CAAxB;;AACA,eAAgBA,OAAO,CAAC,qBAAD,CAAvB;AAAA,IAAQE,GAAR,YAAQA,GAAR;;AACA,IAAMC,MAAM,GAAGH,OAAO,CAAC,eAAD,CAAtB;;AACA,IAAMI,MAAM,GAAGJ,OAAO,CAAC,SAAD,CAAtB;;AACA,IAAMK,SAAS,GAAGL,OAAO,CAAC,aAAD,CAAzB;;AAEA,IAAMM,KAAK,GAAGN,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMO,GAAG,GAAGD,KAAK,CAAC,QAAD,CAAjB;AACAC,GAAG,CAACC,KAAJ,GAAYF,KAAK,CAAC,cAAD,CAAjB;;AAEA,IAAMG,cAAc,GAAGT,OAAO,CAAC,iBAAD,CAA9B;;AACA,gBAAyBA,OAAO,CAAC,SAAD,CAAhC;AAAA,IAAQU,YAAR,aAAQA,YAAR;;AACA,IAAMC,MAAM,GAAGX,OAAO,CAAC,UAAD,CAAtB;;AAEA,IAAMY,iBAAiB,GAAGP,SAAS,CAACQ,KAAV,CAAgBC,EAA1C;AAEA,IAAMC,SAAS,GAAG,QAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,MAAM,GAAG,SAATA,MAAS,CAACC,UAAD,EAAaC,KAAb,EAAoBC,GAApB,EAAyBC,QAAzB,EAAmCC,QAAnC,EAAgD;AAC7D;AACA,MAAMC,WAAW,GAAG,IAAIrB,QAAJ,CAAasB,IAAI,CAACC,GAAL,KAAaC,MAAM,CAACL,QAAD,CAAhC,EAA4CM,QAA5C,EAApB;AACA,MAAMC,YAAY,GAAGlB,cAAc,CAACmB,YAAf,CAA4BC,GAAjD;;AACAC,EAAAA,OAAO,CAACb,UAAD,EAAaC,KAAb,EAAoBC,GAApB,EAAyBG,WAAzB,EAAsCK,YAAtC,EAAoDN,QAApD,CAAP;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMU,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACd,UAAD,EAAaC,KAAb,EAAoBC,GAApB,EAAyBa,UAAzB,EAAqCX,QAArC,EAAkD;AAC7E,MAAMM,YAAY,GAAGlB,cAAc,CAACmB,YAAf,CAA4BC,GAAjD;;AACAC,EAAAA,OAAO,CAACb,UAAD,EAAaC,KAAb,EAAoBC,GAApB,EAAyBa,UAAzB,EAAqCL,YAArC,EAAmDN,QAAnD,CAAP;AACD,CAHD;;AAKA,IAAMS,OAAO,GAAG,SAAVA,OAAU,CAACb,UAAD,EAAaC,KAAb,EAAoBC,GAApB,EAAyBG,WAAzB,EAAsCK,YAAtC,EAAoDN,QAApD,EAAiE;AAC/EY,EAAAA,IAAI,CAAChB,UAAD,EAAaC,KAAb,EAAoBS,YAApB,EAAkCL,WAAlC,EAA+C,UAACd,KAAD,EAAQ0B,SAAR,EAAsB;AACvE,QAAI1B,KAAJ,EAAW;AACTD,MAAAA,GAAG,CAACC,KAAJ,CAAU,kCAAV;AACA,aAAOa,QAAQ,CAACc,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,sCAAV,CAAd,EAAiE;AAAEC,QAAAA,IAAI,EAAE3B,MAAM,CAAC4B;AAAf,OAAjE,CAAD,CAAf;AACD;;AAED,QAAMC,KAAK,GAAG;AACZtB,MAAAA,KAAK,EAAEA,KADK;AAEZgB,MAAAA,SAAS,EAAEA,SAFC;AAGZP,MAAAA,YAAY,EAAEA,YAHF;AAIZc,MAAAA,QAAQ,EAAEnB,WAJE;AAKZoB,MAAAA,QAAQ,EAAEvB;AALE,KAAd;AAQAZ,IAAAA,GAAG,0BAAmBW,KAAnB,cAAH;AACA,WAAOG,QAAQ,CAAC,IAAD,EAAOmB,KAAP,CAAf;AACD,GAhBG,CAAJ;AAiBD,CAlBD;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,SAAQ,GAAG,SAAXA,QAAW,CAACC,SAAD,EAAYJ,KAAZ,EAAmBnB,QAAnB,EAAgC;AAC/C,MAAQH,KAAR,GAA0CsB,KAA1C,CAAQtB,KAAR;AAAA,MAAeS,YAAf,GAA0Ca,KAA1C,CAAeb,YAAf;AAAA,MAA6Bc,QAA7B,GAA0CD,KAA1C,CAA6BC,QAA7B;AACA,MAAMI,gBAAgB,GAAGC,mBAAmB,CAAC5B,KAAD,EAAQS,YAAR,EAAsBc,QAAtB,CAA5C,CAF+C,CAI/C;;AACAG,EAAAA,SAAS,CAACG,MAAV,CAAiBF,gBAAjB,EAAmCL,KAAK,CAACN,SAAzC,EAAoD,UAACc,GAAD,EAAMC,OAAN,EAAkB;AACpE,QAAID,GAAG,IAAI,CAACC,OAAZ,EAAqB;AACnB1C,MAAAA,GAAG,CAACC,KAAJ,CAAU,sCAAV;AACA,aAAOa,QAAQ,CAACc,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,sCAAV,CAAd,EAAiE;AAAEC,QAAAA,IAAI,EAAE3B,MAAM,CAACuC;AAAf,OAAjE,CAAD,CAAf;AACD,KAJmE,CAMpE;;;AACA,QAAIvB,YAAY,KAAKlB,cAAc,CAACmB,YAAf,CAA4BC,GAAjD,EAAsD;AACpD,UAAIsB,YAAJ;;AAEA,UAAI;AACFA,QAAAA,YAAY,GAAGzC,YAAY,CAAC+B,QAAQ,CAACf,QAAT,EAAD,CAA3B;AACD,OAFD,CAEE,OAAO0B,CAAP,EAAU;AACV7C,QAAAA,GAAG,CAACC,KAAJ,CAAU,sDAAV;AACA,eAAOa,QAAQ,CAACc,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,sDAAV,CAAd,EAAiF;AAAEC,UAAAA,IAAI,EAAE3B,MAAM,CAAC0C;AAAf,SAAjF,CAAD,CAAf;AACD;;AAED,UAAIF,YAAY,GAAG5B,IAAI,CAACC,GAAL,EAAnB,EAA+B;AAC7BjB,QAAAA,GAAG,CAACC,KAAJ,CAAU,oBAAV;AACA,eAAOa,QAAQ,CAACc,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,oBAAV,CAAd,EAA+C;AAAEC,UAAAA,IAAI,EAAE3B,MAAM,CAAC2C;AAAf,SAA/C,CAAD,CAAf;AACD;AACF,KAdD,MAcO,IAAI3B,YAAJ,EAAkB;AACvBpB,MAAAA,GAAG,CAACC,KAAJ,CAAU,4BAAV;AACA,aAAOa,QAAQ,CAACc,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,4BAAV,CAAd,EAAuD;AAAEC,QAAAA,IAAI,EAAE3B,MAAM,CAAC4C;AAAf,OAAvD,CAAD,CAAf;AACD;;AAEDhD,IAAAA,GAAG,0BAAmBW,KAAnB,eAAH;AACA,WAAOG,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAf;AACD,GA5BD;AA6BD,CAlCD;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMmC,cAAc,GAAG,SAAjBA,cAAiB,CAACZ,SAAD,EAAYJ,KAAZ,EAAmBnB,QAAnB,EAAgC;AACrD,MAAI,CAACuB,SAAD,IAAc,CAACA,SAAS,CAACa,KAAzB,IAAkC,CAACjB,KAAvC,EAA8C;AAC5C,QAAMhC,KAAK,GAAG,wDAAd;AAEAD,IAAAA,GAAG,CAACC,KAAJ,CAAUA,KAAV;AACA,WAAOa,QAAQ,CAACc,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU7B,KAAV,CAAd,EAAgC;AAAE8B,MAAAA,IAAI,EAAE3B,MAAM,CAAC+C;AAAf,KAAhC,CAAD,CAAf;AACD,GANoD,CAQrD;;;AACAtD,EAAAA,MAAM,CAACuD,gBAAP,CAAwBf,SAAS,CAACa,KAAlC,EAAyC,UAACT,GAAD,EAAMY,MAAN,EAAiB;AACxD,QAAIZ,GAAJ,EAAS;AACPzC,MAAAA,GAAG,CAACC,KAAJ,CAAUwC,GAAV;AACA,aAAO3B,QAAQ,CAACc,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAUW,GAAV,CAAd,EAA8B;AAAEV,QAAAA,IAAI,EAAE3B,MAAM,CAACkD;AAAf,OAA9B,CAAD,CAAf;AACD,KAJuD,CAMxD;;;AACA,QAAIC,kBAAJ;;AACA,QAAI;AACFA,MAAAA,kBAAkB,GAAGC,sBAAsB,CAACH,MAAD,CAA3C;AACD,KAFD,CAEE,OAAOZ,GAAP,EAAY;AACZzC,MAAAA,GAAG,CAACC,KAAJ,CAAUwC,GAAV;AACA,aAAO3B,QAAQ,CAACc,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAUW,GAAV,CAAd,EAA8B;AAAEV,QAAAA,IAAI,EAAE3B,MAAM,CAACqD;AAAf,OAA9B,CAAD,CAAf;AACD;;AAED,QAAIF,kBAAJ,EAAwB;AACtB,aAAOzC,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAf;AACD,KAjBuD,CAmBxD;;;AACA,QAAI;AACFmB,MAAAA,KAAK,CAACyB,MAAN,GAAe9D,MAAM,CAAC+D,IAAP,CAAYC,gBAAZ,CAA6BvB,SAA7B,CAAf;AACD,KAFD,CAEE,OAAOI,GAAP,EAAY;AACZzC,MAAAA,GAAG,CAACC,KAAJ,CAAUwC,GAAV;AACA,aAAO3B,QAAQ,CAAC2B,GAAD,CAAf;AACD;;AACD3B,IAAAA,QAAQ,CAAC,IAAD,EAAOmB,KAAP,CAAR;AACD,GA3BD;AA4BD,CArCD;AAuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAM4B,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACR,MAAD,EAASpB,KAAT,EAAgBnB,QAAhB,EAA6B;AACpD,MAAI,CAACmB,KAAD,IAAU,CAACoB,MAAf,EAAuB;AACrB,QAAMpD,KAAK,GAAG,wDAAd;AAEAD,IAAAA,GAAG,CAACC,KAAJ,CAAUA,KAAV;AACA,WAAOa,QAAQ,CAACc,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU7B,KAAV,CAAd,EAAgC;AAAE8B,MAAAA,IAAI,EAAE3B,MAAM,CAAC+C;AAAf,KAAhC,CAAD,CAAf;AACD;;AAED,MAAIlB,KAAK,CAACyB,MAAV,EAAkB;AAChB,QAAIA,MAAJ;;AACA,QAAI;AACFA,MAAAA,MAAM,GAAG9D,MAAM,CAAC+D,IAAP,CAAYG,kBAAZ,CAA+B7B,KAAK,CAACyB,MAArC,CAAT;AACD,KAFD,CAEE,OAAOjB,GAAP,EAAY;AACZzC,MAAAA,GAAG,CAACC,KAAJ,CAAUwC,GAAV;AACA,aAAO3B,QAAQ,CAAC2B,GAAD,CAAf;AACD;;AACD,WAAO3B,QAAQ,CAAC,IAAD,EAAO4C,MAAP,CAAf;AACD;;AAED,MAAIL,MAAM,CAACK,MAAX,EAAmB;AACjB5C,IAAAA,QAAQ,CAAC,IAAD,EAAOuC,MAAM,CAACK,MAAd,CAAR;AACD,GAFD,MAEO;AACL5C,IAAAA,QAAQ,CAACc,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,4BAAV,CAAd,EAAuD;AAAEC,MAAAA,IAAI,EAAE3B,MAAM,CAAC+C;AAAf,KAAvD,CAAD,CAAR;AACD;AACF,CAxBD,C,CA0BA;;;AACA,IAAMY,cAAc,GAAG,SAAjBA,cAAiB,CAACC,GAAD;AAAA,SAASxE,YAAY,CAACwE,GAAD,EAAM,SAAN,EAAiB;AAAEC,IAAAA,OAAO,EAAE;AAAX,GAAjB,CAArB;AAAA,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACF,GAAD;AAAA,SAAS,IAAIrE,GAAJ,iBAAiBoE,cAAc,CAACC,GAAD,CAA/B,EAAT;AAAA,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,SAAS,GAAG,SAAZA,SAAY,CAACC,GAAD,EAAS;AACzB,MAAMC,QAAQ,GAAGC,MAAM,CAACC,IAAP,CAAY,MAAZ,CAAjB;AACA,MAAMC,UAAU,GAAGF,MAAM,CAACC,IAAP,CAAY,QAAZ,CAAnB;AAEA,SAAO;AACLE,IAAAA,aAAa,EAAE,IAAI9E,GAAJ,CAAQ2E,MAAM,CAACI,MAAP,CAAc,CAACL,QAAD,EAAWD,GAAX,CAAd,CAAR,CADV;AACmD;AACxDO,IAAAA,KAAK,EAAE,IAAIhF,GAAJ,CAAQoE,cAAc,CAACO,MAAM,CAACI,MAAP,CAAc,CAACL,QAAD,EAAWD,GAAX,CAAd,CAAD,CAAtB,CAFF;AAGLQ,IAAAA,UAAU,EAAE,IAAIjF,GAAJ,CAAQ2E,MAAM,CAACI,MAAP,CAAc,CAACF,UAAD,EAAaJ,GAAb,CAAd,CAAR,CAHP;AAGkD;AACvDS,IAAAA,OAAO,EAAE,IAAIlF,GAAJ,CAAQoE,cAAc,CAACO,MAAM,CAACI,MAAP,CAAc,CAACF,UAAD,EAAaJ,GAAb,CAAd,CAAD,CAAtB;AAJJ,GAAP;AAMD,CAVD,C,CAYA;;;AACA,IAAM1C,IAAI,GAAG,SAAPA,IAAO,CAAChB,UAAD,EAAaC,KAAb,EAAoBS,YAApB,EAAkCc,QAAlC,EAA4CpB,QAA5C,EAAyD;AACpE,MAAMwB,gBAAgB,GAAGC,mBAAmB,CAAC5B,KAAD,EAAQS,YAAR,EAAsBc,QAAtB,CAA5C;AAEAxB,EAAAA,UAAU,CAACgB,IAAX,CAAgBY,gBAAhB,EAAkC,UAACG,GAAD,EAAMd,SAAN,EAAoB;AACpD,QAAIc,GAAJ,EAAS;AACP,aAAO3B,QAAQ,CAAC2B,GAAD,CAAf;AACD;;AACD,WAAO3B,QAAQ,CAAC,IAAD,EAAOa,SAAP,CAAf;AACD,GALD;AAMD,CATD,C,CAWA;;;AACA,IAAMmD,eAAe,GAAG,SAAlBA,eAAkB,CAAC1D,YAAD,EAAkB;AACxC,MAAIA,YAAY,CAACD,QAAb,OAA4B,GAAhC,EAAqC;AACnC,WAAO,KAAP;AACD,GAFD,MAEO;AACL,QAAMlB,KAAK,wCAAiCmB,YAAY,CAACD,QAAb,EAAjC,CAAX;AACAnB,IAAAA,GAAG,CAACC,KAAJ,CAAUA,KAAV;AACA,UAAM2B,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU7B,KAAV,CAAd,EAAgC;AAAE8B,MAAAA,IAAI,EAAE3B,MAAM,CAAC4C;AAAf,KAAhC,CAAN;AACD;AACF,CARD,C,CAUA;;;AACA,IAAMT,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAC5B,KAAD,EAAQS,YAAR,EAAsBc,QAAtB,EAAmC;AAC7D,MAAM6C,WAAW,GAAGT,MAAM,CAACC,IAAP,CAAY5D,KAAZ,CAApB;AACA,MAAMqE,kBAAkB,GAAGV,MAAM,CAACC,IAAP,CAAYO,eAAe,CAAC1D,YAAD,CAA3B,CAA3B;AACA,MAAM6D,cAAc,GAAGX,MAAM,CAACC,IAAP,CAAYrC,QAAZ,CAAvB;AAEA,SAAOoC,MAAM,CAACI,MAAP,CAAc,CAACK,WAAD,EAAcE,cAAd,EAA8BD,kBAA9B,CAAd,CAAP;AACD,CAND,C,CAQA;;;AACA,IAAMxB,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACH,MAAD,EAAY;AACzC,MAAM6B,SAAS,GAAGpF,SAAS,CAACqF,MAAV,CAAiB9B,MAAM,CAAC9C,EAAxB,CAAlB;;AAEA,MAAI2E,SAAS,CAACnD,IAAV,KAAmB1B,iBAAvB,EAA0C;AACxC,WAAO,IAAP;AACD;;AAED,SAAOT,MAAM,CAAC+D,IAAP,CAAYG,kBAAZ,CAA+BoB,SAAS,CAACE,MAAzC,CAAP;AACD,CARD;;AAUA,IAAMC,OAAO,GAAGnF,cAAc,CAACoF,MAA/B;AAEA,IAAMC,SAAS,GAAGrF,cAAc,CAACiF,MAAjC;AAEA,IAAMK,SAAS,GAAG;AAChBpD,EAAAA,QAAQ,EAAE,kBAACqD,cAAD,EAAiBzB,GAAjB,EAAsBlD,QAAtB,EAAmC;AAC3C,QAAM4E,aAAa,GAAGH,SAAS,CAACE,cAAD,CAA/B;AACA,QAAME,QAAQ,GAAG3B,GAAG,CAAC4B,KAAJ,CAAU,SAASC,MAAnB,CAAjB;AACA,QAAIxC,MAAJ;;AAEA,QAAI;AACFA,MAAAA,MAAM,GAAGxD,MAAM,CAACiG,eAAP,CAAuBH,QAAvB,CAAT;AACD,KAFD,CAEE,OAAOlD,GAAP,EAAY;AACZ,aAAO3B,QAAQ,CAAC2B,GAAD,CAAf;AACD,KAT0C,CAW3C;;;AACAoB,IAAAA,gBAAgB,CAACR,MAAD,EAASqC,aAAT,EAAwB,UAACjD,GAAD,EAAMiB,MAAN,EAAiB;AACvD,UAAIjB,GAAJ,EAAS;AACP,eAAO3B,QAAQ,CAAC2B,GAAD,CAAf;AACD,OAHsD,CAKvD;;;AACAL,MAAAA,SAAQ,CAACsB,MAAD,EAASgC,aAAT,EAAwB,UAACjD,GAAD,EAAS;AACvC,YAAIA,GAAJ,EAAS;AACP,iBAAO3B,QAAQ,CAAC2B,GAAD,CAAf;AACD;;AAED3B,QAAAA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACD,OANO,CAAR;AAOD,KAbe,CAAhB;AAcD,GA3Be;AA4BhBiF,EAAAA,MAAM,EAAE,gBAACC,KAAD,EAAQC,KAAR,EAAenF,QAAf,EAA4B;AAClC,QAAMoF,MAAM,GAAGX,SAAS,CAACS,KAAD,CAAxB;AACA,QAAMG,MAAM,GAAGZ,SAAS,CAACU,KAAD,CAAxB;AAEA,QAAMG,KAAK,GAAGF,MAAM,CAAC/D,QAAP,GAAkBgE,MAAM,CAAChE,QAAzB,GAAoC,CAApC,GAAwC,CAAtD;;AAEA,QAAI,OAAOrB,QAAP,KAAoB,UAAxB,EAAoC;AAClC,aAAOsF,KAAP;AACD;;AAEDtF,IAAAA,QAAQ,CAAC,IAAD,EAAOsF,KAAP,CAAR;AACD;AAvCe,CAAlB;AA0CAC,MAAM,CAACC,OAAP,GAAiB;AACf;AACA7F,EAAAA,MAAM,EAANA,MAFe;AAGf;AACAe,EAAAA,oBAAoB,EAApBA,oBAJe;AAKf;AACAY,EAAAA,QAAQ,EAARA,SANe;AAOf;AACAa,EAAAA,cAAc,EAAdA,cARe;AASf;AACAY,EAAAA,gBAAgB,EAAhBA,gBAVe;AAWf;AACAK,EAAAA,WAAW,EAAXA,WAZe;AAaf;AACAC,EAAAA,SAAS,EAATA,SAde;AAef;AACAkB,EAAAA,OAAO,EAAPA,OAhBe;AAiBf;AACAE,EAAAA,SAAS,EAATA,SAlBe;AAmBf;AACAC,EAAAA,SAAS,EAATA,SApBe;AAqBf;AACAhF,EAAAA,SAAS,EAATA,SAtBe;AAuBf+F,EAAAA,eAAe,EAAE/F,SAAS,CAACqF;AAvBZ,CAAjB","sourcesContent":["'use strict'\n\nconst base32Encode = require('base32-encode')\nconst NanoDate = require('timestamp-nano')\nconst { Key } = require('interface-datastore')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst multihash = require('multihashes')\n\nconst debug = require('debug')\nconst log = debug('jsipns')\nlog.error = debug('jsipns:error')\n\nconst ipnsEntryProto = require('./pb/ipns.proto')\nconst { parseRFC3339 } = require('./utils')\nconst ERRORS = require('./errors')\n\nconst ID_MULTIHASH_CODE = multihash.names.id\n\nconst namespace = '/ipns/'\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {number|string} lifetime lifetime of the record (in milliseconds).\n * @param {function(Error, entry)} [callback]\n */\nconst create = (privateKey, value, seq, lifetime, callback) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const isoValidity = new NanoDate(Date.now() + Number(lifetime)).toString()\n  const validityType = ipnsEntryProto.ValidityType.EOL\n  _create(privateKey, value, seq, isoValidity, validityType, callback)\n}\n\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {string} expiration expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * @param {function(Error, entry)} [callback]\n */\nconst createWithExpiration = (privateKey, value, seq, expiration, callback) => {\n  const validityType = ipnsEntryProto.ValidityType.EOL\n  _create(privateKey, value, seq, expiration, validityType, callback)\n}\n\nconst _create = (privateKey, value, seq, isoValidity, validityType, callback) => {\n  sign(privateKey, value, validityType, isoValidity, (error, signature) => {\n    if (error) {\n      log.error('record signature creation failed')\n      return callback(Object.assign(new Error('record signature verification failed'), { code: ERRORS.ERR_SIGNATURE_CREATION }))\n    }\n\n    const entry = {\n      value: value,\n      signature: signature,\n      validityType: validityType,\n      validity: isoValidity,\n      sequence: seq\n    }\n\n    log(`ipns entry for ${value} created`)\n    return callback(null, entry)\n  })\n}\n\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {Object} publicKey public key for validating the record.\n * @param {Object} entry ipns entry record.\n * @param {function(Error)} [callback]\n */\nconst validate = (publicKey, entry, callback) => {\n  const { value, validityType, validity } = entry\n  const dataForSignature = ipnsEntryDataForSig(value, validityType, validity)\n\n  // Validate Signature\n  publicKey.verify(dataForSignature, entry.signature, (err, isValid) => {\n    if (err || !isValid) {\n      log.error('record signature verification failed')\n      return callback(Object.assign(new Error('record signature verification failed'), { code: ERRORS.ERR_SIGNATURE_VERIFICATION }))\n    }\n\n    // Validate according to the validity type\n    if (validityType === ipnsEntryProto.ValidityType.EOL) {\n      let validityDate\n\n      try {\n        validityDate = parseRFC3339(validity.toString())\n      } catch (e) {\n        log.error('unrecognized validity format (not an rfc3339 format)')\n        return callback(Object.assign(new Error('unrecognized validity format (not an rfc3339 format)'), { code: ERRORS.ERR_UNRECOGNIZED_FORMAT }))\n      }\n\n      if (validityDate < Date.now()) {\n        log.error('record has expired')\n        return callback(Object.assign(new Error('record has expired'), { code: ERRORS.ERR_IPNS_EXPIRED_RECORD }))\n      }\n    } else if (validityType) {\n      log.error('unrecognized validity type')\n      return callback(Object.assign(new Error('unrecognized validity type'), { code: ERRORS.ERR_UNRECOGNIZED_VALIDITY }))\n    }\n\n    log(`ipns entry for ${value} is valid`)\n    return callback(null, null)\n  })\n}\n\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validade a record upon receipt, they need\n * the public key associated with it. For olde RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {Object} publicKey public key to embed.\n * @param {Object} entry ipns entry record.\n * @param {function(Error)} [callback]\n * @return {Void}\n */\nconst embedPublicKey = (publicKey, entry, callback) => {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    const error = 'one or more of the provided parameters are not defined'\n\n    log.error(error)\n    return callback(Object.assign(new Error(error), { code: ERRORS.ERR_UNDEFINED_PARAMETER }))\n  }\n\n  // Create a peer id from the public key.\n  PeerId.createFromPubKey(publicKey.bytes, (err, peerId) => {\n    if (err) {\n      log.error(err)\n      return callback(Object.assign(new Error(err), { code: ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY }))\n    }\n\n    // Try to extract the public key from the ID. If we can, no need to embed it\n    let extractedPublicKey\n    try {\n      extractedPublicKey = extractPublicKeyFromId(peerId)\n    } catch (err) {\n      log.error(err)\n      return callback(Object.assign(new Error(err), { code: ERRORS.ERR_PUBLIC_KEY_FROM_ID }))\n    }\n\n    if (extractedPublicKey) {\n      return callback(null, null)\n    }\n\n    // If we failed to extract the public key from the peer ID, embed it in the record.\n    try {\n      entry.pubKey = crypto.keys.marshalPublicKey(publicKey)\n    } catch (err) {\n      log.error(err)\n      return callback(err)\n    }\n    callback(null, entry)\n  })\n}\n\n/**\n * Extracts a public key matching `pid` from the ipns record.\n *\n * @param {Object} peerId peer identifier object.\n * @param {Object} entry ipns entry record.\n * @param {function(Error)} [callback]\n * @return {Void}\n */\nconst extractPublicKey = (peerId, entry, callback) => {\n  if (!entry || !peerId) {\n    const error = 'one or more of the provided parameters are not defined'\n\n    log.error(error)\n    return callback(Object.assign(new Error(error), { code: ERRORS.ERR_UNDEFINED_PARAMETER }))\n  }\n\n  if (entry.pubKey) {\n    let pubKey\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey)\n    } catch (err) {\n      log.error(err)\n      return callback(err)\n    }\n    return callback(null, pubKey)\n  }\n\n  if (peerId.pubKey) {\n    callback(null, peerId.pubKey)\n  } else {\n    callback(Object.assign(new Error('no public key is available'), { code: ERRORS.ERR_UNDEFINED_PARAMETER }))\n  }\n}\n\n// rawStdEncoding with RFC4648\nconst rawStdEncoding = (key) => base32Encode(key, 'RFC4648', { padding: false })\n\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Buffer} key peer identifier object.\n * @returns {string}\n */\nconst getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`)\n\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Buffer} pid peer identifier represented by the multihash of the public key as Buffer.\n * @returns {Object} containing the `nameKey` and the `ipnsKey`.\n */\nconst getIdKeys = (pid) => {\n  const pkBuffer = Buffer.from('/pk/')\n  const ipnsBuffer = Buffer.from('/ipns/')\n\n  return {\n    routingPubKey: new Key(Buffer.concat([pkBuffer, pid])), // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(Buffer.concat([pkBuffer, pid]))),\n    routingKey: new Key(Buffer.concat([ipnsBuffer, pid])), // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(Buffer.concat([ipnsBuffer, pid])))\n  }\n}\n\n// Sign ipns record data\nconst sign = (privateKey, value, validityType, validity, callback) => {\n  const dataForSignature = ipnsEntryDataForSig(value, validityType, validity)\n\n  privateKey.sign(dataForSignature, (err, signature) => {\n    if (err) {\n      return callback(err)\n    }\n    return callback(null, signature)\n  })\n}\n\n// Utility for getting the validity type code name of a validity\nconst getValidityType = (validityType) => {\n  if (validityType.toString() === '0') {\n    return 'EOL'\n  } else {\n    const error = `unrecognized validity type ${validityType.toString()}`\n    log.error(error)\n    throw Object.assign(new Error(error), { code: ERRORS.ERR_UNRECOGNIZED_VALIDITY })\n  }\n}\n\n// Utility for creating the record data for being signed\nconst ipnsEntryDataForSig = (value, validityType, validity) => {\n  const valueBuffer = Buffer.from(value)\n  const validityTypeBuffer = Buffer.from(getValidityType(validityType))\n  const validityBuffer = Buffer.from(validity)\n\n  return Buffer.concat([valueBuffer, validityBuffer, validityTypeBuffer])\n}\n\n// Utility for extracting the public key from a peer-id\nconst extractPublicKeyFromId = (peerId) => {\n  const decodedId = multihash.decode(peerId.id)\n\n  if (decodedId.code !== ID_MULTIHASH_CODE) {\n    return null\n  }\n\n  return crypto.keys.unmarshalPublicKey(decodedId.digest)\n}\n\nconst marshal = ipnsEntryProto.encode\n\nconst unmarshal = ipnsEntryProto.decode\n\nconst validator = {\n  validate: (marshalledData, key, callback) => {\n    const receivedEntry = unmarshal(marshalledData)\n    const bufferId = key.slice('/ipns/'.length)\n    let peerId\n\n    try {\n      peerId = PeerId.createFromBytes(bufferId)\n    } catch (err) {\n      return callback(err)\n    }\n\n    // extract public key\n    extractPublicKey(peerId, receivedEntry, (err, pubKey) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // Record validation\n      validate(pubKey, receivedEntry, (err) => {\n        if (err) {\n          return callback(err)\n        }\n\n        callback(null, true)\n      })\n    })\n  },\n  select: (dataA, dataB, callback) => {\n    const entryA = unmarshal(dataA)\n    const entryB = unmarshal(dataB)\n\n    const index = entryA.sequence > entryB.sequence ? 0 : 1\n\n    if (typeof callback !== 'function') {\n      return index\n    }\n\n    callback(null, index)\n  }\n}\n\nmodule.exports = {\n  // create ipns entry record\n  create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration,\n  // validate ipns entry record\n  validate,\n  // embed public key in the record\n  embedPublicKey,\n  // extract public key from the record\n  extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey,\n  // get keys for routing\n  getIdKeys,\n  // marshal\n  marshal,\n  // unmarshal\n  unmarshal,\n  // validator\n  validator,\n  // namespace\n  namespace,\n  namespaceLength: namespace.length\n}\n"]},"metadata":{},"sourceType":"script"}