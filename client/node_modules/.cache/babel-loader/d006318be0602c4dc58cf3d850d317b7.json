{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar mafmt = require('mafmt');\n\nvar multiaddr = require('multiaddr');\n\nvar CircuitDialer = require('./circuit/dialer');\n\nvar utilsFactory = require('./circuit/utils');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:circuit:transportdialer');\nlog.err = debug('libp2p:circuit:error:transportdialer');\n\nvar _createListener = require('./listener');\n\nvar Circuit = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of Dialer.\n   *\n   * @param {Swarm} swarm - the swarm\n   * @param {any} options - config options\n   *\n   * @memberOf Dialer\n   */\n  function Circuit(swarm, options) {\n    var _this = this;\n\n    _classCallCheck(this, Circuit);\n\n    this.options = options || {};\n    this.swarm = swarm;\n    this.dialer = null;\n    this.utils = utilsFactory(swarm);\n    this.peerInfo = this.swarm._peerInfo;\n    this.relays = this.filter(this.peerInfo.multiaddrs.toArray()); // if no explicit relays, add a default relay addr\n\n    if (this.relays.length === 0) {\n      this.peerInfo.multiaddrs.add(\"/p2p-circuit/ipfs/\".concat(this.peerInfo.id.toB58String()));\n    }\n\n    this.dialer = new CircuitDialer(swarm, options);\n    this.swarm.on('peer-mux-established', function (peerInfo) {\n      _this.dialer.canHop(peerInfo);\n    });\n    this.swarm.on('peer-mux-closed', function (peerInfo) {\n      _this.dialer.relayPeers.delete(peerInfo.id.toB58String());\n    });\n  }\n  /**\n   * Dial the relays in the Addresses.Swarm config\n   *\n   * @param {Array} relays\n   * @return {void}\n   */\n\n\n  _createClass(Circuit, [{\n    key: \"_dialSwarmRelays\",\n    value: function _dialSwarmRelays() {\n      var _this2 = this;\n\n      // if we have relay addresses in swarm config, then dial those relays\n      this.relays.forEach(function (relay) {\n        var relaySegments = relay.toString().split('/p2p-circuit').filter(function (segment) {\n          return segment.length;\n        });\n        relaySegments.forEach(function (relaySegment) {\n          var ma = _this2.utils.peerInfoFromMa(multiaddr(relaySegment));\n\n          _this2.dialer._dialRelay(ma);\n        });\n      });\n    }\n    /**\n     * Dial a peer over a relay\n     *\n     * @param {multiaddr} ma - the multiaddr of the peer to dial\n     * @param {Object} options - dial options\n     * @param {Function} cb - a callback called once dialed\n     * @returns {Connection} - the connection\n     *\n     * @memberOf Dialer\n     */\n\n  }, {\n    key: \"dial\",\n    value: function dial(ma, options, cb) {\n      return this.dialer.dial(ma, options, cb);\n    }\n    /**\n     * Create a listener\n     *\n     * @param {any} options\n     * @param {Function} handler\n     * @return {listener}\n     */\n\n  }, {\n    key: \"createListener\",\n    value: function createListener(options, handler) {\n      if (typeof options === 'function') {\n        handler = options;\n        options = this.options || {};\n      }\n\n      var listener = _createListener(this.swarm, options, handler);\n\n      listener.on('listen', this._dialSwarmRelays.bind(this));\n      return listener;\n    }\n    /**\n     * Filter check for all multiaddresses\n     * that this transport can dial on\n     *\n     * @param {any} multiaddrs\n     * @returns {Array<multiaddr>}\n     *\n     * @memberOf Dialer\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(multiaddrs) {\n      if (!Array.isArray(multiaddrs)) {\n        multiaddrs = [multiaddrs];\n      }\n\n      return multiaddrs.filter(function (ma) {\n        return mafmt.Circuit.matches(ma);\n      });\n    }\n  }], [{\n    key: \"tag\",\n    get: function get() {\n      return 'Circuit';\n    }\n  }]);\n\n  return Circuit;\n}();\n\nmodule.exports = Circuit;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/libp2p-circuit/src/circuit.js"],"names":["mafmt","require","multiaddr","CircuitDialer","utilsFactory","debug","log","err","createListener","Circuit","swarm","options","dialer","utils","peerInfo","_peerInfo","relays","filter","multiaddrs","toArray","length","add","id","toB58String","on","canHop","relayPeers","delete","forEach","relay","relaySegments","toString","split","segment","relaySegment","ma","peerInfoFromMa","_dialRelay","cb","dial","handler","listener","_dialSwarmRelays","bind","Array","isArray","matches","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mafmt = require('mafmt')\nconst multiaddr = require('multiaddr')\n\nconst CircuitDialer = require('./circuit/dialer')\nconst utilsFactory = require('./circuit/utils')\n\nconst debug = require('debug')\nconst log = debug('libp2p:circuit:transportdialer')\nlog.err = debug('libp2p:circuit:error:transportdialer')\n\nconst createListener = require('./listener')\n\nclass Circuit {\n  static get tag () {\n    return 'Circuit'\n  }\n\n  /**\n   * Creates an instance of Dialer.\n   *\n   * @param {Swarm} swarm - the swarm\n   * @param {any} options - config options\n   *\n   * @memberOf Dialer\n   */\n  constructor (swarm, options) {\n    this.options = options || {}\n\n    this.swarm = swarm\n    this.dialer = null\n    this.utils = utilsFactory(swarm)\n    this.peerInfo = this.swarm._peerInfo\n    this.relays = this.filter(this.peerInfo.multiaddrs.toArray())\n\n    // if no explicit relays, add a default relay addr\n    if (this.relays.length === 0) {\n      this.peerInfo\n        .multiaddrs\n        .add(`/p2p-circuit/ipfs/${this.peerInfo.id.toB58String()}`)\n    }\n\n    this.dialer = new CircuitDialer(swarm, options)\n\n    this.swarm.on('peer-mux-established', (peerInfo) => {\n      this.dialer.canHop(peerInfo)\n    })\n    this.swarm.on('peer-mux-closed', (peerInfo) => {\n      this.dialer.relayPeers.delete(peerInfo.id.toB58String())\n    })\n  }\n\n  /**\n   * Dial the relays in the Addresses.Swarm config\n   *\n   * @param {Array} relays\n   * @return {void}\n   */\n  _dialSwarmRelays () {\n    // if we have relay addresses in swarm config, then dial those relays\n    this.relays.forEach((relay) => {\n      let relaySegments = relay\n        .toString()\n        .split('/p2p-circuit')\n        .filter(segment => segment.length)\n\n      relaySegments.forEach((relaySegment) => {\n        const ma = this.utils.peerInfoFromMa(multiaddr(relaySegment))\n        this.dialer._dialRelay(ma)\n      })\n    })\n  }\n\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Object} options - dial options\n   * @param {Function} cb - a callback called once dialed\n   * @returns {Connection} - the connection\n   *\n   * @memberOf Dialer\n   */\n  dial (ma, options, cb) {\n    return this.dialer.dial(ma, options, cb)\n  }\n\n  /**\n   * Create a listener\n   *\n   * @param {any} options\n   * @param {Function} handler\n   * @return {listener}\n   */\n  createListener (options, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = this.options || {}\n    }\n\n    const listener = createListener(this.swarm, options, handler)\n    listener.on('listen', this._dialSwarmRelays.bind(this))\n    return listener\n  }\n\n  /**\n   * Filter check for all multiaddresses\n   * that this transport can dial on\n   *\n   * @param {any} multiaddrs\n   * @returns {Array<multiaddr>}\n   *\n   * @memberOf Dialer\n   */\n  filter (multiaddrs) {\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs]\n    }\n    return multiaddrs.filter((ma) => {\n      return mafmt.Circuit.matches(ma)\n    })\n  }\n}\n\nmodule.exports = Circuit\n"]},"metadata":{},"sourceType":"script"}