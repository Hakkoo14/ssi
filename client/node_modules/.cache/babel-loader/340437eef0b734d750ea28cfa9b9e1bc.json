{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\n\nvar shortid = require('shortid');\n\nvar _require = require('./constants'),\n    WORKER_REQUEST_READ_LOCK = _require.WORKER_REQUEST_READ_LOCK,\n    WORKER_RELEASE_READ_LOCK = _require.WORKER_RELEASE_READ_LOCK,\n    MASTER_GRANT_READ_LOCK = _require.MASTER_GRANT_READ_LOCK,\n    WORKER_REQUEST_WRITE_LOCK = _require.WORKER_REQUEST_WRITE_LOCK,\n    WORKER_RELEASE_WRITE_LOCK = _require.WORKER_RELEASE_WRITE_LOCK,\n    MASTER_GRANT_WRITE_LOCK = _require.MASTER_GRANT_WRITE_LOCK;\n\nvar cluster;\n\nvar handleWorkerLockRequest = function handleWorkerLockRequest(emitter, masterEvent, requestType, releaseType, grantType) {\n  return function (worker, requestEvent) {\n    if (requestEvent && requestEvent.type === requestType) {\n      emitter.emit(masterEvent, requestEvent.name, function () {\n        // grant lock to worker\n        worker.send({\n          type: grantType,\n          name: requestEvent.name,\n          identifier: requestEvent.identifier\n        }); // wait for worker to finish\n\n        return new Promise(function (resolve) {\n          var releaseEventListener = function releaseEventListener(releaseEvent) {\n            if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n              worker.removeListener('message', releaseEventListener);\n              resolve();\n            }\n          };\n\n          worker.on('message', releaseEventListener);\n        });\n      });\n    }\n  };\n};\n\nvar makeWorkerLockRequest = function makeWorkerLockRequest(name, requestType, grantType, releaseType) {\n  return function (fn) {\n    var id = shortid.generate();\n    process.send({\n      type: requestType,\n      identifier: id,\n      name: name\n    });\n    return new Promise(function (resolve, reject) {\n      var listener = function listener(event) {\n        if (event && event.type === grantType && event.identifier === id) {\n          process.removeListener('message', listener);\n          var error = null;\n          fn().catch(function (err) {\n            error = err;\n          }).then(function (result) {\n            process.send({\n              type: releaseType,\n              identifier: id,\n              name: name\n            });\n\n            if (error) {\n              return reject(error);\n            }\n\n            resolve(result);\n          });\n        }\n      };\n\n      process.on('message', listener);\n    });\n  };\n};\n\nmodule.exports = function (options) {\n  try {\n    cluster = require('cluster');\n\n    if (!Object.keys(cluster).length) {\n      return;\n    }\n  } catch (_) {\n    return;\n  }\n\n  if (cluster.isMaster || options.singleProcess) {\n    var emitter = new EventEmitter();\n    cluster.on('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));\n    cluster.on('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));\n    return emitter;\n  }\n\n  return {\n    isWorker: true,\n    readLock: function readLock(name, options) {\n      return makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK);\n    },\n    writeLock: function writeLock(name, options) {\n      return makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK);\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/mortice/lib/node.js"],"names":["EventEmitter","require","shortid","WORKER_REQUEST_READ_LOCK","WORKER_RELEASE_READ_LOCK","MASTER_GRANT_READ_LOCK","WORKER_REQUEST_WRITE_LOCK","WORKER_RELEASE_WRITE_LOCK","MASTER_GRANT_WRITE_LOCK","cluster","handleWorkerLockRequest","emitter","masterEvent","requestType","releaseType","grantType","worker","requestEvent","type","emit","name","send","identifier","Promise","resolve","releaseEventListener","releaseEvent","removeListener","on","makeWorkerLockRequest","fn","id","generate","process","reject","listener","event","error","catch","err","then","result","module","exports","options","Object","keys","length","_","isMaster","singleProcess","isWorker","readLock","writeLock"],"mappings":"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","sourcesContent":["const EventEmitter = require('events').EventEmitter\nconst shortid = require('shortid')\nconst {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK\n} = require('./constants')\nlet cluster\n\nconst handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {\n  return (worker, requestEvent) => {\n    if (requestEvent && requestEvent.type === requestType) {\n      emitter.emit(masterEvent, requestEvent.name, () => {\n        // grant lock to worker\n        worker.send({\n          type: grantType,\n          name: requestEvent.name,\n          identifier: requestEvent.identifier\n        })\n\n        // wait for worker to finish\n        return new Promise((resolve) => {\n          const releaseEventListener = (releaseEvent) => {\n            if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n              worker.removeListener('message', releaseEventListener)\n              resolve()\n            }\n          }\n\n          worker.on('message', releaseEventListener)\n        })\n      })\n    }\n  }\n}\n\nconst makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {\n  return (fn) => {\n    const id = shortid.generate()\n\n    process.send({\n      type: requestType,\n      identifier: id,\n      name\n    })\n\n    return new Promise((resolve, reject) => {\n      const listener = (event) => {\n        if (event && event.type === grantType && event.identifier === id) {\n          process.removeListener('message', listener)\n\n          let error = null\n\n          fn()\n            .catch((err) => {\n              error = err\n            })\n            .then((result) => {\n              process.send({\n                type: releaseType,\n                identifier: id,\n                name\n              })\n\n              if (error) {\n                return reject(error)\n              }\n\n              resolve(result)\n            })\n        }\n      }\n\n      process.on('message', listener)\n    })\n  }\n}\n\nmodule.exports = (options) => {\n  try {\n    cluster = require('cluster')\n\n    if (!Object.keys(cluster).length) {\n      return\n    }\n  } catch (_) {\n    return\n  }\n\n  if (cluster.isMaster || options.singleProcess) {\n    const emitter = new EventEmitter()\n\n    cluster.on('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))\n    cluster.on('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))\n\n    return emitter\n  }\n\n  return {\n    isWorker: true,\n    readLock: (name, options) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: (name, options) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}