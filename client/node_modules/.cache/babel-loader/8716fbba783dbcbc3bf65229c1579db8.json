{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar pull = require('pull-stream');\n\nvar pullDefer = require('pull-defer');\n\nvar pullTraverse = require('pull-traverse');\n\nvar pullCat = require('pull-cat');\n\nvar isIpfs = require('is-ipfs');\n\nvar CID = require('cids');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode;\n\nvar _require2 = require('./utils'),\n    normalizePath = _require2.normalizePath;\n\nvar _require3 = require('./refs'),\n    Format = _require3.Format;\n\nmodule.exports = function (self) {\n  return function (ipfsPath) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.maxDepth === 0) {\n      return pull.empty();\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      return pull.error(new Error('Cannot set edges to true and also specify format'));\n    }\n\n    options.format = options.edges ? Format.edges : options.format || Format.default;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n\n    var paths;\n\n    try {\n      var rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n      paths = rawPaths.map(function (p) {\n        return getFullPath(self, p, options);\n      });\n    } catch (err) {\n      return pull.error(err);\n    }\n\n    return pullCat(paths.map(function (p) {\n      return refsStream(self, p, options);\n    }));\n  };\n};\n\nfunction getFullPath(ipfs, ipfsPath, options) {\n  // normalizePath() strips /ipfs/ off the front of the path so the CID will\n  // be at the front of the path\n  var path = normalizePath(ipfsPath);\n  var pathComponents = path.split('/');\n  var cid = pathComponents[0];\n\n  if (!isIpfs.cid(cid)) {\n    throw new Error(\"Error resolving path '\".concat(path, \"': '\").concat(cid, \"' is not a valid CID\"));\n  }\n\n  if (options.preload !== false) {\n    ipfs._preload(cid);\n  }\n\n  return '/ipfs/' + path;\n} // Get a stream of refs at the given path\n\n\nfunction refsStream(ipfs, path, options) {\n  var deferred = pullDefer.source(); // Resolve to the target CID of the path\n\n  ipfs.resolve(path, function (err, resPath) {\n    if (err) {\n      return deferred.resolve(pull.error(err));\n    } // path is /ipfs/<cid>\n\n\n    var parts = resPath.split('/');\n    var cid = parts[2];\n    deferred.resolve(pull( // Traverse the DAG, converting it into a stream\n    objectStream(ipfs, cid, options.maxDepth, options.unique), // Root object will not have a parent\n    pull.filter(function (obj) {\n      return Boolean(obj.parent);\n    }), // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    pull.filter(function (obj) {\n      return !obj.isDuplicate;\n    }), // Format the links\n    pull.map(function (obj) {\n      return formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format);\n    }), // Clients expect refs to be in the format { ref: <ref> }\n    pull.map(function (ref) {\n      return {\n        ref: ref\n      };\n    })));\n  });\n  return deferred;\n} // Get formatted link\n\n\nfunction formatLink(srcCid, dstCid, linkName, format) {\n  var out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n} // Do a depth first search of the DAG, starting from the given root cid\n\n\nfunction objectStream(ipfs, rootCid, maxDepth, isUnique) {\n  var uniques = new Set();\n  var root = {\n    node: {\n      cid: rootCid\n    },\n    depth: 0\n  };\n\n  var traverseLevel = function traverseLevel(obj) {\n    var node = obj.node,\n        depth = obj.depth; // Check the depth\n\n    var nextLevelDepth = depth + 1;\n\n    if (nextLevelDepth > maxDepth) {\n      return pull.empty();\n    } // If unique option is enabled, check if the CID has been seen before.\n    // Note we need to do this here rather than before adding to the stream\n    // so that the unique check happens in the order that items are examined\n    // in the DAG.\n\n\n    if (isUnique) {\n      if (uniques.has(node.cid.toString())) {\n        // Mark this object as a duplicate so we can filter it out later\n        obj.isDuplicate = true;\n        return pull.empty();\n      }\n\n      uniques.add(node.cid.toString());\n    }\n\n    var deferred = pullDefer.source(); // Get this object's links\n\n    getLinks(ipfs, node.cid, function (err, links) {\n      if (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          err.message = \"Could not find object with CID: \".concat(node.cid);\n        }\n\n        return deferred.resolve(pull.error(err));\n      } // Add to the stream each link, parent and the new depth\n\n\n      var vals = links.map(function (link) {\n        return {\n          parent: node,\n          node: link,\n          depth: nextLevelDepth\n        };\n      });\n      deferred.resolve(pull.values(vals));\n    });\n    return deferred;\n  };\n\n  return pullTraverse.depthFirst(root, traverseLevel);\n} // Fetch a node from IPLD then get all its links\n\n\nfunction getLinks(ipfs, cid, callback) {\n  ipfs._ipld.get(new CID(cid)).then(function (node) {\n    var links;\n\n    if (DAGNode.isDAGNode(node)) {\n      links = node.Links.map(function (_ref) {\n        var Name = _ref.Name,\n            Hash = _ref.Hash;\n        return {\n          name: Name,\n          cid: new CID(Hash)\n        };\n      });\n    } else {\n      links = getNodeLinks(node);\n    }\n\n    callback(null, links);\n  }).catch(callback);\n} // Recursively search the node for CIDs\n\n\nfunction getNodeLinks(node) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var links = [];\n\n  for (var _i = 0, _Object$entries = Object.entries(node); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        name = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    if (CID.isCID(value)) {\n      links.push({\n        name: path + name,\n        cid: value\n      });\n    } else if (typeof value === 'object') {\n      links = links.concat(getNodeLinks(value, path + name + '/'));\n    }\n  }\n\n  return links;\n}","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs/src/core/components/files-regular/refs-pull-stream.js"],"names":["pull","require","pullDefer","pullTraverse","pullCat","isIpfs","CID","DAGNode","normalizePath","Format","module","exports","self","ipfsPath","options","maxDepth","empty","edges","format","default","error","Error","recursive","Infinity","paths","rawPaths","Array","isArray","map","p","getFullPath","err","refsStream","ipfs","path","pathComponents","split","cid","preload","_preload","deferred","source","resolve","resPath","parts","objectStream","unique","filter","obj","Boolean","parent","isDuplicate","formatLink","node","name","ref","srcCid","dstCid","linkName","out","replace","toString","rootCid","isUnique","uniques","Set","root","depth","traverseLevel","nextLevelDepth","has","add","getLinks","links","code","message","vals","link","values","depthFirst","callback","_ipld","get","then","isDAGNode","Links","Name","Hash","getNodeLinks","catch","Object","entries","value","isCID","push","concat"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream')\nconst pullDefer = require('pull-defer')\nconst pullTraverse = require('pull-traverse')\nconst pullCat = require('pull-cat')\nconst isIpfs = require('is-ipfs')\nconst CID = require('cids')\nconst { DAGNode } = require('ipld-dag-pb')\nconst { normalizePath } = require('./utils')\nconst { Format } = require('./refs')\n\nmodule.exports = function (self) {\n  return function (ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return pull.empty()\n    }\n    if (options.edges && options.format && options.format !== Format.default) {\n      return pull.error(new Error('Cannot set edges to true and also specify format'))\n    }\n\n    options.format = options.edges ? Format.edges : options.format || Format.default\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    let paths\n    try {\n      const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n      paths = rawPaths.map(p => getFullPath(self, p, options))\n    } catch (err) {\n      return pull.error(err)\n    }\n\n    return pullCat(paths.map(p => refsStream(self, p, options)))\n  }\n}\n\nfunction getFullPath (ipfs, ipfsPath, options) {\n  // normalizePath() strips /ipfs/ off the front of the path so the CID will\n  // be at the front of the path\n  const path = normalizePath(ipfsPath)\n  const pathComponents = path.split('/')\n  const cid = pathComponents[0]\n  if (!isIpfs.cid(cid)) {\n    throw new Error(`Error resolving path '${path}': '${cid}' is not a valid CID`)\n  }\n\n  if (options.preload !== false) {\n    ipfs._preload(cid)\n  }\n\n  return '/ipfs/' + path\n}\n\n// Get a stream of refs at the given path\nfunction refsStream (ipfs, path, options) {\n  const deferred = pullDefer.source()\n\n  // Resolve to the target CID of the path\n  ipfs.resolve(path, (err, resPath) => {\n    if (err) {\n      return deferred.resolve(pull.error(err))\n    }\n\n    // path is /ipfs/<cid>\n    const parts = resPath.split('/')\n    const cid = parts[2]\n    deferred.resolve(pull(\n      // Traverse the DAG, converting it into a stream\n      objectStream(ipfs, cid, options.maxDepth, options.unique),\n      // Root object will not have a parent\n      pull.filter(obj => Boolean(obj.parent)),\n      // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n      pull.filter(obj => !obj.isDuplicate),\n      // Format the links\n      pull.map(obj => formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)),\n      // Clients expect refs to be in the format { ref: <ref> }\n      pull.map(ref => ({ ref }))\n    ))\n  })\n\n  return deferred\n}\n\n// Get formatted link\nfunction formatLink (srcCid, dstCid, linkName, format) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n// Do a depth first search of the DAG, starting from the given root cid\nfunction objectStream (ipfs, rootCid, maxDepth, isUnique) {\n  const uniques = new Set()\n\n  const root = { node: { cid: rootCid }, depth: 0 }\n  const traverseLevel = (obj) => {\n    const { node, depth } = obj\n\n    // Check the depth\n    const nextLevelDepth = depth + 1\n    if (nextLevelDepth > maxDepth) {\n      return pull.empty()\n    }\n\n    // If unique option is enabled, check if the CID has been seen before.\n    // Note we need to do this here rather than before adding to the stream\n    // so that the unique check happens in the order that items are examined\n    // in the DAG.\n    if (isUnique) {\n      if (uniques.has(node.cid.toString())) {\n        // Mark this object as a duplicate so we can filter it out later\n        obj.isDuplicate = true\n        return pull.empty()\n      }\n      uniques.add(node.cid.toString())\n    }\n\n    const deferred = pullDefer.source()\n\n    // Get this object's links\n    getLinks(ipfs, node.cid, (err, links) => {\n      if (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          err.message = `Could not find object with CID: ${node.cid}`\n        }\n        return deferred.resolve(pull.error(err))\n      }\n\n      // Add to the stream each link, parent and the new depth\n      const vals = links.map(link => ({\n        parent: node,\n        node: link,\n        depth: nextLevelDepth\n      }))\n\n      deferred.resolve(pull.values(vals))\n    })\n\n    return deferred\n  }\n\n  return pullTraverse.depthFirst(root, traverseLevel)\n}\n\n// Fetch a node from IPLD then get all its links\nfunction getLinks (ipfs, cid, callback) {\n  ipfs._ipld.get(new CID(cid))\n    .then(node => {\n      let links\n      if (DAGNode.isDAGNode(node)) {\n        links = node.Links.map(({ Name, Hash }) => {\n          return { name: Name, cid: new CID(Hash) }\n        })\n      } else {\n        links = getNodeLinks(node)\n      }\n      callback(null, links)\n    })\n    .catch(callback)\n}\n\n// Recursively search the node for CIDs\nfunction getNodeLinks (node, path = '') {\n  let links = []\n  for (const [name, value] of Object.entries(node)) {\n    if (CID.isCID(value)) {\n      links.push({\n        name: path + name,\n        cid: value\n      })\n    } else if (typeof value === 'object') {\n      links = links.concat(getNodeLinks(value, path + name + '/'))\n    }\n  }\n  return links\n}\n"]},"metadata":{},"sourceType":"script"}