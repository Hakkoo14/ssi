{"ast":null,"code":"'use strict';\n\nvar debug = require('debug');\n\nvar promisify = require('promisify-es6');\n\nvar waterfall = require('async/waterfall');\n\nvar parallel = require('async/parallel');\n\nvar human = require('human-to-milliseconds');\n\nvar crypto = require('libp2p-crypto');\n\nvar errcode = require('err-code');\n\nvar log = debug('ipfs:name');\nlog.error = debug('ipfs:name:error');\n\nvar namePubsub = require('./name-pubsub');\n\nvar utils = require('../utils');\n\nvar path = require('../ipns/path');\n\nvar keyLookup = function keyLookup(ipfsNode, kname, callback) {\n  if (kname === 'self') {\n    return callback(null, ipfsNode._peerInfo.id.privKey);\n  }\n\n  var pass = ipfsNode._options.pass;\n  waterfall([function (cb) {\n    return ipfsNode._keychain.exportKey(kname, pass, cb);\n  }, function (pem, cb) {\n    return crypto.keys.import(pem, pass, cb);\n  }], function (err, privateKey) {\n    if (err) {\n      log.error(err);\n      return callback(errcode(err, 'ERR_CANNOT_GET_KEY'));\n    }\n\n    return callback(null, privateKey);\n  });\n};\n\nmodule.exports = function name(self) {\n  return {\n    /**\n     * IPNS is a PKI namespace, where names are the hashes of public keys, and\n     * the private key enables publishing new (signed) values. In both publish\n     * and resolve, the default name used is the node's own PeerID,\n     * which is the hash of its public key.\n     *\n     * @param {String} value ipfs path of the object to be published.\n     * @param {Object} options ipfs publish options.\n     * @param {boolean} options.resolve resolve given path before publishing.\n     * @param {String} options.lifetime time duration that the record will be valid for.\n    This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n    \"ns\", \"ms\", \"s\", \"m\", \"h\". Default is 24h.\n     * @param {String} options.ttl time duration this record should be cached for (NOT IMPLEMENTED YET).\n     * This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n     \"ns\", \"ms\", \"s\", \"m\", \"h\" (caution: experimental).\n     * @param {String} options.key name of the key to be used, as listed by 'ipfs key list -l'.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    publish: promisify(function (value, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var resolve = !(options.resolve === false);\n      var lifetime = options.lifetime || '24h';\n      var key = options.key || 'self';\n\n      if (!self.isOnline()) {\n        var errMsg = utils.OFFLINE_ERROR;\n        log.error(errMsg);\n        return callback(errcode(errMsg, 'OFFLINE_ERROR'));\n      } // TODO: params related logic should be in the core implementation\n      // Normalize path value\n\n\n      try {\n        value = utils.normalizePath(value);\n      } catch (err) {\n        log.error(err);\n        return callback(err);\n      }\n\n      parallel([function (cb) {\n        return human(lifetime, cb);\n      }, // (cb) => ttl ? human(ttl, cb) : cb(),\n      function (cb) {\n        return keyLookup(self, key, cb);\n      }, // verify if the path exists, if not, an error will stop the execution\n      function (cb) {\n        return resolve.toString() === 'true' ? path.resolvePath(self, value, cb) : cb();\n      }], function (err, results) {\n        if (err) {\n          log.error(err);\n          return callback(err);\n        } // Calculate lifetime with nanoseconds precision\n\n\n        var pubLifetime = results[0].toFixed(6);\n        var privateKey = results[1]; // TODO IMPROVEMENT - Handle ttl for cache\n        // const ttl = results[1]\n        // const privateKey = results[2]\n        // Start publishing process\n\n        self._ipns.publish(privateKey, value, pubLifetime, callback);\n      });\n    }),\n\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n     * @param {Object} options ipfs resolve options.\n     * @param {boolean} options.nocache do not use cached entries.\n     * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    resolve: promisify(function (name, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var nocache = options.nocache && options.nocache.toString() === 'true';\n      var recursive = options.recursive && options.recursive.toString() === 'true';\n      var offline = self._options.offline;\n\n      if (!self.isOnline() && !offline) {\n        var errMsg = utils.OFFLINE_ERROR;\n        log.error(errMsg);\n        return callback(errcode(errMsg, 'OFFLINE_ERROR'));\n      } // TODO: params related logic should be in the core implementation\n\n\n      if (offline && nocache) {\n        var error = 'cannot specify both offline and nocache';\n        log.error(error);\n        return callback(errcode(new Error(error), 'ERR_NOCACHE_AND_OFFLINE'));\n      } // Set node id as name for being resolved, if it is not received\n\n\n      if (!name) {\n        name = self._peerInfo.id.toB58String();\n      }\n\n      if (!name.startsWith('/ipns/')) {\n        name = \"/ipns/\".concat(name);\n      }\n\n      var resolveOptions = {\n        nocache: nocache,\n        recursive: recursive\n      };\n\n      self._ipns.resolve(name, resolveOptions, callback);\n    }),\n    pubsub: namePubsub(self)\n  };\n};","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs/src/core/components/name.js"],"names":["debug","require","promisify","waterfall","parallel","human","crypto","errcode","log","error","namePubsub","utils","path","keyLookup","ipfsNode","kname","callback","_peerInfo","id","privKey","pass","_options","cb","_keychain","exportKey","pem","keys","import","err","privateKey","module","exports","name","self","publish","value","options","resolve","lifetime","key","isOnline","errMsg","OFFLINE_ERROR","normalizePath","toString","resolvePath","results","pubLifetime","toFixed","_ipns","nocache","recursive","offline","Error","toB58String","startsWith","resolveOptions","pubsub"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst promisify = require('promisify-es6')\nconst waterfall = require('async/waterfall')\nconst parallel = require('async/parallel')\nconst human = require('human-to-milliseconds')\nconst crypto = require('libp2p-crypto')\nconst errcode = require('err-code')\n\nconst log = debug('ipfs:name')\nlog.error = debug('ipfs:name:error')\n\nconst namePubsub = require('./name-pubsub')\nconst utils = require('../utils')\nconst path = require('../ipns/path')\n\nconst keyLookup = (ipfsNode, kname, callback) => {\n  if (kname === 'self') {\n    return callback(null, ipfsNode._peerInfo.id.privKey)\n  }\n\n  const pass = ipfsNode._options.pass\n\n  waterfall([\n    (cb) => ipfsNode._keychain.exportKey(kname, pass, cb),\n    (pem, cb) => crypto.keys.import(pem, pass, cb)\n  ], (err, privateKey) => {\n    if (err) {\n      log.error(err)\n      return callback(errcode(err, 'ERR_CANNOT_GET_KEY'))\n    }\n\n    return callback(null, privateKey)\n  })\n}\n\nmodule.exports = function name (self) {\n  return {\n    /**\n     * IPNS is a PKI namespace, where names are the hashes of public keys, and\n     * the private key enables publishing new (signed) values. In both publish\n     * and resolve, the default name used is the node's own PeerID,\n     * which is the hash of its public key.\n     *\n     * @param {String} value ipfs path of the object to be published.\n     * @param {Object} options ipfs publish options.\n     * @param {boolean} options.resolve resolve given path before publishing.\n     * @param {String} options.lifetime time duration that the record will be valid for.\n    This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n    \"ns\", \"ms\", \"s\", \"m\", \"h\". Default is 24h.\n     * @param {String} options.ttl time duration this record should be cached for (NOT IMPLEMENTED YET).\n     * This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n     \"ns\", \"ms\", \"s\", \"m\", \"h\" (caution: experimental).\n     * @param {String} options.key name of the key to be used, as listed by 'ipfs key list -l'.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    publish: promisify((value, options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      options = options || {}\n      const resolve = !(options.resolve === false)\n      const lifetime = options.lifetime || '24h'\n      const key = options.key || 'self'\n\n      if (!self.isOnline()) {\n        const errMsg = utils.OFFLINE_ERROR\n\n        log.error(errMsg)\n        return callback(errcode(errMsg, 'OFFLINE_ERROR'))\n      }\n\n      // TODO: params related logic should be in the core implementation\n\n      // Normalize path value\n      try {\n        value = utils.normalizePath(value)\n      } catch (err) {\n        log.error(err)\n        return callback(err)\n      }\n\n      parallel([\n        (cb) => human(lifetime, cb),\n        // (cb) => ttl ? human(ttl, cb) : cb(),\n        (cb) => keyLookup(self, key, cb),\n        // verify if the path exists, if not, an error will stop the execution\n        (cb) => resolve.toString() === 'true' ? path.resolvePath(self, value, cb) : cb()\n      ], (err, results) => {\n        if (err) {\n          log.error(err)\n          return callback(err)\n        }\n\n        // Calculate lifetime with nanoseconds precision\n        const pubLifetime = results[0].toFixed(6)\n        const privateKey = results[1]\n\n        // TODO IMPROVEMENT - Handle ttl for cache\n        // const ttl = results[1]\n        // const privateKey = results[2]\n\n        // Start publishing process\n        self._ipns.publish(privateKey, value, pubLifetime, callback)\n      })\n    }),\n\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n     * @param {Object} options ipfs resolve options.\n     * @param {boolean} options.nocache do not use cached entries.\n     * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    resolve: promisify((name, options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      options = options || {}\n      const nocache = options.nocache && options.nocache.toString() === 'true'\n      const recursive = options.recursive && options.recursive.toString() === 'true'\n\n      const offline = self._options.offline\n\n      if (!self.isOnline() && !offline) {\n        const errMsg = utils.OFFLINE_ERROR\n\n        log.error(errMsg)\n        return callback(errcode(errMsg, 'OFFLINE_ERROR'))\n      }\n\n      // TODO: params related logic should be in the core implementation\n\n      if (offline && nocache) {\n        const error = 'cannot specify both offline and nocache'\n\n        log.error(error)\n        return callback(errcode(new Error(error), 'ERR_NOCACHE_AND_OFFLINE'))\n      }\n\n      // Set node id as name for being resolved, if it is not received\n      if (!name) {\n        name = self._peerInfo.id.toB58String()\n      }\n\n      if (!name.startsWith('/ipns/')) {\n        name = `/ipns/${name}`\n      }\n\n      const resolveOptions = {\n        nocache,\n        recursive\n      }\n\n      self._ipns.resolve(name, resolveOptions, callback)\n    }),\n    pubsub: namePubsub(self)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}