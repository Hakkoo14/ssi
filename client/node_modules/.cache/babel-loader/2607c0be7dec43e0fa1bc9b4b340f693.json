{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events');\n\nvar LatencyMonitor = require('latency-monitor').default;\n\nvar debug = require('debug')('libp2p:connection-manager');\n\nvar defaultOptions = {\n  maxPeers: Infinity,\n  minPeers: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\n\nvar ConnectionManager = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(ConnectionManager, _EventEmitter);\n\n  var _super = _createSuper(ConnectionManager);\n\n  function ConnectionManager(libp2p, options) {\n    var _this;\n\n    _classCallCheck(this, ConnectionManager);\n\n    _this = _super.call(this);\n    _this._libp2p = libp2p;\n    _this._options = Object.assign({}, defaultOptions, options);\n    _this._options.maxPeersPerProtocol = fixMaxPeersPerProtocol(_this._options.maxPeersPerProtocol);\n    debug('options: %j', _this._options);\n    _this._stats = libp2p.stats;\n\n    if (options && !_this._stats) {\n      throw new Error('No libp2p.stats');\n    }\n\n    _this._peerValues = new Map();\n    _this._peers = new Map();\n    _this._peerProtocols = new Map();\n    _this._peerCountPerProtocol = new Map();\n    _this._onStatsUpdate = _this._onStatsUpdate.bind(_assertThisInitialized(_this));\n    _this._onPeerConnect = _this._onPeerConnect.bind(_assertThisInitialized(_this));\n    _this._onPeerDisconnect = _this._onPeerDisconnect.bind(_assertThisInitialized(_this));\n\n    if (_this._libp2p.isStarted()) {\n      _this._onceStarted();\n    } else {\n      _this._libp2p.once('start', _this._onceStarted.bind(_assertThisInitialized(_this)));\n    }\n\n    return _this;\n  }\n\n  _createClass(ConnectionManager, [{\n    key: \"start\",\n    value: function start() {\n      this._stats.on('update', this._onStatsUpdate);\n\n      this._libp2p.on('connection:start', this._onPeerConnect);\n\n      this._libp2p.on('connection:end', this._onPeerDisconnect); // latency monitor\n\n\n      this._latencyMonitor = new LatencyMonitor({\n        dataEmitIntervalMs: this._options.pollInterval\n      });\n      this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n      this._latencyMonitor.on('data', this._onLatencyMeasure);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._stats.removeListener('update', this._onStatsUpdate);\n\n      this._libp2p.removeListener('connection:start', this._onPeerConnect);\n\n      this._libp2p.removeListener('connection:end', this._onPeerDisconnect);\n\n      this._latencyMonitor.removeListener('data', this._onLatencyMeasure);\n    }\n  }, {\n    key: \"setPeerValue\",\n    value: function setPeerValue(peerId, value) {\n      if (value < 0 || value > 1) {\n        throw new Error('value should be a number between 0 and 1');\n      }\n\n      if (peerId.toB58String) {\n        peerId = peerId.toB58String();\n      }\n\n      this._peerValues.set(peerId, value);\n    }\n  }, {\n    key: \"_onceStarted\",\n    value: function _onceStarted() {\n      this._peerId = this._libp2p.peerInfo.id.toB58String();\n    }\n  }, {\n    key: \"_onStatsUpdate\",\n    value: function _onStatsUpdate() {\n      var movingAvgs = this._stats.global.movingAverages;\n\n      var received = movingAvgs.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n      this._checkLimit('maxReceivedData', received);\n\n      var sent = movingAvgs.dataSent[this._options.movingAverageInterval].movingAverage();\n\n      this._checkLimit('maxSentData', sent);\n\n      var total = received + sent;\n\n      this._checkLimit('maxData', total);\n\n      debug('stats update', total);\n    }\n  }, {\n    key: \"_onPeerConnect\",\n    value: function _onPeerConnect(peerInfo) {\n      var _this2 = this;\n\n      var peerId = peerInfo.id.toB58String();\n      debug('%s: connected to %s', this._peerId, peerId);\n\n      this._peerValues.set(peerId, this._options.defaultPeerValue);\n\n      this._peers.set(peerId, peerInfo);\n\n      this.emit('connected', peerId);\n\n      this._checkLimit('maxPeers', this._peers.size);\n\n      protocolsFromPeerInfo(peerInfo).forEach(function (protocolTag) {\n        var protocol = _this2._peerCountPerProtocol[protocolTag];\n\n        if (!protocol) {\n          _this2._peerCountPerProtocol[protocolTag] = 0;\n        }\n\n        _this2._peerCountPerProtocol[protocolTag]++;\n        var peerProtocols = _this2._peerProtocols[peerId];\n\n        if (!peerProtocols) {\n          peerProtocols = _this2._peerProtocols[peerId] = new Set();\n        }\n\n        peerProtocols.add(protocolTag);\n\n        _this2._checkProtocolMaxPeersLimit(protocolTag, _this2._peerCountPerProtocol[protocolTag]);\n      });\n    }\n  }, {\n    key: \"_onPeerDisconnect\",\n    value: function _onPeerDisconnect(peerInfo) {\n      var _this3 = this;\n\n      var peerId = peerInfo.id.toB58String();\n      debug('%s: disconnected from %s', this._peerId, peerId);\n\n      this._peerValues.delete(peerId);\n\n      this._peers.delete(peerId);\n\n      var peerProtocols = this._peerProtocols[peerId];\n\n      if (peerProtocols) {\n        Array.from(peerProtocols).forEach(function (protocolTag) {\n          var peerCountForProtocol = _this3._peerCountPerProtocol[protocolTag];\n\n          if (peerCountForProtocol) {\n            _this3._peerCountPerProtocol[protocolTag]--;\n          }\n        });\n      }\n\n      this.emit('disconnected', peerId);\n    }\n  }, {\n    key: \"_onLatencyMeasure\",\n    value: function _onLatencyMeasure(summary) {\n      this._checkLimit('maxEventLoopDelay', summary.avgMs);\n    }\n  }, {\n    key: \"_checkLimit\",\n    value: function _checkLimit(name, value) {\n      var limit = this._options[name];\n      debug('checking limit of %s. current value: %d of %d', name, value, limit);\n\n      if (value > limit) {\n        debug('%s: limit exceeded: %s, %d', this._peerId, name, value);\n        this.emit('limit:exceeded', name, value);\n\n        this._maybeDisconnectOne();\n      }\n    }\n  }, {\n    key: \"_checkProtocolMaxPeersLimit\",\n    value: function _checkProtocolMaxPeersLimit(protocolTag, value) {\n      debug('checking protocol limit. current value of %s is %d', protocolTag, value);\n      var limit = this._options.maxPeersPerProtocol[protocolTag];\n\n      if (value > limit) {\n        debug('%s: protocol max peers limit exceeded: %s, %d', this._peerId, protocolTag, value);\n        this.emit('limit:exceeded', protocolTag, value);\n\n        this._maybeDisconnectOne();\n      }\n    }\n  }, {\n    key: \"_maybeDisconnectOne\",\n    value: function _maybeDisconnectOne() {\n      if (this._options.minPeers < this._peerValues.size) {\n        var peerValues = Array.from(this._peerValues).sort(byPeerValue);\n        debug('%s: sorted peer values: %j', this._peerId, peerValues);\n        var disconnectPeer = peerValues[0];\n\n        if (disconnectPeer) {\n          var peerId = disconnectPeer[0];\n          debug('%s: lowest value peer is %s', this._peerId, peerId);\n          debug('%s: forcing disconnection from %j', this._peerId, peerId);\n\n          this._disconnectPeer(peerId);\n        }\n      }\n    }\n  }, {\n    key: \"_disconnectPeer\",\n    value: function _disconnectPeer(peerId) {\n      var _this4 = this;\n\n      debug('preemptively disconnecting peer', peerId);\n      this.emit('%s: disconnect:preemptive', this._peerId, peerId);\n\n      var peer = this._peers.get(peerId);\n\n      this._libp2p.hangUp(peer, function (err) {\n        if (err) {\n          _this4.emit('error', err);\n        }\n      });\n    }\n  }]);\n\n  return ConnectionManager;\n}(EventEmitter);\n\nmodule.exports = ConnectionManager;\n\nfunction byPeerValue(peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1];\n}\n\nfunction fixMaxPeersPerProtocol(maxPeersPerProtocol) {\n  if (!maxPeersPerProtocol) {\n    maxPeersPerProtocol = {};\n  }\n\n  Object.keys(maxPeersPerProtocol).forEach(function (transportTag) {\n    var max = maxPeersPerProtocol[transportTag];\n    delete maxPeersPerProtocol[transportTag];\n    maxPeersPerProtocol[transportTag.toLowerCase()] = max;\n  });\n  return maxPeersPerProtocol;\n}\n\nfunction protocolsFromPeerInfo(peerInfo) {\n  var protocolTags = new Set();\n  peerInfo.multiaddrs.forEach(function (multiaddr) {\n    multiaddr.protos().map(protocolToProtocolTag).forEach(function (protocolTag) {\n      protocolTags.add(protocolTag);\n    });\n  });\n  return Array.from(protocolTags);\n}\n\nfunction protocolToProtocolTag(protocol) {\n  return protocol.name.toLowerCase();\n}","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/libp2p-connection-manager/src/index.js"],"names":["EventEmitter","require","LatencyMonitor","default","debug","defaultOptions","maxPeers","Infinity","minPeers","maxData","maxSentData","maxReceivedData","maxEventLoopDelay","pollInterval","movingAverageInterval","defaultPeerValue","ConnectionManager","libp2p","options","_libp2p","_options","Object","assign","maxPeersPerProtocol","fixMaxPeersPerProtocol","_stats","stats","Error","_peerValues","Map","_peers","_peerProtocols","_peerCountPerProtocol","_onStatsUpdate","bind","_onPeerConnect","_onPeerDisconnect","isStarted","_onceStarted","once","on","_latencyMonitor","dataEmitIntervalMs","_onLatencyMeasure","removeListener","peerId","value","toB58String","set","_peerId","peerInfo","id","movingAvgs","global","movingAverages","received","dataReceived","movingAverage","_checkLimit","sent","dataSent","total","emit","size","protocolsFromPeerInfo","forEach","protocolTag","protocol","peerProtocols","Set","add","_checkProtocolMaxPeersLimit","delete","Array","from","peerCountForProtocol","summary","avgMs","name","limit","_maybeDisconnectOne","peerValues","sort","byPeerValue","disconnectPeer","_disconnectPeer","peer","get","hangUp","err","module","exports","peerValueEntryA","peerValueEntryB","keys","transportTag","max","toLowerCase","protocolTags","multiaddrs","multiaddr","protos","map","protocolToProtocolTag"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\nconst LatencyMonitor = require('latency-monitor').default\nconst debug = require('debug')('libp2p:connection-manager')\n\nconst defaultOptions = {\n  maxPeers: Infinity,\n  minPeers: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n}\n\nclass ConnectionManager extends EventEmitter {\n  constructor (libp2p, options) {\n    super()\n    this._libp2p = libp2p\n    this._options = Object.assign({}, defaultOptions, options)\n    this._options.maxPeersPerProtocol = fixMaxPeersPerProtocol(this._options.maxPeersPerProtocol)\n\n    debug('options: %j', this._options)\n\n    this._stats = libp2p.stats\n    if (options && !this._stats) {\n      throw new Error('No libp2p.stats')\n    }\n\n    this._peerValues = new Map()\n    this._peers = new Map()\n    this._peerProtocols = new Map()\n    this._peerCountPerProtocol = new Map()\n    this._onStatsUpdate = this._onStatsUpdate.bind(this)\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n\n    if (this._libp2p.isStarted()) {\n      this._onceStarted()\n    } else {\n      this._libp2p.once('start', this._onceStarted.bind(this))\n    }\n  }\n\n  start () {\n    this._stats.on('update', this._onStatsUpdate)\n    this._libp2p.on('connection:start', this._onPeerConnect)\n    this._libp2p.on('connection:end', this._onPeerDisconnect)\n    // latency monitor\n    this._latencyMonitor = new LatencyMonitor({\n      dataEmitIntervalMs: this._options.pollInterval\n    })\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)\n    this._latencyMonitor.on('data', this._onLatencyMeasure)\n  }\n\n  stop () {\n    this._stats.removeListener('update', this._onStatsUpdate)\n    this._libp2p.removeListener('connection:start', this._onPeerConnect)\n    this._libp2p.removeListener('connection:end', this._onPeerDisconnect)\n    this._latencyMonitor.removeListener('data', this._onLatencyMeasure)\n  }\n\n  setPeerValue (peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1')\n    }\n    if (peerId.toB58String) {\n      peerId = peerId.toB58String()\n    }\n    this._peerValues.set(peerId, value)\n  }\n\n  _onceStarted () {\n    this._peerId = this._libp2p.peerInfo.id.toB58String()\n  }\n\n  _onStatsUpdate () {\n    const movingAvgs = this._stats.global.movingAverages\n    const received = movingAvgs.dataReceived[this._options.movingAverageInterval].movingAverage()\n    this._checkLimit('maxReceivedData', received)\n    const sent = movingAvgs.dataSent[this._options.movingAverageInterval].movingAverage()\n    this._checkLimit('maxSentData', sent)\n    const total = received + sent\n    this._checkLimit('maxData', total)\n    debug('stats update', total)\n  }\n\n  _onPeerConnect (peerInfo) {\n    const peerId = peerInfo.id.toB58String()\n    debug('%s: connected to %s', this._peerId, peerId)\n    this._peerValues.set(peerId, this._options.defaultPeerValue)\n    this._peers.set(peerId, peerInfo)\n    this.emit('connected', peerId)\n    this._checkLimit('maxPeers', this._peers.size)\n\n    protocolsFromPeerInfo(peerInfo).forEach((protocolTag) => {\n      const protocol = this._peerCountPerProtocol[protocolTag]\n      if (!protocol) {\n        this._peerCountPerProtocol[protocolTag] = 0\n      }\n      this._peerCountPerProtocol[protocolTag]++\n\n      let peerProtocols = this._peerProtocols[peerId]\n      if (!peerProtocols) {\n        peerProtocols = this._peerProtocols[peerId] = new Set()\n      }\n      peerProtocols.add(protocolTag)\n      this._checkProtocolMaxPeersLimit(protocolTag, this._peerCountPerProtocol[protocolTag])\n    })\n  }\n\n  _onPeerDisconnect (peerInfo) {\n    const peerId = peerInfo.id.toB58String()\n    debug('%s: disconnected from %s', this._peerId, peerId)\n    this._peerValues.delete(peerId)\n    this._peers.delete(peerId)\n\n    const peerProtocols = this._peerProtocols[peerId]\n    if (peerProtocols) {\n      Array.from(peerProtocols).forEach((protocolTag) => {\n        const peerCountForProtocol = this._peerCountPerProtocol[protocolTag]\n        if (peerCountForProtocol) {\n          this._peerCountPerProtocol[protocolTag]--\n        }\n      })\n    }\n\n    this.emit('disconnected', peerId)\n  }\n\n  _onLatencyMeasure (summary) {\n    this._checkLimit('maxEventLoopDelay', summary.avgMs)\n  }\n\n  _checkLimit (name, value) {\n    const limit = this._options[name]\n    debug('checking limit of %s. current value: %d of %d', name, value, limit)\n    if (value > limit) {\n      debug('%s: limit exceeded: %s, %d', this._peerId, name, value)\n      this.emit('limit:exceeded', name, value)\n      this._maybeDisconnectOne()\n    }\n  }\n\n  _checkProtocolMaxPeersLimit (protocolTag, value) {\n    debug('checking protocol limit. current value of %s is %d', protocolTag, value)\n    const limit = this._options.maxPeersPerProtocol[protocolTag]\n    if (value > limit) {\n      debug('%s: protocol max peers limit exceeded: %s, %d', this._peerId, protocolTag, value)\n      this.emit('limit:exceeded', protocolTag, value)\n      this._maybeDisconnectOne()\n    }\n  }\n\n  _maybeDisconnectOne () {\n    if (this._options.minPeers < this._peerValues.size) {\n      const peerValues = Array.from(this._peerValues).sort(byPeerValue)\n      debug('%s: sorted peer values: %j', this._peerId, peerValues)\n      const disconnectPeer = peerValues[0]\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0]\n        debug('%s: lowest value peer is %s', this._peerId, peerId)\n        debug('%s: forcing disconnection from %j', this._peerId, peerId)\n        this._disconnectPeer(peerId)\n      }\n    }\n  }\n\n  _disconnectPeer (peerId) {\n    debug('preemptively disconnecting peer', peerId)\n    this.emit('%s: disconnect:preemptive', this._peerId, peerId)\n    const peer = this._peers.get(peerId)\n    this._libp2p.hangUp(peer, (err) => {\n      if (err) {\n        this.emit('error', err)\n      }\n    })\n  }\n}\n\nmodule.exports = ConnectionManager\n\nfunction byPeerValue (peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1]\n}\n\nfunction fixMaxPeersPerProtocol (maxPeersPerProtocol) {\n  if (!maxPeersPerProtocol) {\n    maxPeersPerProtocol = {}\n  }\n\n  Object.keys(maxPeersPerProtocol).forEach((transportTag) => {\n    const max = maxPeersPerProtocol[transportTag]\n    delete maxPeersPerProtocol[transportTag]\n    maxPeersPerProtocol[transportTag.toLowerCase()] = max\n  })\n\n  return maxPeersPerProtocol\n}\n\nfunction protocolsFromPeerInfo (peerInfo) {\n  const protocolTags = new Set()\n  peerInfo.multiaddrs.forEach((multiaddr) => {\n    multiaddr.protos().map(protocolToProtocolTag).forEach((protocolTag) => {\n      protocolTags.add(protocolTag)\n    })\n  })\n\n  return Array.from(protocolTags)\n}\n\nfunction protocolToProtocolTag (protocol) {\n  return protocol.name.toLowerCase()\n}\n"]},"metadata":{},"sourceType":"script"}