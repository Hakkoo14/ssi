{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar CID = require('cids');\n\nvar log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nvar UnixFS = require('ipfs-unixfs');\n\nvar _require2 = require('./hamt-utils'),\n    generatePath = _require2.generatePath,\n    updateHamtDirectory = _require2.updateHamtDirectory;\n\nvar errCode = require('err-code');\n\nvar mc = require('multicodec');\n\nvar mh = require('multihashes');\n\nvar removeLink = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(context, options) {\n    var meta;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(!options.parentCid && !options.parent)) {\n              _context.next = 2;\n              break;\n            }\n\n            throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n\n          case 2:\n            if (!(options.parentCid && !CID.isCID(options.parentCid))) {\n              _context.next = 4;\n              break;\n            }\n\n            throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n\n          case 4:\n            if (options.parent) {\n              _context.next = 9;\n              break;\n            }\n\n            log(\"Loading parent node \".concat(options.parentCid));\n            _context.next = 8;\n            return context.ipld.get(options.parentCid);\n\n          case 8:\n            options.parent = _context.sent;\n\n          case 9:\n            if (options.name) {\n              _context.next = 11;\n              break;\n            }\n\n            throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n\n          case 11:\n            meta = UnixFS.unmarshal(options.parent.Data);\n\n            if (!(meta.type === 'hamt-sharded-directory')) {\n              _context.next = 15;\n              break;\n            }\n\n            log(\"Removing \".concat(options.name, \" from sharded directory\"));\n            return _context.abrupt(\"return\", removeFromShardedDirectory(context, options));\n\n          case 15:\n            log(\"Removing link \".concat(options.name, \" regular directory\"));\n            return _context.abrupt(\"return\", removeFromDirectory(context, options));\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function removeLink(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar removeFromDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, options) {\n    var format, hashAlg, newParentNode, cid;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            format = mc[options.format.toUpperCase().replace(/-/g, '_')];\n            hashAlg = mh.names[options.hashAlg];\n            _context2.next = 4;\n            return DAGNode.rmLink(options.parent, options.name);\n\n          case 4:\n            newParentNode = _context2.sent;\n            _context2.next = 7;\n            return context.ipld.put(newParentNode, format, {\n              cidVersion: options.cidVersion,\n              hashAlg: hashAlg\n            });\n\n          case 7:\n            cid = _context2.sent;\n            log(\"Updated regular directory \".concat(cid));\n            return _context2.abrupt(\"return\", {\n              node: newParentNode,\n              cid: cid\n            });\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function removeFromDirectory(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar removeFromShardedDirectory = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(context, options) {\n    var _yield$generatePath, rootBucket, path, _yield$updateShard, node;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return generatePath(context, options.name, options.parent);\n\n          case 2:\n            _yield$generatePath = _context3.sent;\n            rootBucket = _yield$generatePath.rootBucket;\n            path = _yield$generatePath.path;\n            _context3.next = 7;\n            return rootBucket.del(options.name);\n\n          case 7:\n            _context3.next = 9;\n            return updateShard(context, path, {\n              name: options.name,\n              cid: options.cid,\n              size: options.size,\n              hashAlg: options.hashAlg,\n              format: options.format,\n              cidVersion: options.cidVersion,\n              flush: options.flush\n            }, options);\n\n          case 9:\n            _yield$updateShard = _context3.sent;\n            node = _yield$updateShard.node;\n            return _context3.abrupt(\"return\", updateHamtDirectory(context, node.Links, rootBucket, options));\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function removeFromShardedDirectory(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar updateShard = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(context, positions, child, options) {\n    var _positions$pop, bucket, prefix, node, link, newNode, result, newName, size;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _positions$pop = positions.pop(), bucket = _positions$pop.bucket, prefix = _positions$pop.prefix, node = _positions$pop.node;\n            link = node.Links.find(function (link) {\n              return link.Name.substring(0, 2) === prefix;\n            });\n\n            if (link) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw errCode(new Error(\"No link found with prefix \".concat(prefix, \" for file \").concat(child.name)), 'ERR_NOT_FOUND');\n\n          case 4:\n            if (!(link.Name === \"\".concat(prefix).concat(child.name))) {\n              _context4.next = 12;\n              break;\n            }\n\n            log(\"Removing existing link \".concat(link.Name));\n            _context4.next = 8;\n            return DAGNode.rmLink(node, link.Name);\n\n          case 8:\n            newNode = _context4.sent;\n            _context4.next = 11;\n            return bucket.del(child.name);\n\n          case 11:\n            return _context4.abrupt(\"return\", updateHamtDirectory(context, newNode.Links, bucket, options));\n\n          case 12:\n            log(\"Descending into sub-shard \".concat(link.Name, \" for \").concat(prefix).concat(child.name));\n            _context4.next = 15;\n            return updateShard(context, positions, child, options);\n\n          case 15:\n            result = _context4.sent;\n            newName = prefix;\n\n            if (result.node.Links.length === 1) {\n              log(\"Removing subshard for \".concat(prefix)); // convert shard back to normal dir\n\n              result.cid = result.node.Links[0].Hash;\n              result.node = result.node.Links[0];\n              newName = \"\".concat(prefix).concat(result.node.Name.substring(2));\n            }\n\n            log(\"Updating shard \".concat(prefix, \" with name \").concat(newName));\n            size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize;\n            return _context4.abrupt(\"return\", updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options));\n\n          case 21:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function updateShard(_x7, _x8, _x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar updateShardParent = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(context, bucket, parent, oldName, newName, size, cid, options) {\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return DAGNode.rmLink(parent, oldName);\n\n          case 2:\n            parent = _context5.sent;\n            _context5.next = 5;\n            return DAGNode.addLink(parent, new DAGLink(newName, size, cid));\n\n          case 5:\n            parent = _context5.sent;\n            return _context5.abrupt(\"return\", updateHamtDirectory(context, parent.Links, bucket, options));\n\n          case 7:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function updateShardParent(_x11, _x12, _x13, _x14, _x15, _x16, _x17, _x18) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nmodule.exports = removeLink;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs-mfs/src/core/utils/remove-link.js"],"names":["require","DAGNode","DAGLink","CID","log","UnixFS","generatePath","updateHamtDirectory","errCode","mc","mh","removeLink","context","options","parentCid","parent","Error","isCID","ipld","get","name","meta","unmarshal","Data","type","removeFromShardedDirectory","removeFromDirectory","format","toUpperCase","replace","hashAlg","names","rmLink","newParentNode","put","cidVersion","cid","node","rootBucket","path","del","updateShard","size","flush","Links","positions","child","pop","bucket","prefix","link","find","Name","substring","newNode","result","newName","length","Hash","isDAGNode","Tsize","updateShardParent","oldName","addLink","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb')\nconst CID = require('cids')\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link')\nconst UnixFS = require('ipfs-unixfs')\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils')\nconst errCode = require('err-code')\nconst mc = require('multicodec')\nconst mh = require('multihashes')\n\nconst removeLink = async (context, options) => {\n  if (!options.parentCid && !options.parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')\n  }\n\n  if (options.parentCid && !CID.isCID(options.parentCid)) {\n    throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')\n  }\n\n  if (!options.parent) {\n    log(`Loading parent node ${options.parentCid}`)\n\n    options.parent = await context.ipld.get(options.parentCid)\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')\n  }\n\n  const meta = UnixFS.unmarshal(options.parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`)\n\n    return removeFromShardedDirectory(context, options)\n  }\n\n  log(`Removing link ${options.name} regular directory`)\n\n  return removeFromDirectory(context, options)\n}\n\nconst removeFromDirectory = async (context, options) => {\n  const format = mc[options.format.toUpperCase().replace(/-/g, '_')]\n  const hashAlg = mh.names[options.hashAlg]\n\n  const newParentNode = await DAGNode.rmLink(options.parent, options.name)\n  const cid = await context.ipld.put(newParentNode, format, {\n    cidVersion: options.cidVersion,\n    hashAlg\n  })\n\n  log(`Updated regular directory ${cid}`)\n\n  return {\n    node: newParentNode,\n    cid\n  }\n}\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket, path\n  } = await generatePath(context, options.name, options.parent)\n\n  await rootBucket.del(options.name)\n\n  const {\n    node\n  } = await updateShard(context, path, {\n    name: options.name,\n    cid: options.cid,\n    size: options.size,\n    hashAlg: options.hashAlg,\n    format: options.format,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  }, options)\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options)\n}\n\nconst updateShard = async (context, positions, child, options) => {\n  const {\n    bucket,\n    prefix,\n    node\n  } = positions.pop()\n\n  const link = node.Links\n    .find(link => link.Name.substring(0, 2) === prefix)\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${child.name}`), 'ERR_NOT_FOUND')\n  }\n\n  if (link.Name === `${prefix}${child.name}`) {\n    log(`Removing existing link ${link.Name}`)\n\n    const newNode = await DAGNode.rmLink(node, link.Name)\n\n    await bucket.del(child.name)\n\n    return updateHamtDirectory(context, newNode.Links, bucket, options)\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${child.name}`)\n\n  const result = await updateShard(context, positions, child, options)\n\n  let newName = prefix\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`)\n\n    // convert shard back to normal dir\n    result.cid = result.node.Links[0].Hash\n    result.node = result.node.Links[0]\n\n    newName = `${prefix}${result.node.Name.substring(2)}`\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`)\n\n  const size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize\n\n  return updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options)\n}\n\nconst updateShardParent = async (context, bucket, parent, oldName, newName, size, cid, options) => {\n  parent = await DAGNode.rmLink(parent, oldName)\n  parent = await DAGNode.addLink(parent, new DAGLink(newName, size, cid))\n\n  return updateHamtDirectory(context, parent.Links, bucket, options)\n}\n\nmodule.exports = removeLink\n"]},"metadata":{},"sourceType":"script"}