{"ast":null,"code":"'use strict';\n\nvar handshake = require('pull-handshake');\n\nvar lp = require('pull-length-prefixed');\n\nvar Connection = require('interface-connection').Connection;\n\nvar writeEncoded = require('../util.js').writeEncoded;\n\nvar some = require('async/some');\n\nfunction selectHandler(rawConn, handlersMap, log) {\n  var cb = function cb(err) {\n    // incoming errors are irrelevant for the app\n    log.error(err);\n  };\n\n  var stream = handshake({\n    timeout: 60 * 1000\n  }, cb);\n  var shake = stream.handshake;\n  next();\n  return stream;\n\n  function next() {\n    lp.decodeFromReader(shake, function (err, data) {\n      if (err) {\n        return cb(err);\n      }\n\n      log('received:', data.toString());\n      var protocol = data.toString().slice(0, -1);\n      matcher(protocol, handlersMap, function (err, result) {\n        if (err) {\n          return cb(err);\n        }\n\n        var key = result;\n\n        if (key) {\n          log('send ack back of: ' + protocol);\n          writeEncoded(shake, data, cb);\n          var conn = new Connection(shake.rest(), rawConn);\n          handlersMap[key].handlerFunc(protocol, conn);\n        } else {\n          log('not supported protocol: ' + protocol);\n          writeEncoded(shake, Buffer.from('na\\n'));\n          next();\n        }\n      });\n    });\n  }\n}\n\nfunction matcher(protocol, handlers, callback) {\n  var supportedProtocols = Object.keys(handlers);\n  var supportedProtocol = false;\n  some(supportedProtocols, function (sp, cb) {\n    handlers[sp].matchFunc(sp, protocol, function (err, result) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (result) {\n        supportedProtocol = sp;\n      }\n\n      cb();\n    });\n  }, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, supportedProtocol);\n  });\n}\n\nmodule.exports = selectHandler;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/multistream-select/src/listener/select-handler.js"],"names":["handshake","require","lp","Connection","writeEncoded","some","selectHandler","rawConn","handlersMap","log","cb","err","error","stream","timeout","shake","next","decodeFromReader","data","toString","protocol","slice","matcher","result","key","conn","rest","handlerFunc","Buffer","from","handlers","callback","supportedProtocols","Object","keys","supportedProtocol","sp","matchFunc","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst handshake = require('pull-handshake')\nconst lp = require('pull-length-prefixed')\nconst Connection = require('interface-connection').Connection\nconst writeEncoded = require('../util.js').writeEncoded\nconst some = require('async/some')\n\nfunction selectHandler (rawConn, handlersMap, log) {\n  const cb = (err) => {\n    // incoming errors are irrelevant for the app\n    log.error(err)\n  }\n\n  const stream = handshake({ timeout: 60 * 1000 }, cb)\n  const shake = stream.handshake\n\n  next()\n  return stream\n\n  function next () {\n    lp.decodeFromReader(shake, (err, data) => {\n      if (err) {\n        return cb(err)\n      }\n      log('received:', data.toString())\n      const protocol = data.toString().slice(0, -1)\n\n      matcher(protocol, handlersMap, (err, result) => {\n        if (err) {\n          return cb(err)\n        }\n        const key = result\n\n        if (key) {\n          log('send ack back of: ' + protocol)\n          writeEncoded(shake, data, cb)\n\n          const conn = new Connection(shake.rest(), rawConn)\n          handlersMap[key].handlerFunc(protocol, conn)\n        } else {\n          log('not supported protocol: ' + protocol)\n          writeEncoded(shake, Buffer.from('na\\n'))\n          next()\n        }\n      })\n    })\n  }\n}\n\nfunction matcher (protocol, handlers, callback) {\n  const supportedProtocols = Object.keys(handlers)\n  let supportedProtocol = false\n\n  some(supportedProtocols,\n    (sp, cb) => {\n      handlers[sp].matchFunc(sp, protocol, (err, result) => {\n        if (err) {\n          return cb(err)\n        }\n        if (result) {\n          supportedProtocol = sp\n        }\n        cb()\n      })\n    },\n    (err) => {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, supportedProtocol)\n    }\n  )\n}\n\nmodule.exports = selectHandler\n"]},"metadata":{},"sourceType":"script"}