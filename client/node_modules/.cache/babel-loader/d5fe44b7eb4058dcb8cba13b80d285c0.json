{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar lp = require('pull-length-prefixed');\n\nvar pull = require('pull-stream');\n\nvar waterfall = require('async/waterfall');\n\nvar each = require('async/each');\n\nvar nextTick = require('async/nextTick');\n\nvar Message = require('./types/message');\n\nvar CONSTANTS = require('./constants');\n\nvar logger = require('./utils').logger;\n\nvar BITSWAP100 = '/ipfs/bitswap/1.0.0';\nvar BITSWAP110 = '/ipfs/bitswap/1.1.0';\n\nvar Network = /*#__PURE__*/function () {\n  function Network(libp2p, bitswap, options, stats) {\n    _classCallCheck(this, Network);\n\n    this._log = logger(libp2p.peerInfo.id, 'network');\n    options = options || {};\n    this.libp2p = libp2p;\n    this.bitswap = bitswap;\n    this.b100Only = options.b100Only || false;\n    this._stats = stats;\n    this._running = false;\n  }\n\n  _createClass(Network, [{\n    key: \"start\",\n    value: function start(callback) {\n      var _this = this;\n\n      this._running = true; // bind event listeners\n\n      this._onPeerConnect = this._onPeerConnect.bind(this);\n      this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n      this._onConnection = this._onConnection.bind(this);\n      this.libp2p.handle(BITSWAP100, this._onConnection);\n\n      if (!this.b100Only) {\n        this.libp2p.handle(BITSWAP110, this._onConnection);\n      }\n\n      this.libp2p.on('peer:connect', this._onPeerConnect);\n      this.libp2p.on('peer:disconnect', this._onPeerDisconnect); // All existing connections are like new ones for us\n\n      this.libp2p.peerBook.getAllArray().filter(function (peer) {\n        return peer.isConnected();\n      }).forEach(function (peer) {\n        return _this._onPeerConnect(peer);\n      });\n      nextTick(function () {\n        return callback();\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      this._running = false;\n      this.libp2p.unhandle(BITSWAP100);\n\n      if (!this.b100Only) {\n        this.libp2p.unhandle(BITSWAP110);\n      }\n\n      this.libp2p.removeListener('peer:connect', this._onPeerConnect);\n      this.libp2p.removeListener('peer:disconnect', this._onPeerDisconnect);\n      nextTick(function () {\n        return callback();\n      });\n    } // Handles both types of bitswap messgages\n\n  }, {\n    key: \"_onConnection\",\n    value: function _onConnection(protocol, conn) {\n      var _this2 = this;\n\n      if (!this._running) {\n        return;\n      }\n\n      this._log('incomming new bitswap connection: %s', protocol);\n\n      pull(conn, lp.decode(), pull.asyncMap(function (data, cb) {\n        return Message.deserialize(data, cb);\n      }), pull.asyncMap(function (msg, cb) {\n        conn.getPeerInfo(function (err, peerInfo) {\n          if (err) {\n            return cb(err);\n          } // this._log('data from', peerInfo.id.toB58String())\n\n\n          _this2.bitswap._receiveMessage(peerInfo.id, msg, cb);\n        });\n      }), pull.onEnd(function (err) {\n        _this2._log('ending connection');\n\n        if (err) {\n          _this2.bitswap._receiveError(err);\n        }\n      }));\n    }\n  }, {\n    key: \"_onPeerConnect\",\n    value: function _onPeerConnect(peerInfo) {\n      if (!this._running) {\n        return;\n      }\n\n      this.bitswap._onPeerConnected(peerInfo.id);\n    }\n  }, {\n    key: \"_onPeerDisconnect\",\n    value: function _onPeerDisconnect(peerInfo) {\n      if (!this._running) {\n        return;\n      }\n\n      this.bitswap._onPeerDisconnected(peerInfo.id);\n    }\n  }, {\n    key: \"findProviders\",\n    value: function findProviders(cid, maxProviders, callback) {\n      this.libp2p.contentRouting.findProviders(cid, {\n        maxTimeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders\n      }, callback);\n    }\n  }, {\n    key: \"findAndConnect\",\n    value: function findAndConnect(cid, callback) {\n      var _this3 = this;\n\n      waterfall([function (cb) {\n        return _this3.findProviders(cid, CONSTANTS.maxProvidersPerRequest, cb);\n      }, function (provs, cb) {\n        _this3._log('connecting to providers', provs.map(function (p) {\n          return p.id.toB58String();\n        }));\n\n        each(provs, function (p, cb) {\n          return _this3.connectTo(p, cb);\n        });\n      }], callback);\n    }\n  }, {\n    key: \"provide\",\n    value: function provide(cid, callback) {\n      this.libp2p.contentRouting.provide(cid, callback);\n    } // Connect to the given peer\n    // Send the given msg (instance of Message) to the given peer\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(peer, msg, callback) {\n      var _this4 = this;\n\n      if (!this._running) {\n        return callback(new Error(\"network isn't running\"));\n      }\n\n      var stringId = peer.toB58String() ? peer.toB58String() : peer.id.toB58String();\n\n      this._log('sendMessage to %s', stringId, msg);\n\n      this._dialPeer(peer, function (err, conn, protocol) {\n        if (err) {\n          return callback(err);\n        }\n\n        var serialized;\n\n        switch (protocol) {\n          case BITSWAP100:\n            serialized = msg.serializeToBitswap100();\n            break;\n\n          case BITSWAP110:\n            serialized = msg.serializeToBitswap110();\n            break;\n\n          default:\n            return callback(new Error('Unkown protocol: ' + protocol));\n        } // TODO: why doesn't the error get propageted back??\n\n\n        writeMessage(conn, serialized, function (err) {\n          if (err) {\n            _this4._log.error(err);\n          }\n        });\n        callback();\n\n        _this4._updateSentStats(peer, msg.blocks);\n      });\n    }\n  }, {\n    key: \"connectTo\",\n    value: function connectTo(peer, callback) {\n      if (!this._running) {\n        return callback(new Error(\"network isn't running\"));\n      }\n\n      this.libp2p.dial(peer, callback);\n    } // Dial to the peer and try to use the most recent Bitswap\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(peer, callback) {\n      var _this5 = this;\n\n      // Attempt Bitswap 1.1.0\n      this.libp2p.dialProtocol(peer, BITSWAP110, function (err, conn) {\n        if (err) {\n          // Attempt Bitswap 1.0.0\n          _this5.libp2p.dialProtocol(peer, BITSWAP100, function (err, conn) {\n            if (err) {\n              return callback(err);\n            }\n\n            callback(null, conn, BITSWAP100);\n          });\n\n          return;\n        }\n\n        callback(null, conn, BITSWAP110);\n      });\n    }\n  }, {\n    key: \"_updateSentStats\",\n    value: function _updateSentStats(peer, blocks) {\n      var _this6 = this;\n\n      var peerId = peer.toB58String();\n\n      if (this._stats) {\n        blocks.forEach(function (block) {\n          return _this6._stats.push(peerId, 'dataSent', block.data.length);\n        });\n\n        this._stats.push(peerId, 'blocksSent', blocks.size);\n      }\n    }\n  }]);\n\n  return Network;\n}();\n\nfunction writeMessage(conn, msg, callback) {\n  pull(pull.values([msg]), lp.encode(), conn, pull.onEnd(callback));\n}\n\nmodule.exports = Network;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs-bitswap/src/network.js"],"names":["lp","require","pull","waterfall","each","nextTick","Message","CONSTANTS","logger","BITSWAP100","BITSWAP110","Network","libp2p","bitswap","options","stats","_log","peerInfo","id","b100Only","_stats","_running","callback","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","handle","on","peerBook","getAllArray","filter","peer","isConnected","forEach","unhandle","removeListener","protocol","conn","decode","asyncMap","data","cb","deserialize","msg","getPeerInfo","err","_receiveMessage","onEnd","_receiveError","_onPeerConnected","_onPeerDisconnected","cid","maxProviders","contentRouting","findProviders","maxTimeout","providerRequestTimeout","maxNumProviders","maxProvidersPerRequest","provs","map","p","toB58String","connectTo","provide","Error","stringId","_dialPeer","serialized","serializeToBitswap100","serializeToBitswap110","writeMessage","error","_updateSentStats","blocks","dial","dialProtocol","peerId","block","push","length","size","values","encode","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst lp = require('pull-length-prefixed')\nconst pull = require('pull-stream')\nconst waterfall = require('async/waterfall')\nconst each = require('async/each')\nconst nextTick = require('async/nextTick')\n\nconst Message = require('./types/message')\nconst CONSTANTS = require('./constants')\nconst logger = require('./utils').logger\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0'\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0'\n\nclass Network {\n  constructor (libp2p, bitswap, options, stats) {\n    this._log = logger(libp2p.peerInfo.id, 'network')\n    options = options || {}\n    this.libp2p = libp2p\n    this.bitswap = bitswap\n    this.b100Only = options.b100Only || false\n\n    this._stats = stats\n    this._running = false\n  }\n\n  start (callback) {\n    this._running = true\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n\n    this._onConnection = this._onConnection.bind(this)\n    this.libp2p.handle(BITSWAP100, this._onConnection)\n    if (!this.b100Only) { this.libp2p.handle(BITSWAP110, this._onConnection) }\n\n    this.libp2p.on('peer:connect', this._onPeerConnect)\n    this.libp2p.on('peer:disconnect', this._onPeerDisconnect)\n\n    // All existing connections are like new ones for us\n    this.libp2p.peerBook\n      .getAllArray()\n      .filter((peer) => peer.isConnected())\n      .forEach((peer) => this._onPeerConnect((peer)))\n\n    nextTick(() => callback())\n  }\n\n  stop (callback) {\n    this._running = false\n\n    this.libp2p.unhandle(BITSWAP100)\n    if (!this.b100Only) { this.libp2p.unhandle(BITSWAP110) }\n\n    this.libp2p.removeListener('peer:connect', this._onPeerConnect)\n    this.libp2p.removeListener('peer:disconnect', this._onPeerDisconnect)\n\n    nextTick(() => callback())\n  }\n\n  // Handles both types of bitswap messgages\n  _onConnection (protocol, conn) {\n    if (!this._running) { return }\n    this._log('incomming new bitswap connection: %s', protocol)\n\n    pull(\n      conn,\n      lp.decode(),\n      pull.asyncMap((data, cb) => Message.deserialize(data, cb)),\n      pull.asyncMap((msg, cb) => {\n        conn.getPeerInfo((err, peerInfo) => {\n          if (err) { return cb(err) }\n\n          // this._log('data from', peerInfo.id.toB58String())\n          this.bitswap._receiveMessage(peerInfo.id, msg, cb)\n        })\n      }),\n      pull.onEnd((err) => {\n        this._log('ending connection')\n        if (err) {\n          this.bitswap._receiveError(err)\n        }\n      })\n    )\n  }\n\n  _onPeerConnect (peerInfo) {\n    if (!this._running) { return }\n\n    this.bitswap._onPeerConnected(peerInfo.id)\n  }\n\n  _onPeerDisconnect (peerInfo) {\n    if (!this._running) { return }\n\n    this.bitswap._onPeerDisconnected(peerInfo.id)\n  }\n\n  findProviders (cid, maxProviders, callback) {\n    this.libp2p.contentRouting.findProviders(cid, {\n      maxTimeout: CONSTANTS.providerRequestTimeout,\n      maxNumProviders: maxProviders\n    }, callback)\n  }\n\n  findAndConnect (cid, callback) {\n    waterfall([\n      (cb) => this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, cb),\n      (provs, cb) => {\n        this._log('connecting to providers', provs.map((p) => p.id.toB58String()))\n        each(provs, (p, cb) => this.connectTo(p, cb))\n      }\n    ], callback)\n  }\n\n  provide (cid, callback) {\n    this.libp2p.contentRouting.provide(cid, callback)\n  }\n\n  // Connect to the given peer\n  // Send the given msg (instance of Message) to the given peer\n  sendMessage (peer, msg, callback) {\n    if (!this._running) { return callback(new Error(`network isn't running`)) }\n\n    const stringId = peer.toB58String() ? peer.toB58String() : peer.id.toB58String()\n    this._log('sendMessage to %s', stringId, msg)\n\n    this._dialPeer(peer, (err, conn, protocol) => {\n      if (err) {\n        return callback(err)\n      }\n\n      let serialized\n      switch (protocol) {\n        case BITSWAP100:\n          serialized = msg.serializeToBitswap100()\n          break\n        case BITSWAP110:\n          serialized = msg.serializeToBitswap110()\n          break\n        default:\n          return callback(new Error('Unkown protocol: ' + protocol))\n      }\n      // TODO: why doesn't the error get propageted back??\n      writeMessage(conn, serialized, (err) => {\n        if (err) {\n          this._log.error(err)\n        }\n      })\n      callback()\n      this._updateSentStats(peer, msg.blocks)\n    })\n  }\n\n  connectTo (peer, callback) {\n    if (!this._running) { return callback(new Error(`network isn't running`)) }\n\n    this.libp2p.dial(peer, callback)\n  }\n\n  // Dial to the peer and try to use the most recent Bitswap\n  _dialPeer (peer, callback) {\n    // Attempt Bitswap 1.1.0\n    this.libp2p.dialProtocol(peer, BITSWAP110, (err, conn) => {\n      if (err) {\n        // Attempt Bitswap 1.0.0\n        this.libp2p.dialProtocol(peer, BITSWAP100, (err, conn) => {\n          if (err) { return callback(err) }\n\n          callback(null, conn, BITSWAP100)\n        })\n\n        return\n      }\n\n      callback(null, conn, BITSWAP110)\n    })\n  }\n\n  _updateSentStats (peer, blocks) {\n    const peerId = peer.toB58String()\n    if (this._stats) {\n      blocks.forEach((block) => this._stats.push(peerId, 'dataSent', block.data.length))\n      this._stats.push(peerId, 'blocksSent', blocks.size)\n    }\n  }\n}\n\nfunction writeMessage (conn, msg, callback) {\n  pull(\n    pull.values([msg]),\n    lp.encode(),\n    conn,\n    pull.onEnd(callback)\n  )\n}\n\nmodule.exports = Network\n"]},"metadata":{},"sourceType":"script"}