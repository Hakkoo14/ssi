{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar waterfall = require('async/waterfall');\n\nvar series = require('async/series');\n\nvar parallel = require('async/parallel');\n\nvar each = require('async/each');\n\nvar _get = require('dlv');\n\nvar assert = require('assert');\n\nvar path = require('path');\n\nvar debug = require('debug');\n\nvar Big = require('bignumber.js');\n\nvar pull = require('pull-stream/pull');\n\nvar reduce = require('pull-stream/sinks/reduce');\n\nvar backends = require('./backends');\n\nvar version = require('./version');\n\nvar config = require('./config');\n\nvar spec = require('./spec');\n\nvar apiAddr = require('./api-addr');\n\nvar blockstore = require('./blockstore');\n\nvar defaultOptions = require('./default-options');\n\nvar defaultDatastore = require('./default-datastore');\n\nvar ERRORS = require('./errors');\n\nvar log = debug('repo');\nvar noLimit = Number.MAX_SAFE_INTEGER;\nvar lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n};\n\nvar repoVersion = require('./constants').repoVersion;\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\n\n\nvar IpfsRepo = /*#__PURE__*/function () {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  function IpfsRepo(repoPath, options) {\n    _classCallCheck(this, IpfsRepo);\n\n    assert.strictEqual(typeof repoPath, 'string', 'missing repoPath');\n    this.options = buildOptions(options);\n    this.closed = true;\n    this.path = repoPath;\n    this._locker = this._getLocker();\n    this.root = backends.create('root', this.path, this.options);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(IpfsRepo, [{\n    key: \"init\",\n    value: function init(config, callback) {\n      var _this = this;\n\n      log('initializing at: %s', this.path);\n      series([function (cb) {\n        return _this.root.open(ignoringAlreadyOpened(cb));\n      }, function (cb) {\n        return _this.config.set(buildConfig(config), cb);\n      }, function (cb) {\n        return _this.spec.set(buildDatastoreSpec(config), cb);\n      }, function (cb) {\n        return _this.version.set(repoVersion, cb);\n      }], callback);\n    }\n    /**\n     * Open the repo. If the repo is already open no action will be taken.\n     * If the repo is not initialized it will return an error.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"open\",\n    value: function open(callback) {\n      var _this2 = this;\n\n      if (!this.closed) {\n        setImmediate(function () {\n          return callback(new Error('repo is already open'));\n        });\n        return; // early\n      }\n\n      log('opening at: %s', this.path); // check if the repo is already initialized\n\n      waterfall([function (cb) {\n        return _this2.root.open(ignoringAlreadyOpened(cb));\n      }, function (cb) {\n        return _this2._isInitialized(cb);\n      }, function (cb) {\n        return _this2._openLock(_this2.path, cb);\n      }, function (lck, cb) {\n        log('aquired repo.lock');\n        _this2.lockfile = lck;\n        cb();\n      }, function (cb) {\n        log('creating datastore');\n        _this2.datastore = backends.create('datastore', path.join(_this2.path, 'datastore'), _this2.options);\n        log('creating blocks');\n        var blocksBaseStore = backends.create('blocks', path.join(_this2.path, 'blocks'), _this2.options);\n        blockstore(blocksBaseStore, _this2.options.storageBackendOptions.blocks, cb);\n      }, function (blocks, cb) {\n        _this2.blocks = blocks;\n        cb();\n      }, function (cb) {\n        log('creating keystore');\n        _this2.keys = backends.create('keys', path.join(_this2.path, 'keys'), _this2.options);\n        cb();\n      }, function (cb) {\n        _this2.closed = false;\n        log('all opened');\n        cb();\n      }], function (err) {\n        if (err && _this2.lockfile) {\n          _this2._closeLock(function (err2) {\n            if (!err2) {\n              _this2.lockfile = null;\n            } else {\n              log('error removing lock', err2);\n            }\n\n            callback(err);\n          });\n        } else {\n          callback(err);\n        }\n      });\n    }\n    /**\n     * Returns the repo locker to be used. Null will be returned if no locker is requested\n     *\n     * @private\n     * @returns {Locker}\n     */\n\n  }, {\n    key: \"_getLocker\",\n    value: function _getLocker() {\n      if (typeof this.options.lock === 'string') {\n        assert(lockers[this.options.lock], 'Unknown lock type: ' + this.options.lock);\n        return lockers[this.options.lock];\n      }\n\n      assert(this.options.lock, 'No lock provided');\n      return this.options.lock;\n    }\n    /**\n     * Creates a lock on the repo if a locker is specified. The lockfile object will\n     * be returned in the callback if one has been created.\n     *\n     * @param {string} path\n     * @param {function(Error, lockfile)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_openLock\",\n    value: function _openLock(path, callback) {\n      this._locker.lock(path, function (err, lockfile) {\n        if (err) {\n          return callback(err, null);\n        }\n\n        assert.strictEqual(typeof lockfile.close, 'function', 'Locks must have a close method');\n        callback(null, lockfile);\n      });\n    }\n    /**\n     * Closes the lock on the repo\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_closeLock\",\n    value: function _closeLock(callback) {\n      if (this.lockfile) {\n        return this.lockfile.close(callback);\n      }\n\n      callback();\n    }\n    /**\n     * Check if the repo is already initialized.\n     *\n     * @private\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_isInitialized\",\n    value: function _isInitialized(callback) {\n      var _this3 = this;\n\n      log('init check');\n      parallel({\n        config: function config(cb) {\n          return _this3.config.exists(cb);\n        },\n        spec: function spec(cb) {\n          return _this3.spec.exists(cb);\n        },\n        version: function version(cb) {\n          return _this3.version.check(repoVersion, cb);\n        }\n      }, function (err, res) {\n        log('init', err, res);\n\n        if (err && !res.config) {\n          return callback(Object.assign(new Error('repo is not initialized yet'), {\n            code: ERRORS.ERR_REPO_NOT_INITIALIZED,\n            path: _this3.path\n          }));\n        }\n\n        callback(err);\n      });\n    }\n    /**\n     * Close the repo and cleanup.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      var _this4 = this;\n\n      if (this.closed) {\n        return callback(new Error('repo is already closed'));\n      }\n\n      log('closing at: %s', this.path);\n      series([function (cb) {\n        return _this4.apiAddr.delete(ignoringNotFound(cb));\n      }, function (cb) {\n        each([_this4.blocks, _this4.keys, _this4.datastore], function (store, callback) {\n          return store.close(callback);\n        }, cb);\n      }, function (cb) {\n        log('unlocking');\n        _this4.closed = true;\n\n        _this4._closeLock(cb);\n      }, function (cb) {\n        _this4.lockfile = null;\n        cb();\n      }], function (err) {\n        return callback(err);\n      });\n    }\n    /**\n     * Check if a repo exists.\n     *\n     * @param {function(Error, bool)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"exists\",\n    value: function exists(callback) {\n      this.version.exists(callback);\n    }\n    /**\n     * Get repo status.\n     *\n     * @param {Object}  options\n     * @param {Boolean} options.human\n     * @param {function(Error, Object)} callback\n     * @return {void}\n     */\n\n  }, {\n    key: \"stat\",\n    value: function stat(options, callback) {\n      var _this5 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = Object.assign({}, {\n        human: false\n      }, options);\n      parallel({\n        storageMax: function storageMax(cb) {\n          return _this5.config.get('Datastore.StorageMax', function (err, max) {\n            if (err) {\n              cb(null, new Big(noLimit));\n            } else {\n              cb(null, new Big(max));\n            }\n          });\n        },\n        version: function version(cb) {\n          return _this5.version.get(cb);\n        },\n        blocks: function blocks(cb) {\n          return _this5.blocks.query({}, function (err, list) {\n            list = list || [];\n            var count = new Big(list.length);\n            var size = new Big(0);\n            list.forEach(function (block) {\n              size = size.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n            });\n            cb(err, {\n              count: count,\n              size: size\n            });\n          });\n        },\n        datastore: function datastore(cb) {\n          return getSize(_this5.datastore, cb);\n        },\n        keys: function keys(cb) {\n          return getSize(_this5.keys, cb);\n        }\n      }, function (err, results) {\n        if (err) return callback(err);\n        var size = results.blocks.size.plus(results.datastore).plus(results.keys);\n\n        if (options.human) {\n          size = size.div(1048576);\n        }\n\n        callback(null, {\n          repoPath: _this5.path,\n          storageMax: results.storageMax,\n          version: results.version,\n          numObjects: results.blocks.count,\n          repoSize: size\n        });\n      });\n    }\n  }]);\n\n  return IpfsRepo;\n}();\n\nfunction getSize(queryFn, callback) {\n  pull(queryFn.query({}), reduce(function (sum, block) {\n    return sum.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n  }, new Big(0), callback));\n}\n\nmodule.exports = IpfsRepo;\nmodule.exports.repoVersion = repoVersion;\nmodule.exports.errors = ERRORS;\n\nfunction ignoringIf(cond, cb) {\n  return function (err) {\n    cb(err && !cond(err) ? err : null);\n  };\n}\n\nfunction ignoringAlreadyOpened(cb) {\n  return ignoringIf(function (err) {\n    return err.message === 'Already open';\n  }, cb);\n}\n\nfunction ignoringNotFound(cb) {\n  return ignoringIf(function (err) {\n    return err && (err.code === ERRORS.ERR_REPO_NOT_INITIALIZED || err.message.startsWith('ENOENT'));\n  }, cb);\n}\n\nfunction buildOptions(_options) {\n  var options = Object.assign({}, defaultOptions, _options);\n  options.storageBackends = Object.assign({}, defaultOptions.storageBackends, options.storageBackends);\n  options.storageBackendOptions = Object.assign({}, defaultOptions.storageBackendOptions, options.storageBackendOptions);\n  return options;\n} // TODO this should come from js-ipfs instead\n\n\nfunction buildConfig(_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}));\n  return _config;\n}\n\nfunction buildDatastoreSpec(_config) {\n  var spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}));\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(function (mounting) {\n      return {\n        mountpoint: mounting.mountpoint,\n        type: mounting.child.type,\n        path: mounting.child.path,\n        shardFunc: mounting.child.shardFunc\n      };\n    })\n  };\n}","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs-repo/src/index.js"],"names":["waterfall","require","series","parallel","each","_get","assert","path","debug","Big","pull","reduce","backends","version","config","spec","apiAddr","blockstore","defaultOptions","defaultDatastore","ERRORS","log","noLimit","Number","MAX_SAFE_INTEGER","lockers","memory","fs","repoVersion","IpfsRepo","repoPath","options","strictEqual","buildOptions","closed","_locker","_getLocker","root","create","callback","cb","open","ignoringAlreadyOpened","set","buildConfig","buildDatastoreSpec","setImmediate","Error","_isInitialized","_openLock","lck","lockfile","datastore","join","blocksBaseStore","storageBackendOptions","blocks","keys","err","_closeLock","err2","lock","close","exists","check","res","Object","assign","code","ERR_REPO_NOT_INITIALIZED","delete","ignoringNotFound","store","human","storageMax","get","max","query","list","count","length","size","forEach","block","plus","value","byteLength","key","_buf","getSize","results","div","numObjects","repoSize","queryFn","sum","module","exports","errors","ignoringIf","cond","message","startsWith","_options","storageBackends","_config","Spec","type","mounts","map","mounting","mountpoint","child","shardFunc"],"mappings":"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","sourcesContent":["'use strict'\n\nconst waterfall = require('async/waterfall')\nconst series = require('async/series')\nconst parallel = require('async/parallel')\nconst each = require('async/each')\nconst _get = require('dlv')\nconst assert = require('assert')\nconst path = require('path')\nconst debug = require('debug')\nconst Big = require('bignumber.js')\nconst pull = require('pull-stream/pull')\nconst reduce = require('pull-stream/sinks/reduce')\n\nconst backends = require('./backends')\nconst version = require('./version')\nconst config = require('./config')\nconst spec = require('./spec')\nconst apiAddr = require('./api-addr')\nconst blockstore = require('./blockstore')\nconst defaultOptions = require('./default-options')\nconst defaultDatastore = require('./default-datastore')\nconst ERRORS = require('./errors')\n\nconst log = debug('repo')\n\nconst noLimit = Number.MAX_SAFE_INTEGER\n\nconst lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n}\n\nconst repoVersion = require('./constants').repoVersion\n\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\nclass IpfsRepo {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  constructor (repoPath, options) {\n    assert.strictEqual(typeof repoPath, 'string', 'missing repoPath')\n\n    this.options = buildOptions(options)\n    this.closed = true\n    this.path = repoPath\n\n    this._locker = this._getLocker()\n\n    this.root = backends.create('root', this.path, this.options)\n    this.version = version(this.root)\n    this.config = config(this.root)\n    this.spec = spec(this.root)\n    this.apiAddr = apiAddr(this.root)\n  }\n\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  init (config, callback) {\n    log('initializing at: %s', this.path)\n\n    series([\n      (cb) => this.root.open(ignoringAlreadyOpened(cb)),\n      (cb) => this.config.set(buildConfig(config), cb),\n      (cb) => this.spec.set(buildDatastoreSpec(config), cb),\n      (cb) => this.version.set(repoVersion, cb)\n    ], callback)\n  }\n\n  /**\n   * Open the repo. If the repo is already open no action will be taken.\n   * If the repo is not initialized it will return an error.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  open (callback) {\n    if (!this.closed) {\n      setImmediate(() => callback(new Error('repo is already open')))\n      return // early\n    }\n    log('opening at: %s', this.path)\n\n    // check if the repo is already initialized\n    waterfall([\n      (cb) => this.root.open(ignoringAlreadyOpened(cb)),\n      (cb) => this._isInitialized(cb),\n      (cb) => this._openLock(this.path, cb),\n      (lck, cb) => {\n        log('aquired repo.lock')\n        this.lockfile = lck\n        cb()\n      },\n      (cb) => {\n        log('creating datastore')\n        this.datastore = backends.create('datastore', path.join(this.path, 'datastore'), this.options)\n        log('creating blocks')\n        const blocksBaseStore = backends.create('blocks', path.join(this.path, 'blocks'), this.options)\n        blockstore(\n          blocksBaseStore,\n          this.options.storageBackendOptions.blocks,\n          cb)\n      },\n      (blocks, cb) => {\n        this.blocks = blocks\n        cb()\n      },\n      (cb) => {\n        log('creating keystore')\n        this.keys = backends.create('keys', path.join(this.path, 'keys'), this.options)\n        cb()\n      },\n\n      (cb) => {\n        this.closed = false\n        log('all opened')\n        cb()\n      }\n    ], (err) => {\n      if (err && this.lockfile) {\n        this._closeLock((err2) => {\n          if (!err2) {\n            this.lockfile = null\n          } else {\n            log('error removing lock', err2)\n          }\n          callback(err)\n        })\n      } else {\n        callback(err)\n      }\n    })\n  }\n\n  /**\n   * Returns the repo locker to be used. Null will be returned if no locker is requested\n   *\n   * @private\n   * @returns {Locker}\n   */\n  _getLocker () {\n    if (typeof this.options.lock === 'string') {\n      assert(lockers[this.options.lock], 'Unknown lock type: ' + this.options.lock)\n      return lockers[this.options.lock]\n    }\n\n    assert(this.options.lock, 'No lock provided')\n    return this.options.lock\n  }\n\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @param {string} path\n   * @param {function(Error, lockfile)} callback\n   * @returns {void}\n   */\n  _openLock (path, callback) {\n    this._locker.lock(path, (err, lockfile) => {\n      if (err) {\n        return callback(err, null)\n      }\n\n      assert.strictEqual(typeof lockfile.close, 'function', 'Locks must have a close method')\n      callback(null, lockfile)\n    })\n  }\n\n  /**\n   * Closes the lock on the repo\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  _closeLock (callback) {\n    if (this.lockfile) {\n      return this.lockfile.close(callback)\n    }\n    callback()\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @private\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  _isInitialized (callback) {\n    log('init check')\n    parallel(\n      {\n        config: (cb) => this.config.exists(cb),\n        spec: (cb) => this.spec.exists(cb),\n        version: (cb) => this.version.check(repoVersion, cb)\n      },\n      (err, res) => {\n        log('init', err, res)\n        if (err && !res.config) {\n          return callback(Object.assign(new Error('repo is not initialized yet'),\n            {\n              code: ERRORS.ERR_REPO_NOT_INITIALIZED,\n              path: this.path\n            }))\n        }\n        callback(err)\n      }\n    )\n  }\n\n  /**\n   * Close the repo and cleanup.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  close (callback) {\n    if (this.closed) {\n      return callback(new Error('repo is already closed'))\n    }\n\n    log('closing at: %s', this.path)\n    series([\n      (cb) => this.apiAddr.delete(ignoringNotFound(cb)),\n      (cb) => {\n        each(\n          [this.blocks, this.keys, this.datastore],\n          (store, callback) => store.close(callback),\n          cb)\n      },\n      (cb) => {\n        log('unlocking')\n        this.closed = true\n        this._closeLock(cb)\n      },\n      (cb) => {\n        this.lockfile = null\n        cb()\n      }\n    ], (err) => callback(err))\n  }\n\n  /**\n   * Check if a repo exists.\n   *\n   * @param {function(Error, bool)} callback\n   * @returns {void}\n   */\n  exists (callback) {\n    this.version.exists(callback)\n  }\n\n  /**\n   * Get repo status.\n   *\n   * @param {Object}  options\n   * @param {Boolean} options.human\n   * @param {function(Error, Object)} callback\n   * @return {void}\n   */\n  stat (options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    options = Object.assign({}, { human: false }, options)\n\n    parallel({\n      storageMax: (cb) => this.config.get('Datastore.StorageMax', (err, max) => {\n        if (err) {\n          cb(null, new Big(noLimit))\n        } else {\n          cb(null, new Big(max))\n        }\n      }),\n      version: (cb) => this.version.get(cb),\n      blocks: (cb) => this.blocks.query({}, (err, list) => {\n        list = list || []\n\n        const count = new Big(list.length)\n        let size = new Big(0)\n\n        list.forEach(block => {\n          size = size\n            .plus(block.value.byteLength)\n            .plus(block.key._buf.byteLength)\n        })\n\n        cb(err, {\n          count: count,\n          size: size\n        })\n      }),\n      datastore: (cb) => getSize(this.datastore, cb),\n      keys: (cb) => getSize(this.keys, cb)\n    }, (err, results) => {\n      if (err) return callback(err)\n\n      let size = results.blocks.size\n        .plus(results.datastore)\n        .plus(results.keys)\n\n      if (options.human) {\n        size = size.div(1048576)\n      }\n\n      callback(null, {\n        repoPath: this.path,\n        storageMax: results.storageMax,\n        version: results.version,\n        numObjects: results.blocks.count,\n        repoSize: size\n      })\n    })\n  }\n}\n\nfunction getSize (queryFn, callback) {\n  pull(\n    queryFn.query({}),\n    reduce((sum, block) => {\n      return sum\n        .plus(block.value.byteLength)\n        .plus(block.key._buf.byteLength)\n    }, new Big(0), callback))\n}\n\nmodule.exports = IpfsRepo\nmodule.exports.repoVersion = repoVersion\nmodule.exports.errors = ERRORS\n\nfunction ignoringIf (cond, cb) {\n  return (err) => {\n    cb(err && !cond(err) ? err : null)\n  }\n}\nfunction ignoringAlreadyOpened (cb) {\n  return ignoringIf((err) => err.message === 'Already open', cb)\n}\n\nfunction ignoringNotFound (cb) {\n  return ignoringIf((err) => {\n    return err && (err.code === ERRORS.ERR_REPO_NOT_INITIALIZED || err.message.startsWith('ENOENT'))\n  }, cb)\n}\n\nfunction buildOptions (_options) {\n  const options = Object.assign({}, defaultOptions, _options)\n\n  options.storageBackends = Object.assign(\n    {},\n    defaultOptions.storageBackends,\n    options.storageBackends)\n\n  options.storageBackendOptions = Object.assign(\n    {},\n    defaultOptions.storageBackendOptions,\n    options.storageBackendOptions)\n\n  return options\n}\n\n// TODO this should come from js-ipfs instead\nfunction buildConfig (_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}))\n\n  return _config\n}\n\nfunction buildDatastoreSpec (_config) {\n  const spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}))\n\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map((mounting) => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}