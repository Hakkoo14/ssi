{"ast":null,"code":"'use strict';\n\nvar debug = require('debug');\n\nvar IncomingConnection = require('./incoming');\n\nvar observeConn = require('../observe-connection');\n\nfunction listener(_switch) {\n  var log = debug(\"libp2p:switch:listener\");\n  /**\n   * Takes a transport key and returns a connection handler function\n   *\n   * @param {string} transportKey The key of the transport to handle connections for\n   * @param {function} handler A custom handler to use\n   * @returns {function(Connection)} A connection handler function\n   */\n\n  return function (transportKey, handler) {\n    /**\n     * Takes a base connection and manages listening behavior\n     *\n     * @param {Connection} conn The connection to manage\n     * @returns {void}\n     */\n    return function (conn) {\n      log('received incoming connection for transport %s', transportKey);\n      conn.getPeerInfo(function (_, peerInfo) {\n        // Add a transport level observer, if needed\n        var connection = transportKey ? observeConn(transportKey, null, conn, _switch.observer) : conn;\n        var connFSM = new IncomingConnection({\n          connection: connection,\n          _switch: _switch,\n          transportKey: transportKey,\n          peerInfo: peerInfo\n        });\n        connFSM.once('error', function (err) {\n          return log(err);\n        });\n        connFSM.once('private', function (_conn) {\n          // Use the custom handler, if it was provided\n          if (handler) {\n            return handler(_conn);\n          }\n\n          connFSM.encrypt();\n        });\n        connFSM.once('encrypted', function () {\n          return connFSM.upgrade();\n        });\n        connFSM.protect();\n      });\n    };\n  };\n}\n\nmodule.exports = listener;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-switch/src/connection/handler.js"],"names":["debug","require","IncomingConnection","observeConn","listener","_switch","log","transportKey","handler","conn","getPeerInfo","_","peerInfo","connection","observer","connFSM","once","err","_conn","encrypt","upgrade","protect","module","exports"],"mappings":"AAAA;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMC,kBAAkB,GAAGD,OAAO,CAAC,YAAD,CAAlC;;AACA,IAAME,WAAW,GAAGF,OAAO,CAAC,uBAAD,CAA3B;;AAEA,SAASG,QAAT,CAAmBC,OAAnB,EAA4B;AAC1B,MAAMC,GAAG,GAAGN,KAAK,0BAAjB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAO,UAAUO,YAAV,EAAwBC,OAAxB,EAAiC;AACtC;AACJ;AACA;AACA;AACA;AACA;AACI,WAAO,UAAUC,IAAV,EAAgB;AACrBH,MAAAA,GAAG,CAAC,+CAAD,EAAkDC,YAAlD,CAAH;AACAE,MAAAA,IAAI,CAACC,WAAL,CAAiB,UAACC,CAAD,EAAIC,QAAJ,EAAiB;AAChC;AACA,YAAMC,UAAU,GAAGN,YAAY,GAAGJ,WAAW,CAACI,YAAD,EAAe,IAAf,EAAqBE,IAArB,EAA2BJ,OAAO,CAACS,QAAnC,CAAd,GAA6DL,IAA5F;AACA,YAAMM,OAAO,GAAG,IAAIb,kBAAJ,CAAuB;AAAEW,UAAAA,UAAU,EAAVA,UAAF;AAAcR,UAAAA,OAAO,EAAPA,OAAd;AAAuBE,UAAAA,YAAY,EAAZA,YAAvB;AAAqCK,UAAAA,QAAQ,EAARA;AAArC,SAAvB,CAAhB;AAEAG,QAAAA,OAAO,CAACC,IAAR,CAAa,OAAb,EAAsB,UAACC,GAAD;AAAA,iBAASX,GAAG,CAACW,GAAD,CAAZ;AAAA,SAAtB;AACAF,QAAAA,OAAO,CAACC,IAAR,CAAa,SAAb,EAAwB,UAACE,KAAD,EAAW;AACjC;AACA,cAAIV,OAAJ,EAAa;AACX,mBAAOA,OAAO,CAACU,KAAD,CAAd;AACD;;AACDH,UAAAA,OAAO,CAACI,OAAR;AACD,SAND;AAOAJ,QAAAA,OAAO,CAACC,IAAR,CAAa,WAAb,EAA0B;AAAA,iBAAMD,OAAO,CAACK,OAAR,EAAN;AAAA,SAA1B;AAEAL,QAAAA,OAAO,CAACM,OAAR;AACD,OAhBD;AAiBD,KAnBD;AAoBD,GA3BD;AA4BD;;AAEDC,MAAM,CAACC,OAAP,GAAiBnB,QAAjB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst IncomingConnection = require('./incoming')\nconst observeConn = require('../observe-connection')\n\nfunction listener (_switch) {\n  const log = debug(`libp2p:switch:listener`)\n\n  /**\n   * Takes a transport key and returns a connection handler function\n   *\n   * @param {string} transportKey The key of the transport to handle connections for\n   * @param {function} handler A custom handler to use\n   * @returns {function(Connection)} A connection handler function\n   */\n  return function (transportKey, handler) {\n    /**\n     * Takes a base connection and manages listening behavior\n     *\n     * @param {Connection} conn The connection to manage\n     * @returns {void}\n     */\n    return function (conn) {\n      log('received incoming connection for transport %s', transportKey)\n      conn.getPeerInfo((_, peerInfo) => {\n        // Add a transport level observer, if needed\n        const connection = transportKey ? observeConn(transportKey, null, conn, _switch.observer) : conn\n        const connFSM = new IncomingConnection({ connection, _switch, transportKey, peerInfo })\n\n        connFSM.once('error', (err) => log(err))\n        connFSM.once('private', (_conn) => {\n          // Use the custom handler, if it was provided\n          if (handler) {\n            return handler(_conn)\n          }\n          connFSM.encrypt()\n        })\n        connFSM.once('encrypted', () => connFSM.upgrade())\n\n        connFSM.protect()\n      })\n    }\n  }\n}\n\nmodule.exports = listener\n"]},"metadata":{},"sourceType":"script"}