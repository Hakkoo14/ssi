{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ConnectionFSM = require('../connection');\n\nvar _require = require('../errors'),\n    DIAL_ABORTED = _require.DIAL_ABORTED,\n    ERR_BLACKLISTED = _require.ERR_BLACKLISTED;\n\nvar nextTick = require('async/nextTick');\n\nvar once = require('once');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:dial');\nlog.error = debug('libp2p:switch:dial:error');\n/**\n * Components required to execute a dial\n * @typedef {Object} DialRequest\n * @property {PeerInfo} peerInfo - The peer to dial to\n * @property {string} [protocol] - The protocol to create a stream for\n * @property {object} options\n * @property {boolean} options.useFSM - If `callback` should return a ConnectionFSM\n * @property {number} options.priority - The priority of the dial\n * @property {function(Error, Connection|ConnectionFSM)} callback\n */\n\n/**\n * @typedef {Object} NewConnection\n * @property {ConnectionFSM} connectionFSM\n * @property {boolean} didCreate\n */\n\n/**\n * Attempts to create a new connection or stream (when muxed),\n * via negotiation of the given `protocol`. If no `protocol` is\n * provided, no action will be taken and `callback` will be called\n * immediately with no error or values.\n *\n * @param {object} options\n * @param {string} options.protocol\n * @param {ConnectionFSM} options.connection\n * @param {function(Error, Connection)} options.callback\n * @returns {void}\n */\n\nfunction createConnectionWithProtocol(_ref) {\n  var protocol = _ref.protocol,\n      connection = _ref.connection,\n      callback = _ref.callback;\n\n  if (!protocol) {\n    return callback();\n  }\n\n  connection.shake(protocol, function (err, conn) {\n    if (!conn) {\n      return callback(err);\n    }\n\n    conn.setPeerInfo(connection.theirPeerInfo);\n    callback(null, conn);\n  });\n}\n/**\n * A convenience array wrapper for controlling\n * a per peer queue\n *\n * @returns {Queue}\n */\n\n\nvar Queue = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {string} peerId\n   * @param {Switch} _switch\n   * @param {function(string)} onStopped Called when the queue stops\n   */\n  function Queue(peerId, _switch, onStopped) {\n    _classCallCheck(this, Queue);\n\n    this.id = peerId;\n    this.switch = _switch;\n    this._queue = [];\n    this.blackListed = null;\n    this.blackListCount = 0;\n    this.isRunning = false;\n    this.onStopped = onStopped;\n  }\n\n  _createClass(Queue, [{\n    key: \"length\",\n    get: function get() {\n      return this._queue.length;\n    }\n    /**\n     * Adds the dial request to the queue. The queue is not automatically started\n     * @param {string} protocol\n     * @param {boolean} useFSM If callback should use a ConnectionFSM instead\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(protocol, useFSM, callback) {\n      if (!this.isDialAllowed()) {\n        return nextTick(callback, ERR_BLACKLISTED());\n      }\n\n      this._queue.push({\n        protocol: protocol,\n        useFSM: useFSM,\n        callback: callback\n      });\n    }\n    /**\n     * Determines whether or not dialing is currently allowed\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isDialAllowed\",\n    value: function isDialAllowed() {\n      if (this.blackListed) {\n        // If the blacklist ttl has passed, reset it\n        if (Date.now() > this.blackListed) {\n          this.blackListed = null;\n          return true;\n        } // Dial is not allowed\n\n\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Starts the queue. If the queue was started `true` will be returned.\n     * If the queue was already running `false` is returned.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (!this.isRunning) {\n        log('starting dial queue to %s', this.id);\n        this.isRunning = true;\n\n        this._run();\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Stops the queue\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.isRunning) {\n        log('stopping dial queue to %s', this.id);\n        this.isRunning = false;\n        this.onStopped(this.id);\n      }\n    }\n    /**\n     * Stops the queue and errors the callback for each dial request\n     */\n\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      while (this.length > 0) {\n        var dial = this._queue.shift();\n\n        dial.callback(DIAL_ABORTED());\n      }\n\n      this.stop();\n    }\n    /**\n     * Marks the queue as blacklisted. The queue will be immediately aborted.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"blacklist\",\n    value: function blacklist() {\n      this.blackListCount++;\n\n      if (this.blackListCount >= this.switch.dialer.BLACK_LIST_ATTEMPTS) {\n        this.blackListed = Infinity;\n        return;\n      }\n\n      var ttl = this.switch.dialer.BLACK_LIST_TTL * Math.pow(this.blackListCount, 3);\n      var minTTL = ttl * 0.9;\n      var maxTTL = ttl * 1.1; // Add a random jitter of 20% to the ttl\n\n      ttl = Math.floor(Math.random() * (maxTTL - minTTL) + minTTL);\n      this.blackListed = Date.now() + ttl;\n      this.abort();\n    }\n    /**\n     * Attempts to find a muxed connection for the given peer. If one\n     * isn't found, a new one will be created.\n     *\n     * Returns an array containing two items. The ConnectionFSM and wether\n     * or not the ConnectionFSM was just created. The latter can be used\n     * to determine dialing needs.\n     *\n     * @private\n     * @param {PeerInfo} peerInfo\n     * @returns {NewConnection}\n     */\n\n  }, {\n    key: \"_getOrCreateConnection\",\n    value: function _getOrCreateConnection(peerInfo) {\n      var connectionFSM = this.switch.connection.getOne(this.id);\n      var didCreate = false;\n\n      if (!connectionFSM) {\n        connectionFSM = new ConnectionFSM({\n          _switch: this.switch,\n          peerInfo: peerInfo,\n          muxer: null,\n          conn: null\n        });\n        this.switch.connection.add(connectionFSM); // Add control events and start the dialer\n\n        connectionFSM.once('connected', function () {\n          return connectionFSM.protect();\n        });\n        connectionFSM.once('private', function () {\n          return connectionFSM.encrypt();\n        });\n        connectionFSM.once('encrypted', function () {\n          return connectionFSM.upgrade();\n        });\n        didCreate = true;\n      }\n\n      return {\n        connectionFSM: connectionFSM,\n        didCreate: didCreate\n      };\n    }\n    /**\n     * Executes the next dial in the queue for the given peer\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_run\",\n    value: function _run() {\n      var _this = this;\n\n      // If we have no items in the queue or we're stopped, exit\n      if (this.length < 1 || !this.isRunning) {\n        log('stopping the queue for %s', this.id);\n        return this.stop();\n      }\n\n      var next = once(function () {\n        log('starting next dial to %s', _this.id);\n\n        _this._run();\n      });\n\n      var peerInfo = this.switch._peerBook.get(this.id);\n\n      var queuedDial = this._queue.shift();\n\n      var _this$_getOrCreateCon = this._getOrCreateConnection(peerInfo),\n          connectionFSM = _this$_getOrCreateCon.connectionFSM,\n          didCreate = _this$_getOrCreateCon.didCreate; // If the dial expects a ConnectionFSM, we can provide that back now\n\n\n      if (queuedDial.useFSM) {\n        nextTick(queuedDial.callback, null, connectionFSM);\n      } // If we can handshake protocols, get a new stream and call run again\n\n\n      if (['MUXED', 'CONNECTED'].includes(connectionFSM.getState())) {\n        queuedDial.connection = connectionFSM;\n        createConnectionWithProtocol(queuedDial);\n        next();\n        return;\n      } // If we error, error the queued dial\n      // In the future, it may be desired to error the other queued dials,\n      // depending on the error.\n\n\n      connectionFSM.once('error', function (err) {\n        queuedDial.callback(err); // Dont blacklist peers we have identified and that we are connected to\n\n        if (peerInfo.protocols.size > 0 && peerInfo.isConnected()) {\n          return;\n        }\n\n        _this.blacklist();\n      });\n      connectionFSM.once('close', function () {\n        next();\n      }); // If we're not muxed yet, add listeners\n\n      connectionFSM.once('muxed', function () {\n        _this.blackListCount = 0; // reset blacklisting on good connections\n\n        queuedDial.connection = connectionFSM;\n        createConnectionWithProtocol(queuedDial);\n        next();\n      });\n      connectionFSM.once('unmuxed', function () {\n        _this.blackListCount = 0;\n        queuedDial.connection = connectionFSM;\n        createConnectionWithProtocol(queuedDial);\n        next();\n      }); // If we have a new connection, start dialing\n\n      if (didCreate) {\n        connectionFSM.dial();\n      }\n    }\n  }]);\n\n  return Queue;\n}();\n\nmodule.exports = Queue;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-switch/src/dialer/queue.js"],"names":["ConnectionFSM","require","DIAL_ABORTED","ERR_BLACKLISTED","nextTick","once","debug","log","error","createConnectionWithProtocol","protocol","connection","callback","shake","err","conn","setPeerInfo","theirPeerInfo","Queue","peerId","_switch","onStopped","id","switch","_queue","blackListed","blackListCount","isRunning","length","useFSM","isDialAllowed","push","Date","now","_run","dial","shift","stop","dialer","BLACK_LIST_ATTEMPTS","Infinity","ttl","BLACK_LIST_TTL","Math","pow","minTTL","maxTTL","floor","random","abort","peerInfo","connectionFSM","getOne","didCreate","muxer","add","protect","encrypt","upgrade","next","_peerBook","get","queuedDial","_getOrCreateConnection","includes","getState","protocols","size","isConnected","blacklist","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ConnectionFSM = require('../connection')\nconst { DIAL_ABORTED, ERR_BLACKLISTED } = require('../errors')\nconst nextTick = require('async/nextTick')\nconst once = require('once')\nconst debug = require('debug')\nconst log = debug('libp2p:switch:dial')\nlog.error = debug('libp2p:switch:dial:error')\n\n/**\n * Components required to execute a dial\n * @typedef {Object} DialRequest\n * @property {PeerInfo} peerInfo - The peer to dial to\n * @property {string} [protocol] - The protocol to create a stream for\n * @property {object} options\n * @property {boolean} options.useFSM - If `callback` should return a ConnectionFSM\n * @property {number} options.priority - The priority of the dial\n * @property {function(Error, Connection|ConnectionFSM)} callback\n */\n\n/**\n * @typedef {Object} NewConnection\n * @property {ConnectionFSM} connectionFSM\n * @property {boolean} didCreate\n */\n\n/**\n * Attempts to create a new connection or stream (when muxed),\n * via negotiation of the given `protocol`. If no `protocol` is\n * provided, no action will be taken and `callback` will be called\n * immediately with no error or values.\n *\n * @param {object} options\n * @param {string} options.protocol\n * @param {ConnectionFSM} options.connection\n * @param {function(Error, Connection)} options.callback\n * @returns {void}\n */\nfunction createConnectionWithProtocol ({ protocol, connection, callback }) {\n  if (!protocol) {\n    return callback()\n  }\n  connection.shake(protocol, (err, conn) => {\n    if (!conn) {\n      return callback(err)\n    }\n\n    conn.setPeerInfo(connection.theirPeerInfo)\n    callback(null, conn)\n  })\n}\n\n/**\n * A convenience array wrapper for controlling\n * a per peer queue\n *\n * @returns {Queue}\n */\nclass Queue {\n  /**\n   * @constructor\n   * @param {string} peerId\n   * @param {Switch} _switch\n   * @param {function(string)} onStopped Called when the queue stops\n   */\n  constructor (peerId, _switch, onStopped) {\n    this.id = peerId\n    this.switch = _switch\n    this._queue = []\n    this.blackListed = null\n    this.blackListCount = 0\n    this.isRunning = false\n    this.onStopped = onStopped\n  }\n  get length () {\n    return this._queue.length\n  }\n\n  /**\n   * Adds the dial request to the queue. The queue is not automatically started\n   * @param {string} protocol\n   * @param {boolean} useFSM If callback should use a ConnectionFSM instead\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  add (protocol, useFSM, callback) {\n    if (!this.isDialAllowed()) {\n      return nextTick(callback, ERR_BLACKLISTED())\n    }\n    this._queue.push({ protocol, useFSM, callback })\n  }\n\n  /**\n   * Determines whether or not dialing is currently allowed\n   * @returns {boolean}\n   */\n  isDialAllowed () {\n    if (this.blackListed) {\n      // If the blacklist ttl has passed, reset it\n      if (Date.now() > this.blackListed) {\n        this.blackListed = null\n        return true\n      }\n      // Dial is not allowed\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Starts the queue. If the queue was started `true` will be returned.\n   * If the queue was already running `false` is returned.\n   * @returns {boolean}\n   */\n  start () {\n    if (!this.isRunning) {\n      log('starting dial queue to %s', this.id)\n      this.isRunning = true\n      this._run()\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Stops the queue\n   */\n  stop () {\n    if (this.isRunning) {\n      log('stopping dial queue to %s', this.id)\n      this.isRunning = false\n      this.onStopped(this.id)\n    }\n  }\n\n  /**\n   * Stops the queue and errors the callback for each dial request\n   */\n  abort () {\n    while (this.length > 0) {\n      let dial = this._queue.shift()\n      dial.callback(DIAL_ABORTED())\n    }\n    this.stop()\n  }\n\n  /**\n   * Marks the queue as blacklisted. The queue will be immediately aborted.\n   * @returns {void}\n   */\n  blacklist () {\n    this.blackListCount++\n\n    if (this.blackListCount >= this.switch.dialer.BLACK_LIST_ATTEMPTS) {\n      this.blackListed = Infinity\n      return\n    }\n\n    let ttl = this.switch.dialer.BLACK_LIST_TTL * Math.pow(this.blackListCount, 3)\n    const minTTL = ttl * 0.9\n    const maxTTL = ttl * 1.1\n\n    // Add a random jitter of 20% to the ttl\n    ttl = Math.floor(Math.random() * (maxTTL - minTTL) + minTTL)\n\n    this.blackListed = Date.now() + ttl\n    this.abort()\n  }\n\n  /**\n   * Attempts to find a muxed connection for the given peer. If one\n   * isn't found, a new one will be created.\n   *\n   * Returns an array containing two items. The ConnectionFSM and wether\n   * or not the ConnectionFSM was just created. The latter can be used\n   * to determine dialing needs.\n   *\n   * @private\n   * @param {PeerInfo} peerInfo\n   * @returns {NewConnection}\n   */\n  _getOrCreateConnection (peerInfo) {\n    let connectionFSM = this.switch.connection.getOne(this.id)\n    let didCreate = false\n\n    if (!connectionFSM) {\n      connectionFSM = new ConnectionFSM({\n        _switch: this.switch,\n        peerInfo,\n        muxer: null,\n        conn: null\n      })\n\n      this.switch.connection.add(connectionFSM)\n\n      // Add control events and start the dialer\n      connectionFSM.once('connected', () => connectionFSM.protect())\n      connectionFSM.once('private', () => connectionFSM.encrypt())\n      connectionFSM.once('encrypted', () => connectionFSM.upgrade())\n\n      didCreate = true\n    }\n\n    return { connectionFSM, didCreate }\n  }\n\n  /**\n   * Executes the next dial in the queue for the given peer\n   * @private\n   * @returns {void}\n   */\n  _run () {\n    // If we have no items in the queue or we're stopped, exit\n    if (this.length < 1 || !this.isRunning) {\n      log('stopping the queue for %s', this.id)\n      return this.stop()\n    }\n\n    const next = once(() => {\n      log('starting next dial to %s', this.id)\n      this._run()\n    })\n\n    const peerInfo = this.switch._peerBook.get(this.id)\n    let queuedDial = this._queue.shift()\n    let { connectionFSM, didCreate } = this._getOrCreateConnection(peerInfo)\n\n    // If the dial expects a ConnectionFSM, we can provide that back now\n    if (queuedDial.useFSM) {\n      nextTick(queuedDial.callback, null, connectionFSM)\n    }\n\n    // If we can handshake protocols, get a new stream and call run again\n    if (['MUXED', 'CONNECTED'].includes(connectionFSM.getState())) {\n      queuedDial.connection = connectionFSM\n      createConnectionWithProtocol(queuedDial)\n      next()\n      return\n    }\n\n    // If we error, error the queued dial\n    // In the future, it may be desired to error the other queued dials,\n    // depending on the error.\n    connectionFSM.once('error', (err) => {\n      queuedDial.callback(err)\n      // Dont blacklist peers we have identified and that we are connected to\n      if (peerInfo.protocols.size > 0 && peerInfo.isConnected()) {\n        return\n      }\n      this.blacklist()\n    })\n\n    connectionFSM.once('close', () => {\n      next()\n    })\n\n    // If we're not muxed yet, add listeners\n    connectionFSM.once('muxed', () => {\n      this.blackListCount = 0 // reset blacklisting on good connections\n      queuedDial.connection = connectionFSM\n      createConnectionWithProtocol(queuedDial)\n      next()\n    })\n\n    connectionFSM.once('unmuxed', () => {\n      this.blackListCount = 0\n      queuedDial.connection = connectionFSM\n      createConnectionWithProtocol(queuedDial)\n      next()\n    })\n\n    // If we have a new connection, start dialing\n    if (didCreate) {\n      connectionFSM.dial()\n    }\n  }\n}\n\nmodule.exports = Queue\n"]},"metadata":{},"sourceType":"script"}