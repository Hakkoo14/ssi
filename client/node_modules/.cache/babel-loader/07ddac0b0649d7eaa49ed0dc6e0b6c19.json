{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar errCode = require('err-code');\n\nvar log = require('debug')('ipfs:mfs:mkdir');\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar createNode = require('./utils/create-node');\n\nvar toPathComponents = require('./utils/to-path-components');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar updateTree = require('./utils/update-tree');\n\nvar addLink = require('./utils/add-link');\n\nvar withMfsRoot = require('./utils/with-mfs-root');\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar _require = require('./utils/constants'),\n    FILE_SEPARATOR = _require.FILE_SEPARATOR;\n\nvar defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  format: 'dag-pb',\n  flush: true\n};\n\nmodule.exports = function (context) {\n  return /*#__PURE__*/function () {\n    var _mfsMkdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, options) {\n      var pathComponents, root, parent, trail, emptyDir, i, subPathComponents, subPath, newRootCid;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = applyDefaultOptions(options, defaultOptions);\n\n              if (path) {\n                _context.next = 3;\n                break;\n              }\n\n              throw new Error('no path given to Mkdir');\n\n            case 3:\n              path = path.trim();\n\n              if (!(path === FILE_SEPARATOR)) {\n                _context.next = 8;\n                break;\n              }\n\n              if (!options.parents) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 7:\n              throw errCode(new Error(\"cannot create directory '\".concat(FILE_SEPARATOR, \"': Already exists\")), 'ERR_INVALID_PATH');\n\n            case 8:\n              if (!(path.substring(0, 1) !== FILE_SEPARATOR)) {\n                _context.next = 10;\n                break;\n              }\n\n              throw errCode(new Error('paths must start with a leading /'), 'ERR_INVALID_PATH');\n\n            case 10:\n              log(\"Creating \".concat(path));\n              pathComponents = toPathComponents(path);\n\n              if (!(pathComponents[0] === 'ipfs')) {\n                _context.next = 14;\n                break;\n              }\n\n              throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n\n            case 14:\n              _context.next = 16;\n              return withMfsRoot(context);\n\n            case 16:\n              root = _context.sent;\n              trail = [];\n              _context.next = 20;\n              return createNode(context, 'directory', options);\n\n            case 20:\n              emptyDir = _context.sent;\n              i = 0;\n\n            case 22:\n              if (!(i <= pathComponents.length)) {\n                _context.next = 51;\n                break;\n              }\n\n              subPathComponents = pathComponents.slice(0, i);\n              subPath = \"/ipfs/\".concat(root, \"/\").concat(subPathComponents.join('/'));\n              _context.prev = 25;\n              _context.next = 28;\n              return exporter(subPath, context.ipld);\n\n            case 28:\n              parent = _context.sent;\n              log(\"\".concat(subPath, \" existed\"));\n              log(\"\".concat(subPath, \" had children \").concat(parent.node.Links.map(function (link) {\n                return link.Name;\n              })));\n\n              if (!(i === pathComponents.length)) {\n                _context.next = 35;\n                break;\n              }\n\n              if (!options.parents) {\n                _context.next = 34;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 34:\n              throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n\n            case 35:\n              trail.push({\n                name: parent.name,\n                cid: parent.cid\n              });\n              _context.next = 48;\n              break;\n\n            case 38:\n              _context.prev = 38;\n              _context.t0 = _context[\"catch\"](25);\n\n              if (!(_context.t0.code === 'ERR_NOT_FOUND')) {\n                _context.next = 47;\n                break;\n              }\n\n              if (!(i < pathComponents.length && !options.parents)) {\n                _context.next = 43;\n                break;\n              }\n\n              throw errCode(new Error(\"Intermediate directory path \".concat(subPath, \" does not exist, use the -p flag to create it\")), 'ERR_NOT_FOUND');\n\n            case 43:\n              _context.next = 45;\n              return addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options);\n\n            case 45:\n              _context.next = 48;\n              break;\n\n            case 47:\n              throw _context.t0;\n\n            case 48:\n              i++;\n              _context.next = 22;\n              break;\n\n            case 51:\n              _context.next = 53;\n              return updateTree(context, trail, options);\n\n            case 53:\n              newRootCid = _context.sent;\n              _context.next = 56;\n              return updateMfsRoot(context, newRootCid);\n\n            case 56:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[25, 38]]);\n    }));\n\n    function mfsMkdir(_x, _x2) {\n      return _mfsMkdir.apply(this, arguments);\n    }\n\n    return mfsMkdir;\n  }();\n};\n\nvar addEmptyDir = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, childName, emptyDir, parent, trail, options) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            log(\"Adding empty dir called \".concat(childName, \" to \").concat(parent.cid));\n            _context2.next = 3;\n            return addLink(context, {\n              parent: parent.node,\n              parentCid: parent.cid,\n              size: emptyDir.node.size,\n              cid: emptyDir.cid,\n              name: childName,\n              format: options.format,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion\n            });\n\n          case 3:\n            result = _context2.sent;\n            trail[trail.length - 1].cid = result.cid;\n            trail.push({\n              name: childName,\n              cid: emptyDir.cid\n            });\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function addEmptyDir(_x3, _x4, _x5, _x6, _x7, _x8) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs-mfs/src/core/mkdir.js"],"names":["errCode","require","log","exporter","createNode","toPathComponents","updateMfsRoot","updateTree","addLink","withMfsRoot","applyDefaultOptions","FILE_SEPARATOR","defaultOptions","parents","hashAlg","cidVersion","shardSplitThreshold","format","flush","module","exports","context","path","options","Error","trim","substring","pathComponents","root","trail","emptyDir","i","length","subPathComponents","slice","subPath","join","ipld","parent","node","Links","map","link","Name","push","name","cid","code","addEmptyDir","newRootCid","mfsMkdir","childName","parentCid","size","result"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst log = require('debug')('ipfs:mfs:mkdir')\nconst exporter = require('ipfs-unixfs-exporter')\nconst createNode = require('./utils/create-node')\nconst toPathComponents = require('./utils/to-path-components')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst updateTree = require('./utils/update-tree')\nconst addLink = require('./utils/add-link')\nconst withMfsRoot = require('./utils/with-mfs-root')\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst {\n  FILE_SEPARATOR\n} = require('./utils/constants')\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  format: 'dag-pb',\n  flush: true\n}\n\nmodule.exports = (context) => {\n  return async function mfsMkdir (path, options) {\n    options = applyDefaultOptions(options, defaultOptions)\n\n    if (!path) {\n      throw new Error('no path given to Mkdir')\n    }\n\n    path = path.trim()\n\n    if (path === FILE_SEPARATOR) {\n      if (options.parents) {\n        return\n      }\n\n      throw errCode(new Error(`cannot create directory '${FILE_SEPARATOR}': Already exists`), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(0, 1) !== FILE_SEPARATOR) {\n      throw errCode(new Error('paths must start with a leading /'), 'ERR_INVALID_PATH')\n    }\n\n    log(`Creating ${path}`)\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH')\n    }\n\n    let root = await withMfsRoot(context)\n    let parent\n    let trail = []\n    const emptyDir = await createNode(context, 'directory', options)\n\n    // make sure the containing folder exists, creating it if necessary\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i)\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`\n\n      try {\n        parent = await exporter(subPath, context.ipld)\n        log(`${subPath} existed`)\n        log(`${subPath} had children ${parent.node.Links.map(link => link.Name)}`)\n\n        if (i === pathComponents.length) {\n          if (options.parents) {\n            return\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS')\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        })\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !options.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND')\n          }\n\n          // add the intermediate directory\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options)\n        } else {\n          throw err\n        }\n      }\n    }\n\n    // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n\n    // update the tree from the leaf to the root\n    const newRootCid = await updateTree(context, trail, options)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid)\n  }\n}\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`)\n\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    size: emptyDir.node.size,\n    cid: emptyDir.cid,\n    name: childName,\n    format: options.format,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion\n  })\n\n  trail[trail.length - 1].cid = result.cid\n\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  })\n}\n"]},"metadata":{},"sourceType":"script"}