{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar FSM = require('fsm-event');\n\nvar Circuit = require('libp2p-circuit');\n\nvar multistream = require('multistream-select');\n\nvar withIs = require('class-is');\n\nvar BaseConnection = require('./base');\n\nvar parallel = require('async/parallel');\n\nvar nextTick = require('async/nextTick');\n\nvar identify = require('libp2p-identify');\n\nvar errCode = require('err-code');\n\nvar _require = require('../utils'),\n    msHandle = _require.msHandle,\n    msSelect = _require.msSelect,\n    identifyDialer = _require.identifyDialer;\n\nvar observeConnection = require('../observe-connection');\n\nvar _require2 = require('../errors'),\n    CONNECTION_FAILED = _require2.CONNECTION_FAILED,\n    DIAL_SELF = _require2.DIAL_SELF,\n    INVALID_STATE_TRANSITION = _require2.INVALID_STATE_TRANSITION,\n    NO_TRANSPORTS_REGISTERED = _require2.NO_TRANSPORTS_REGISTERED,\n    maybeUnexpectedEnd = _require2.maybeUnexpectedEnd;\n/**\n * @typedef {Object} ConnectionOptions\n * @property {Switch} _switch Our switch instance\n * @property {PeerInfo} peerInfo The PeerInfo of the peer to dial\n * @property {Muxer} muxer Optional - A muxed connection\n * @property {Connection} conn Optional - The base connection\n * @property {string} type Optional - identify the connection as incoming or outgoing. Defaults to out.\n */\n\n/**\n * ConnectionFSM handles the complex logic of managing a connection\n * between peers. ConnectionFSM is internally composed of a state machine\n * to help improve the usability and debuggability of connections. The\n * state machine also helps to improve the ability to handle dial backoff,\n * coalescing dials and dial locks.\n */\n\n\nvar ConnectionFSM = /*#__PURE__*/function (_BaseConnection) {\n  _inherits(ConnectionFSM, _BaseConnection);\n\n  var _super = _createSuper(ConnectionFSM);\n\n  /**\n   * @param {ConnectionOptions} connectionOptions\n   * @constructor\n   */\n  function ConnectionFSM(_ref) {\n    var _this;\n\n    var _switch = _ref._switch,\n        peerInfo = _ref.peerInfo,\n        muxer = _ref.muxer,\n        conn = _ref.conn,\n        _ref$type = _ref.type,\n        type = _ref$type === void 0 ? 'out' : _ref$type;\n\n    _classCallCheck(this, ConnectionFSM);\n\n    _this = _super.call(this, {\n      _switch: _switch,\n      name: \"\".concat(type, \":\").concat(_switch._peerInfo.id.toB58String().slice(0, 8))\n    });\n    _this.theirPeerInfo = peerInfo;\n    _this.theirB58Id = _this.theirPeerInfo.id.toB58String();\n    _this.conn = conn; // The base connection\n\n    _this.muxer = muxer; // The upgraded/muxed connection\n\n    var startState = 'DISCONNECTED';\n\n    if (_this.muxer) {\n      startState = 'MUXED';\n    }\n\n    _this._state = FSM(startState, {\n      DISCONNECTED: {\n        // No active connections exist for the peer\n        dial: 'DIALING',\n        disconnect: 'DISCONNECTED',\n        done: 'DISCONNECTED'\n      },\n      DIALING: {\n        // Creating an initial connection\n        abort: 'ABORTED',\n        // emit events for different transport dials?\n        done: 'DIALED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      DIALED: {\n        // Base connection to peer established\n        encrypt: 'ENCRYPTING',\n        privatize: 'PRIVATIZING'\n      },\n      PRIVATIZING: {\n        // Protecting the base connection\n        done: 'PRIVATIZED',\n        abort: 'ABORTED',\n        disconnect: 'DISCONNECTING'\n      },\n      PRIVATIZED: {\n        // Base connection is protected\n        encrypt: 'ENCRYPTING'\n      },\n      ENCRYPTING: {\n        // Encrypting the base connection\n        done: 'ENCRYPTED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      ENCRYPTED: {\n        // Upgrading could not happen, the connection is encrypted and waiting\n        upgrade: 'UPGRADING',\n        disconnect: 'DISCONNECTING'\n      },\n      UPGRADING: {\n        // Attempting to upgrade the connection with muxers\n        stop: 'CONNECTED',\n        // If we cannot mux, stop upgrading\n        done: 'MUXED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      MUXED: {\n        disconnect: 'DISCONNECTING'\n      },\n      CONNECTED: {\n        // A non muxed connection is established\n        disconnect: 'DISCONNECTING'\n      },\n      DISCONNECTING: {\n        // Shutting down the connection\n        done: 'DISCONNECTED',\n        disconnect: 'DISCONNECTING'\n      },\n      ABORTED: {},\n      // A severe event occurred\n      ERRORED: {\n        // An error occurred, but future dials may be allowed\n        disconnect: 'DISCONNECTING' // There could be multiple options here, but this is a likely action\n\n      }\n    });\n\n    _this._state.on('DISCONNECTED', function () {\n      return _this._onDisconnected();\n    });\n\n    _this._state.on('DIALING', function () {\n      return _this._onDialing();\n    });\n\n    _this._state.on('DIALED', function () {\n      return _this._onDialed();\n    });\n\n    _this._state.on('PRIVATIZING', function () {\n      return _this._onPrivatizing();\n    });\n\n    _this._state.on('PRIVATIZED', function () {\n      return _this._onPrivatized();\n    });\n\n    _this._state.on('ENCRYPTING', function () {\n      return _this._onEncrypting();\n    });\n\n    _this._state.on('ENCRYPTED', function () {\n      _this.log('successfully encrypted connection to %s', _this.theirB58Id);\n\n      _this.emit('encrypted', _this.conn);\n    });\n\n    _this._state.on('UPGRADING', function () {\n      return _this._onUpgrading();\n    });\n\n    _this._state.on('MUXED', function () {\n      _this.log('successfully muxed connection to %s', _this.theirB58Id);\n\n      delete _this.switch.conns[_this.theirB58Id];\n\n      _this.emit('muxed', _this.muxer);\n    });\n\n    _this._state.on('CONNECTED', function () {\n      _this.log('unmuxed connection opened to %s', _this.theirB58Id);\n\n      _this.emit('unmuxed', _this.conn);\n    });\n\n    _this._state.on('DISCONNECTING', function () {\n      return _this._onDisconnecting();\n    });\n\n    _this._state.on('ABORTED', function () {\n      return _this._onAborted();\n    });\n\n    _this._state.on('ERRORED', function () {\n      return _this._onErrored();\n    });\n\n    _this._state.on('error', function (err) {\n      return _this._onStateError(err);\n    });\n\n    return _this;\n  }\n  /**\n   * Puts the state into dialing mode\n   *\n   * @fires ConnectionFSM#Error May emit a DIAL_SELF error\n   * @returns {void}\n   */\n\n\n  _createClass(ConnectionFSM, [{\n    key: \"dial\",\n    value: function dial() {\n      if (this.theirB58Id === this.ourPeerInfo.id.toB58String()) {\n        return this.emit('error', DIAL_SELF());\n      } else if (this.getState() === 'DIALING') {\n        return this.log('attempted to dial while already dialing, ignoring');\n      }\n\n      this._state('dial');\n    }\n    /**\n     * Initiates a handshake for the given protocol\n     *\n     * @param {string} protocol The protocol to negotiate\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"shake\",\n    value: function shake(protocol, callback) {\n      var _this2 = this;\n\n      // If there is no protocol set yet, don't perform the handshake\n      if (!protocol) {\n        return callback(null, null);\n      }\n\n      if (this.muxer && this.muxer.newStream) {\n        return this.muxer.newStream(function (err, stream) {\n          if (err) {\n            return callback(err, null);\n          }\n\n          _this2.log('created new stream to %s', _this2.theirB58Id);\n\n          _this2._protocolHandshake(protocol, stream, callback);\n        });\n      }\n\n      this._protocolHandshake(protocol, this.conn, callback);\n    }\n    /**\n     * Puts the state into muxing mode\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"upgrade\",\n    value: function upgrade() {\n      this._state('upgrade');\n    }\n    /**\n     * Event handler for dialing. Transitions state when successful.\n     *\n     * @private\n     * @fires ConnectionFSM#error\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onDialing\",\n    value: function _onDialing() {\n      var _this3 = this;\n\n      this.log('dialing %s', this.theirB58Id);\n\n      if (!this.switch.hasTransports()) {\n        return this.close(NO_TRANSPORTS_REGISTERED());\n      }\n\n      var tKeys = this.switch.availableTransports(this.theirPeerInfo);\n      var circuitEnabled = Boolean(this.switch.transports[Circuit.tag]);\n\n      if (circuitEnabled && !tKeys.includes(Circuit.tag)) {\n        tKeys.push(Circuit.tag);\n      }\n\n      var nextTransport = function nextTransport(key) {\n        var transport = key;\n\n        if (!transport) {\n          if (!circuitEnabled) {\n            return _this3.close(CONNECTION_FAILED(\"Circuit not enabled and all transports failed to dial peer \".concat(_this3.theirB58Id, \"!\")));\n          }\n\n          return _this3.close(CONNECTION_FAILED(\"No available transports to dial peer \".concat(_this3.theirB58Id, \"!\")));\n        }\n\n        if (transport === Circuit.tag) {\n          _this3.theirPeerInfo.multiaddrs.add(\"/p2p-circuit/p2p/\".concat(_this3.theirB58Id));\n        }\n\n        _this3.log('dialing transport %s', transport);\n\n        _this3.switch.transport.dial(transport, _this3.theirPeerInfo, function (errors, _conn) {\n          if (errors) {\n            _this3.emit('error:connection_attempt_failed', errors);\n\n            _this3.log(errors);\n\n            return nextTransport(tKeys.shift());\n          }\n\n          _this3.conn = observeConnection(transport, null, _conn, _this3.switch.observer);\n\n          _this3._state('done');\n        });\n      };\n\n      nextTransport(tKeys.shift());\n    }\n    /**\n     * Once a connection has been successfully dialed, the connection\n     * will be privatized or encrypted depending on the presence of the\n     * Switch.protector.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onDialed\",\n    value: function _onDialed() {\n      this.log('successfully dialed %s', this.theirB58Id);\n      this.emit('connected', this.conn);\n    }\n    /**\n     * Event handler for disconnecting. Handles any needed cleanup\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onDisconnecting\",\n    value: function _onDisconnecting() {\n      var _this4 = this;\n\n      this.log('disconnecting from %s', this.theirB58Id, Boolean(this.muxer));\n      delete this.switch.conns[this.theirB58Id];\n      var tasks = []; // Clean up stored connections\n\n      if (this.muxer) {\n        tasks.push(function (cb) {\n          _this4.muxer.end(function () {\n            delete _this4.muxer;\n            cb();\n          });\n        });\n      } // If we have the base connection, abort it\n      // Ignore abort errors, since we're closing\n\n\n      if (this.conn) {\n        try {\n          this.conn.source.abort();\n        } catch (_) {}\n\n        delete this.conn;\n      }\n\n      parallel(tasks, function () {\n        _this4._state('done');\n      });\n    }\n    /**\n     * Attempts to encrypt `this.conn` with the Switch's crypto.\n     *\n     * @private\n     * @fires ConnectionFSM#error\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onEncrypting\",\n    value: function _onEncrypting() {\n      var _this5 = this;\n\n      var msDialer = new multistream.Dialer();\n      msDialer.handle(this.conn, function (err) {\n        if (err) {\n          return _this5.close(maybeUnexpectedEnd(err));\n        }\n\n        _this5.log('selecting crypto %s to %s', _this5.switch.crypto.tag, _this5.theirB58Id);\n\n        msDialer.select(_this5.switch.crypto.tag, function (err, _conn) {\n          if (err) {\n            return _this5.close(maybeUnexpectedEnd(err));\n          }\n\n          var observedConn = observeConnection(null, _this5.switch.crypto.tag, _conn, _this5.switch.observer);\n\n          var encryptedConn = _this5.switch.crypto.encrypt(_this5.ourPeerInfo.id, observedConn, _this5.theirPeerInfo.id, function (err) {\n            if (err) {\n              return _this5.close(err);\n            }\n\n            _this5.conn = encryptedConn;\n\n            _this5.conn.setPeerInfo(_this5.theirPeerInfo);\n\n            _this5._state('done');\n          });\n        });\n      });\n    }\n    /**\n     * Iterates over each Muxer on the Switch and attempts to upgrade\n     * the given `connection`. Successful muxed connections will be stored\n     * on the Switch.muxedConns with `b58Id` as their key for future reference.\n     *\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onUpgrading\",\n    value: function _onUpgrading() {\n      var _this6 = this;\n\n      var muxers = Object.keys(this.switch.muxers);\n      this.log('upgrading connection to %s', this.theirB58Id);\n\n      if (muxers.length === 0) {\n        return this._state('stop');\n      }\n\n      var msDialer = new multistream.Dialer();\n      msDialer.handle(this.conn, function (err) {\n        if (err) {\n          return _this6._didUpgrade(err);\n        } // 1. try to handshake in one of the muxers available\n        // 2. if succeeds\n        //  - add the muxedConn to the list of muxedConns\n        //  - add incomming new streams to connHandler\n\n\n        var nextMuxer = function nextMuxer(key) {\n          _this6.log('selecting %s', key);\n\n          msDialer.select(key, function (err, _conn) {\n            if (err) {\n              if (muxers.length === 0) {\n                return _this6._didUpgrade(err);\n              }\n\n              return nextMuxer(muxers.shift());\n            } // observe muxed connections\n\n\n            var conn = observeConnection(null, key, _conn, _this6.switch.observer);\n            _this6.muxer = _this6.switch.muxers[key].dialer(conn);\n\n            _this6.muxer.once('close', function () {\n              _this6.close();\n            }); // For incoming streams, in case identify is on\n\n\n            _this6.muxer.on('stream', function (conn) {\n              _this6.log('new stream created via muxer to %s', _this6.theirB58Id);\n\n              conn.setPeerInfo(_this6.theirPeerInfo);\n\n              _this6.switch.protocolMuxer(null)(conn);\n            });\n\n            _this6._didUpgrade(null); // Run identify on the connection\n\n\n            if (_this6.switch.identify) {\n              _this6._identify(function (err, results) {\n                if (err) {\n                  return _this6.close(err);\n                }\n\n                _this6.theirPeerInfo = _this6.switch._peerBook.put(results.peerInfo);\n              });\n            }\n          });\n        };\n\n        nextMuxer(muxers.shift());\n      });\n    }\n    /**\n     * Runs the identify protocol on the connection\n     * @private\n     * @param {function(error, { PeerInfo })} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_identify\",\n    value: function _identify(callback) {\n      var _this7 = this;\n\n      if (!this.muxer) {\n        return nextTick(callback, errCode('The connection was already closed', 'ERR_CONNECTION_CLOSED'));\n      }\n\n      this.muxer.newStream( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(err, conn) {\n          var ms, results, msConn;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (!err) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\", callback(err));\n\n                case 2:\n                  ms = new multistream.Dialer();\n                  _context.prev = 3;\n                  _context.next = 6;\n                  return msHandle(ms, conn);\n\n                case 6:\n                  _context.next = 8;\n                  return msSelect(ms, identify.multicodec);\n\n                case 8:\n                  msConn = _context.sent;\n                  _context.next = 11;\n                  return identifyDialer(msConn, _this7.theirPeerInfo);\n\n                case 11:\n                  results = _context.sent;\n                  _context.next = 17;\n                  break;\n\n                case 14:\n                  _context.prev = 14;\n                  _context.t0 = _context[\"catch\"](3);\n                  return _context.abrupt(\"return\", callback(_context.t0));\n\n                case 17:\n                  callback(null, results);\n\n                case 18:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[3, 14]]);\n        }));\n\n        return function (_x, _x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    }\n    /**\n     * Analyses the given error, if it exists, to determine where the state machine\n     * needs to go.\n     *\n     * @param {Error} err\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_didUpgrade\",\n    value: function _didUpgrade(err) {\n      if (err) {\n        this.log('Error upgrading connection:', err);\n        this.switch.conns[this.theirB58Id] = this;\n        this.emit('error:upgrade_failed', err); // Cant upgrade, hold the encrypted connection\n\n        return this._state('stop');\n      } // move the state machine forward\n\n\n      this._state('done');\n    }\n    /**\n     * Performs the protocol handshake for the given protocol\n     * over the given connection. The resulting error or connection\n     * will be returned via the callback.\n     *\n     * @private\n     * @param {string} protocol\n     * @param {Connection} connection\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_protocolHandshake\",\n    value: function _protocolHandshake(protocol, connection, callback) {\n      var _this8 = this;\n\n      var msDialer = new multistream.Dialer();\n      msDialer.handle(connection, function (err) {\n        if (err) {\n          return callback(err, null);\n        }\n\n        msDialer.select(protocol, function (err, _conn) {\n          if (err) {\n            _this8.log('could not perform protocol handshake:', err);\n\n            return callback(err, null);\n          }\n\n          var conn = observeConnection(null, protocol, _conn, _this8.switch.observer);\n\n          _this8.log('successfully performed handshake of %s to %s', protocol, _this8.theirB58Id);\n\n          _this8.emit('connection', conn);\n\n          callback(null, conn);\n        });\n      });\n    }\n    /**\n     * Event handler for state transition errors\n     *\n     * @param {Error} err\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onStateError\",\n    value: function _onStateError(err) {\n      this.emit('error', INVALID_STATE_TRANSITION(err));\n      this.log(err);\n    }\n  }]);\n\n  return ConnectionFSM;\n}(BaseConnection);\n\nmodule.exports = withIs(ConnectionFSM, {\n  className: 'ConnectionFSM',\n  symbolName: 'libp2p-switch/ConnectionFSM'\n});","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/libp2p-switch/src/connection/index.js"],"names":["FSM","require","Circuit","multistream","withIs","BaseConnection","parallel","nextTick","identify","errCode","msHandle","msSelect","identifyDialer","observeConnection","CONNECTION_FAILED","DIAL_SELF","INVALID_STATE_TRANSITION","NO_TRANSPORTS_REGISTERED","maybeUnexpectedEnd","ConnectionFSM","_switch","peerInfo","muxer","conn","type","name","_peerInfo","id","toB58String","slice","theirPeerInfo","theirB58Id","startState","_state","DISCONNECTED","dial","disconnect","done","DIALING","abort","error","DIALED","encrypt","privatize","PRIVATIZING","PRIVATIZED","ENCRYPTING","ENCRYPTED","upgrade","UPGRADING","stop","MUXED","CONNECTED","DISCONNECTING","ABORTED","ERRORED","on","_onDisconnected","_onDialing","_onDialed","_onPrivatizing","_onPrivatized","_onEncrypting","log","emit","_onUpgrading","switch","conns","_onDisconnecting","_onAborted","_onErrored","err","_onStateError","ourPeerInfo","getState","protocol","callback","newStream","stream","_protocolHandshake","hasTransports","close","tKeys","availableTransports","circuitEnabled","Boolean","transports","tag","includes","push","nextTransport","key","transport","multiaddrs","add","errors","_conn","shift","observer","tasks","cb","end","source","_","msDialer","Dialer","handle","crypto","select","observedConn","encryptedConn","setPeerInfo","muxers","Object","keys","length","_didUpgrade","nextMuxer","dialer","once","protocolMuxer","_identify","results","_peerBook","put","ms","multicodec","msConn","connection","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst FSM = require('fsm-event')\nconst Circuit = require('libp2p-circuit')\nconst multistream = require('multistream-select')\nconst withIs = require('class-is')\nconst BaseConnection = require('./base')\nconst parallel = require('async/parallel')\nconst nextTick = require('async/nextTick')\nconst identify = require('libp2p-identify')\nconst errCode = require('err-code')\nconst { msHandle, msSelect, identifyDialer } = require('../utils')\n\nconst observeConnection = require('../observe-connection')\nconst {\n  CONNECTION_FAILED,\n  DIAL_SELF,\n  INVALID_STATE_TRANSITION,\n  NO_TRANSPORTS_REGISTERED,\n  maybeUnexpectedEnd\n} = require('../errors')\n\n/**\n * @typedef {Object} ConnectionOptions\n * @property {Switch} _switch Our switch instance\n * @property {PeerInfo} peerInfo The PeerInfo of the peer to dial\n * @property {Muxer} muxer Optional - A muxed connection\n * @property {Connection} conn Optional - The base connection\n * @property {string} type Optional - identify the connection as incoming or outgoing. Defaults to out.\n */\n\n/**\n * ConnectionFSM handles the complex logic of managing a connection\n * between peers. ConnectionFSM is internally composed of a state machine\n * to help improve the usability and debuggability of connections. The\n * state machine also helps to improve the ability to handle dial backoff,\n * coalescing dials and dial locks.\n */\nclass ConnectionFSM extends BaseConnection {\n  /**\n   * @param {ConnectionOptions} connectionOptions\n   * @constructor\n   */\n  constructor ({ _switch, peerInfo, muxer, conn, type = 'out' }) {\n    super({\n      _switch,\n      name: `${type}:${_switch._peerInfo.id.toB58String().slice(0, 8)}`\n    })\n\n    this.theirPeerInfo = peerInfo\n    this.theirB58Id = this.theirPeerInfo.id.toB58String()\n\n    this.conn = conn // The base connection\n    this.muxer = muxer // The upgraded/muxed connection\n\n    let startState = 'DISCONNECTED'\n    if (this.muxer) {\n      startState = 'MUXED'\n    }\n\n    this._state = FSM(startState, {\n      DISCONNECTED: { // No active connections exist for the peer\n        dial: 'DIALING',\n        disconnect: 'DISCONNECTED',\n        done: 'DISCONNECTED'\n      },\n      DIALING: { // Creating an initial connection\n        abort: 'ABORTED',\n        // emit events for different transport dials?\n        done: 'DIALED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      DIALED: { // Base connection to peer established\n        encrypt: 'ENCRYPTING',\n        privatize: 'PRIVATIZING'\n      },\n      PRIVATIZING: { // Protecting the base connection\n        done: 'PRIVATIZED',\n        abort: 'ABORTED',\n        disconnect: 'DISCONNECTING'\n      },\n      PRIVATIZED: { // Base connection is protected\n        encrypt: 'ENCRYPTING'\n      },\n      ENCRYPTING: { // Encrypting the base connection\n        done: 'ENCRYPTED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      ENCRYPTED: { // Upgrading could not happen, the connection is encrypted and waiting\n        upgrade: 'UPGRADING',\n        disconnect: 'DISCONNECTING'\n      },\n      UPGRADING: { // Attempting to upgrade the connection with muxers\n        stop: 'CONNECTED', // If we cannot mux, stop upgrading\n        done: 'MUXED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      MUXED: {\n        disconnect: 'DISCONNECTING'\n      },\n      CONNECTED: { // A non muxed connection is established\n        disconnect: 'DISCONNECTING'\n      },\n      DISCONNECTING: { // Shutting down the connection\n        done: 'DISCONNECTED',\n        disconnect: 'DISCONNECTING'\n      },\n      ABORTED: { }, // A severe event occurred\n      ERRORED: { // An error occurred, but future dials may be allowed\n        disconnect: 'DISCONNECTING' // There could be multiple options here, but this is a likely action\n      }\n    })\n\n    this._state.on('DISCONNECTED', () => this._onDisconnected())\n    this._state.on('DIALING', () => this._onDialing())\n    this._state.on('DIALED', () => this._onDialed())\n    this._state.on('PRIVATIZING', () => this._onPrivatizing())\n    this._state.on('PRIVATIZED', () => this._onPrivatized())\n    this._state.on('ENCRYPTING', () => this._onEncrypting())\n    this._state.on('ENCRYPTED', () => {\n      this.log('successfully encrypted connection to %s', this.theirB58Id)\n      this.emit('encrypted', this.conn)\n    })\n    this._state.on('UPGRADING', () => this._onUpgrading())\n    this._state.on('MUXED', () => {\n      this.log('successfully muxed connection to %s', this.theirB58Id)\n      delete this.switch.conns[this.theirB58Id]\n      this.emit('muxed', this.muxer)\n    })\n    this._state.on('CONNECTED', () => {\n      this.log('unmuxed connection opened to %s', this.theirB58Id)\n      this.emit('unmuxed', this.conn)\n    })\n    this._state.on('DISCONNECTING', () => this._onDisconnecting())\n    this._state.on('ABORTED', () => this._onAborted())\n    this._state.on('ERRORED', () => this._onErrored())\n    this._state.on('error', (err) => this._onStateError(err))\n  }\n\n  /**\n   * Puts the state into dialing mode\n   *\n   * @fires ConnectionFSM#Error May emit a DIAL_SELF error\n   * @returns {void}\n   */\n  dial () {\n    if (this.theirB58Id === this.ourPeerInfo.id.toB58String()) {\n      return this.emit('error', DIAL_SELF())\n    } else if (this.getState() === 'DIALING') {\n      return this.log('attempted to dial while already dialing, ignoring')\n    }\n\n    this._state('dial')\n  }\n\n  /**\n   * Initiates a handshake for the given protocol\n   *\n   * @param {string} protocol The protocol to negotiate\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  shake (protocol, callback) {\n    // If there is no protocol set yet, don't perform the handshake\n    if (!protocol) {\n      return callback(null, null)\n    }\n\n    if (this.muxer && this.muxer.newStream) {\n      return this.muxer.newStream((err, stream) => {\n        if (err) {\n          return callback(err, null)\n        }\n\n        this.log('created new stream to %s', this.theirB58Id)\n        this._protocolHandshake(protocol, stream, callback)\n      })\n    }\n\n    this._protocolHandshake(protocol, this.conn, callback)\n  }\n\n  /**\n   * Puts the state into muxing mode\n   *\n   * @returns {void}\n   */\n  upgrade () {\n    this._state('upgrade')\n  }\n\n  /**\n   * Event handler for dialing. Transitions state when successful.\n   *\n   * @private\n   * @fires ConnectionFSM#error\n   * @returns {void}\n   */\n  _onDialing () {\n    this.log('dialing %s', this.theirB58Id)\n\n    if (!this.switch.hasTransports()) {\n      return this.close(NO_TRANSPORTS_REGISTERED())\n    }\n\n    const tKeys = this.switch.availableTransports(this.theirPeerInfo)\n\n    const circuitEnabled = Boolean(this.switch.transports[Circuit.tag])\n\n    if (circuitEnabled && !tKeys.includes(Circuit.tag)) {\n      tKeys.push(Circuit.tag)\n    }\n\n    const nextTransport = (key) => {\n      let transport = key\n      if (!transport) {\n        if (!circuitEnabled) {\n          return this.close(\n            CONNECTION_FAILED(`Circuit not enabled and all transports failed to dial peer ${this.theirB58Id}!`)\n          )\n        }\n\n        return this.close(\n          CONNECTION_FAILED(`No available transports to dial peer ${this.theirB58Id}!`)\n        )\n      }\n\n      if (transport === Circuit.tag) {\n        this.theirPeerInfo.multiaddrs.add(`/p2p-circuit/p2p/${this.theirB58Id}`)\n      }\n\n      this.log('dialing transport %s', transport)\n      this.switch.transport.dial(transport, this.theirPeerInfo, (errors, _conn) => {\n        if (errors) {\n          this.emit('error:connection_attempt_failed', errors)\n          this.log(errors)\n          return nextTransport(tKeys.shift())\n        }\n\n        this.conn = observeConnection(transport, null, _conn, this.switch.observer)\n        this._state('done')\n      })\n    }\n\n    nextTransport(tKeys.shift())\n  }\n\n  /**\n   * Once a connection has been successfully dialed, the connection\n   * will be privatized or encrypted depending on the presence of the\n   * Switch.protector.\n   *\n   * @returns {void}\n   */\n  _onDialed () {\n    this.log('successfully dialed %s', this.theirB58Id)\n\n    this.emit('connected', this.conn)\n  }\n\n  /**\n   * Event handler for disconnecting. Handles any needed cleanup\n   *\n   * @returns {void}\n   */\n  _onDisconnecting () {\n    this.log('disconnecting from %s', this.theirB58Id, Boolean(this.muxer))\n\n    delete this.switch.conns[this.theirB58Id]\n\n    let tasks = []\n\n    // Clean up stored connections\n    if (this.muxer) {\n      tasks.push((cb) => {\n        this.muxer.end(() => {\n          delete this.muxer\n          cb()\n        })\n      })\n    }\n\n    // If we have the base connection, abort it\n    // Ignore abort errors, since we're closing\n    if (this.conn) {\n      try {\n        this.conn.source.abort()\n      } catch (_) { }\n      delete this.conn\n    }\n\n    parallel(tasks, () => {\n      this._state('done')\n    })\n  }\n\n  /**\n   * Attempts to encrypt `this.conn` with the Switch's crypto.\n   *\n   * @private\n   * @fires ConnectionFSM#error\n   * @returns {void}\n   */\n  _onEncrypting () {\n    const msDialer = new multistream.Dialer()\n    msDialer.handle(this.conn, (err) => {\n      if (err) {\n        return this.close(maybeUnexpectedEnd(err))\n      }\n\n      this.log('selecting crypto %s to %s', this.switch.crypto.tag, this.theirB58Id)\n\n      msDialer.select(this.switch.crypto.tag, (err, _conn) => {\n        if (err) {\n          return this.close(maybeUnexpectedEnd(err))\n        }\n\n        const observedConn = observeConnection(null, this.switch.crypto.tag, _conn, this.switch.observer)\n        const encryptedConn = this.switch.crypto.encrypt(this.ourPeerInfo.id, observedConn, this.theirPeerInfo.id, (err) => {\n          if (err) {\n            return this.close(err)\n          }\n\n          this.conn = encryptedConn\n          this.conn.setPeerInfo(this.theirPeerInfo)\n          this._state('done')\n        })\n      })\n    })\n  }\n\n  /**\n   * Iterates over each Muxer on the Switch and attempts to upgrade\n   * the given `connection`. Successful muxed connections will be stored\n   * on the Switch.muxedConns with `b58Id` as their key for future reference.\n   *\n   * @private\n   * @returns {void}\n   */\n  _onUpgrading () {\n    const muxers = Object.keys(this.switch.muxers)\n    this.log('upgrading connection to %s', this.theirB58Id)\n\n    if (muxers.length === 0) {\n      return this._state('stop')\n    }\n\n    const msDialer = new multistream.Dialer()\n    msDialer.handle(this.conn, (err) => {\n      if (err) {\n        return this._didUpgrade(err)\n      }\n\n      // 1. try to handshake in one of the muxers available\n      // 2. if succeeds\n      //  - add the muxedConn to the list of muxedConns\n      //  - add incomming new streams to connHandler\n      const nextMuxer = (key) => {\n        this.log('selecting %s', key)\n        msDialer.select(key, (err, _conn) => {\n          if (err) {\n            if (muxers.length === 0) {\n              return this._didUpgrade(err)\n            }\n\n            return nextMuxer(muxers.shift())\n          }\n\n          // observe muxed connections\n          const conn = observeConnection(null, key, _conn, this.switch.observer)\n\n          this.muxer = this.switch.muxers[key].dialer(conn)\n\n          this.muxer.once('close', () => {\n            this.close()\n          })\n\n          // For incoming streams, in case identify is on\n          this.muxer.on('stream', (conn) => {\n            this.log('new stream created via muxer to %s', this.theirB58Id)\n            conn.setPeerInfo(this.theirPeerInfo)\n            this.switch.protocolMuxer(null)(conn)\n          })\n\n          this._didUpgrade(null)\n\n          // Run identify on the connection\n          if (this.switch.identify) {\n            this._identify((err, results) => {\n              if (err) {\n                return this.close(err)\n              }\n              this.theirPeerInfo = this.switch._peerBook.put(results.peerInfo)\n            })\n          }\n        })\n      }\n\n      nextMuxer(muxers.shift())\n    })\n  }\n\n  /**\n   * Runs the identify protocol on the connection\n   * @private\n   * @param {function(error, { PeerInfo })} callback\n   * @returns {void}\n   */\n  _identify (callback) {\n    if (!this.muxer) {\n      return nextTick(callback, errCode('The connection was already closed', 'ERR_CONNECTION_CLOSED'))\n    }\n    this.muxer.newStream(async (err, conn) => {\n      if (err) return callback(err)\n      const ms = new multistream.Dialer()\n      let results\n      try {\n        await msHandle(ms, conn)\n        const msConn = await msSelect(ms, identify.multicodec)\n        results = await identifyDialer(msConn, this.theirPeerInfo)\n      } catch (err) {\n        return callback(err)\n      }\n      callback(null, results)\n    })\n  }\n\n  /**\n   * Analyses the given error, if it exists, to determine where the state machine\n   * needs to go.\n   *\n   * @param {Error} err\n   * @returns {void}\n   */\n  _didUpgrade (err) {\n    if (err) {\n      this.log('Error upgrading connection:', err)\n      this.switch.conns[this.theirB58Id] = this\n      this.emit('error:upgrade_failed', err)\n      // Cant upgrade, hold the encrypted connection\n      return this._state('stop')\n    }\n\n    // move the state machine forward\n    this._state('done')\n  }\n\n  /**\n   * Performs the protocol handshake for the given protocol\n   * over the given connection. The resulting error or connection\n   * will be returned via the callback.\n   *\n   * @private\n   * @param {string} protocol\n   * @param {Connection} connection\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  _protocolHandshake (protocol, connection, callback) {\n    const msDialer = new multistream.Dialer()\n    msDialer.handle(connection, (err) => {\n      if (err) {\n        return callback(err, null)\n      }\n\n      msDialer.select(protocol, (err, _conn) => {\n        if (err) {\n          this.log('could not perform protocol handshake:', err)\n          return callback(err, null)\n        }\n\n        const conn = observeConnection(null, protocol, _conn, this.switch.observer)\n        this.log('successfully performed handshake of %s to %s', protocol, this.theirB58Id)\n        this.emit('connection', conn)\n        callback(null, conn)\n      })\n    })\n  }\n\n  /**\n   * Event handler for state transition errors\n   *\n   * @param {Error} err\n   * @returns {void}\n   */\n  _onStateError (err) {\n    this.emit('error', INVALID_STATE_TRANSITION(err))\n    this.log(err)\n  }\n}\n\nmodule.exports = withIs(ConnectionFSM, {\n  className: 'ConnectionFSM',\n  symbolName: 'libp2p-switch/ConnectionFSM'\n})\n"]},"metadata":{},"sourceType":"script"}