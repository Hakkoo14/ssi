{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('peer-id'),\n    createFromPrivKey = _require.createFromPrivKey;\n\nvar series = require('async/series');\n\nvar Receptacle = require('receptacle');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns');\nlog.error = debug('ipfs:ipns:error');\n\nvar IpnsPublisher = require('./publisher');\n\nvar IpnsRepublisher = require('./republisher');\n\nvar IpnsResolver = require('./resolver');\n\nvar path = require('./path');\n\nvar defaultRecordTtl = 60 * 1000;\n\nvar IPNS = /*#__PURE__*/function () {\n  function IPNS(routing, datastore, peerInfo, keychain, options) {\n    _classCallCheck(this, IPNS);\n\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerInfo, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new Receptacle({\n      max: 1000\n    }); // Create an LRU cache with max 1000 items\n\n    this.routing = routing;\n  } // Publish\n\n\n  _createClass(IPNS, [{\n    key: \"publish\",\n    value: function publish(privKey, value, lifetime, callback) {\n      var _this = this;\n\n      series([function (cb) {\n        return createFromPrivKey(privKey.bytes, cb);\n      }, function (cb) {\n        return _this.publisher.publishWithEOL(privKey, value, lifetime, cb);\n      }], function (err, results) {\n        if (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        log(\"IPNS value \".concat(value, \" was published correctly\")); // Add to cache\n\n        var id = results[0].toB58String();\n        var ttEol = parseFloat(lifetime);\n        var ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n\n        _this.cache.set(id, value, {\n          ttl: ttl\n        });\n\n        log(\"IPNS value \".concat(value, \" was cached correctly\"));\n        callback(null, {\n          name: id,\n          value: value\n        });\n      });\n    } // Resolve\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(name, options, callback) {\n      if (typeof name !== 'string') {\n        var errMsg = \"name received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_NAME'));\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {}; // If recursive, we should not try to get the cached value\n\n      if (!options.nocache && !options.recursive) {\n        // Try to get the record from cache\n        var id = name.split('/')[2];\n        var result = this.cache.get(id);\n\n        if (result) {\n          return callback(null, {\n            path: result\n          });\n        }\n      }\n\n      this.resolver.resolve(name, options, function (err, result) {\n        if (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        log(\"IPNS record from \".concat(name, \" was resolved correctly\"));\n        callback(null, {\n          path: result\n        });\n      });\n    } // Initialize keyspace\n    // sets the ipns record for the given key to point to an empty directory\n\n  }, {\n    key: \"initializeKeyspace\",\n    value: function initializeKeyspace(privKey, value, callback) {\n      this.publisher.publish(privKey, value, callback);\n    }\n  }]);\n\n  return IPNS;\n}();\n\nexports = module.exports = IPNS;\nexports.path = path;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs/src/core/ipns/index.js"],"names":["require","createFromPrivKey","series","Receptacle","errcode","debug","log","error","IpnsPublisher","IpnsRepublisher","IpnsResolver","path","defaultRecordTtl","IPNS","routing","datastore","peerInfo","keychain","options","publisher","republisher","resolver","cache","max","privKey","value","lifetime","callback","cb","bytes","publishWithEOL","err","results","id","toB58String","ttEol","parseFloat","ttl","set","name","errMsg","Error","nocache","recursive","split","result","get","resolve","publish","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { createFromPrivKey } = require('peer-id')\nconst series = require('async/series')\nconst Receptacle = require('receptacle')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:ipns')\nlog.error = debug('ipfs:ipns:error')\n\nconst IpnsPublisher = require('./publisher')\nconst IpnsRepublisher = require('./republisher')\nconst IpnsResolver = require('./resolver')\nconst path = require('./path')\n\nconst defaultRecordTtl = 60 * 1000\n\nclass IPNS {\n  constructor (routing, datastore, peerInfo, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore)\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerInfo, keychain, options)\n    this.resolver = new IpnsResolver(routing)\n    this.cache = new Receptacle({ max: 1000 }) // Create an LRU cache with max 1000 items\n    this.routing = routing\n  }\n\n  // Publish\n  publish (privKey, value, lifetime, callback) {\n    series([\n      (cb) => createFromPrivKey(privKey.bytes, cb),\n      (cb) => this.publisher.publishWithEOL(privKey, value, lifetime, cb)\n    ], (err, results) => {\n      if (err) {\n        log.error(err)\n        return callback(err)\n      }\n\n      log(`IPNS value ${value} was published correctly`)\n\n      // Add to cache\n      const id = results[0].toB58String()\n      const ttEol = parseFloat(lifetime)\n      const ttl = (ttEol < defaultRecordTtl) ? ttEol : defaultRecordTtl\n\n      this.cache.set(id, value, { ttl: ttl })\n\n      log(`IPNS value ${value} was cached correctly`)\n\n      callback(null, {\n        name: id,\n        value: value\n      })\n    })\n  }\n\n  // Resolve\n  resolve (name, options, callback) {\n    if (typeof name !== 'string') {\n      const errMsg = `name received is not valid`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_NAME'))\n    }\n\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    options = options || {}\n\n    // If recursive, we should not try to get the cached value\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2]\n      const result = this.cache.get(id)\n\n      if (result) {\n        return callback(null, {\n          path: result\n        })\n      }\n    }\n\n    this.resolver.resolve(name, options, (err, result) => {\n      if (err) {\n        log.error(err)\n        return callback(err)\n      }\n\n      log(`IPNS record from ${name} was resolved correctly`)\n\n      callback(null, {\n        path: result\n      })\n    })\n  }\n\n  // Initialize keyspace\n  // sets the ipns record for the given key to point to an empty directory\n  initializeKeyspace (privKey, value, callback) {\n    this.publisher.publish(privKey, value, callback)\n  }\n}\n\nexports = module.exports = IPNS\nexports.path = path\n"]},"metadata":{},"sourceType":"script"}