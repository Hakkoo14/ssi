{"ast":null,"code":"'use strict';\n\nvar CID = require('cids');\n\nvar parallel = require('async/parallel');\n\nvar PeerInfo = require('peer-info');\n\nvar promiseToCallback = require('promise-to-callback');\n\nvar errcode = require('err-code');\n\nvar Message = require('../../message');\n\nvar utils = require('../../utils');\n\nmodule.exports = function (dht) {\n  var log = utils.logger(dht.peerInfo.id, 'rpc:get-providers');\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {undefined}\n   */\n\n  return function getProviders(peer, msg, callback) {\n    var cid;\n\n    try {\n      cid = new CID(msg.key);\n    } catch (err) {\n      return callback(errcode(new Error(\"Invalid CID: \".concat(err.message)), 'ERR_INVALID_CID'));\n    }\n\n    log('%s', cid.toBaseEncodedString());\n    var dsKey = utils.bufferToKey(cid.buffer);\n    parallel([function (cb) {\n      return dht.datastore.has(dsKey, function (err, exists) {\n        if (err) {\n          log.error('Failed to check datastore existence', err);\n          return cb(null, false);\n        }\n\n        cb(null, exists);\n      });\n    }, function (cb) {\n      return promiseToCallback(dht.providers.getProviders(cid))(cb);\n    }, function (cb) {\n      return dht._betterPeersToQuery(msg, peer, cb);\n    }], function (err, res) {\n      if (err) {\n        return callback(err);\n      }\n\n      var has = res[0];\n      var closer = res[2];\n      var providers = res[1].map(function (p) {\n        if (dht.peerBook.has(p)) {\n          return dht.peerBook.get(p);\n        }\n\n        return dht.peerBook.put(new PeerInfo(p));\n      });\n\n      if (has) {\n        providers.push(dht.peerInfo);\n      }\n\n      var response = new Message(msg.type, msg.key, msg.clusterLevel);\n\n      if (providers.length > 0) {\n        response.providerPeers = providers;\n      }\n\n      if (closer.length > 0) {\n        response.closerPeers = closer;\n      }\n\n      log('got %s providers %s closerPeers', providers.length, closer.length);\n      callback(null, response);\n    });\n  };\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js"],"names":["CID","require","parallel","PeerInfo","promiseToCallback","errcode","Message","utils","module","exports","dht","log","logger","peerInfo","id","getProviders","peer","msg","callback","cid","key","err","Error","message","toBaseEncodedString","dsKey","bufferToKey","buffer","cb","datastore","has","exists","error","providers","_betterPeersToQuery","res","closer","map","p","peerBook","get","put","push","response","type","clusterLevel","length","providerPeers","closerPeers"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst parallel = require('async/parallel')\nconst PeerInfo = require('peer-info')\nconst promiseToCallback = require('promise-to-callback')\nconst errcode = require('err-code')\n\nconst Message = require('../../message')\nconst utils = require('../../utils')\n\nmodule.exports = (dht) => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc:get-providers')\n\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {undefined}\n   */\n  return function getProviders (peer, msg, callback) {\n    let cid\n    try {\n      cid = new CID(msg.key)\n    } catch (err) {\n      return callback(errcode(new Error(`Invalid CID: ${err.message}`), 'ERR_INVALID_CID'))\n    }\n\n    log('%s', cid.toBaseEncodedString())\n\n    const dsKey = utils.bufferToKey(cid.buffer)\n\n    parallel([\n      (cb) => dht.datastore.has(dsKey, (err, exists) => {\n        if (err) {\n          log.error('Failed to check datastore existence', err)\n          return cb(null, false)\n        }\n\n        cb(null, exists)\n      }),\n      (cb) => promiseToCallback(dht.providers.getProviders(cid))(cb),\n      (cb) => dht._betterPeersToQuery(msg, peer, cb)\n    ], (err, res) => {\n      if (err) {\n        return callback(err)\n      }\n      const has = res[0]\n      const closer = res[2]\n      const providers = res[1].map((p) => {\n        if (dht.peerBook.has(p)) {\n          return dht.peerBook.get(p)\n        }\n\n        return dht.peerBook.put(new PeerInfo(p))\n      })\n\n      if (has) {\n        providers.push(dht.peerInfo)\n      }\n\n      const response = new Message(msg.type, msg.key, msg.clusterLevel)\n\n      if (providers.length > 0) {\n        response.providerPeers = providers\n      }\n\n      if (closer.length > 0) {\n        response.closerPeers = closer\n      }\n\n      log('got %s providers %s closerPeers', providers.length, closer.length)\n\n      callback(null, response)\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}