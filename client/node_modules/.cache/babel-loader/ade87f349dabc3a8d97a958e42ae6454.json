{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _awaitAsyncGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar _require = require('./utils/constants'),\n    FILE_SEPARATOR = _require.FILE_SEPARATOR,\n    FILE_TYPES = _require.FILE_TYPES;\n\nvar defaultOptions = {};\n\nvar toOutput = function toOutput(fsEntry) {\n  var type = 0;\n  var size = fsEntry.node.size || fsEntry.node.length;\n\n  if (fsEntry.unixfs) {\n    size = fsEntry.unixfs.fileSize();\n    type = FILE_TYPES[fsEntry.unixfs.type];\n  }\n\n  return {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type: type,\n    size: size\n  };\n};\n\nmodule.exports = function (context) {\n  return /*#__PURE__*/function () {\n    var _mfsLs = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var path,\n          options,\n          mfsPath,\n          fsDir,\n          _iteratorNormalCompletion,\n          _didIteratorError,\n          _iteratorError,\n          _iterator,\n          _step,\n          _value,\n          fsEntry,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              path = _args.length > 0 && _args[0] !== undefined ? _args[0] : FILE_SEPARATOR;\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n              if (typeof path === 'object' && !(path instanceof String)) {\n                options = path;\n                path = FILE_SEPARATOR;\n              }\n\n              options = applyDefaultOptions(options, defaultOptions);\n              _context.next = 6;\n              return _awaitAsyncGenerator(toMfsPath(context, path));\n\n            case 6:\n              mfsPath = _context.sent;\n              _context.next = 9;\n              return _awaitAsyncGenerator(exporter(mfsPath.mfsPath, context.ipld));\n\n            case 9:\n              fsDir = _context.sent;\n\n              if (!(!fsDir.unixfs || !fsDir.unixfs.type.includes('directory'))) {\n                _context.next = 14;\n                break;\n              }\n\n              _context.next = 13;\n              return toOutput(fsDir);\n\n            case 13:\n              return _context.abrupt(\"return\");\n\n            case 14:\n              // directory, perhaps sharded\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 16;\n              _iterator = _asyncIterator(fsDir.content(options));\n\n            case 18:\n              _context.next = 20;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 20:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 24;\n              return _awaitAsyncGenerator(_step.value);\n\n            case 24:\n              _value = _context.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context.next = 32;\n                break;\n              }\n\n              fsEntry = _value;\n              _context.next = 29;\n              return toOutput(fsEntry);\n\n            case 29:\n              _iteratorNormalCompletion = true;\n              _context.next = 18;\n              break;\n\n            case 32:\n              _context.next = 38;\n              break;\n\n            case 34:\n              _context.prev = 34;\n              _context.t0 = _context[\"catch\"](16);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 38:\n              _context.prev = 38;\n              _context.prev = 39;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context.next = 43;\n                break;\n              }\n\n              _context.next = 43;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 43:\n              _context.prev = 43;\n\n              if (!_didIteratorError) {\n                _context.next = 46;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 46:\n              return _context.finish(43);\n\n            case 47:\n              return _context.finish(38);\n\n            case 48:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[16, 34, 38, 48], [39,, 43, 47]]);\n    }));\n\n    function mfsLs() {\n      return _mfsLs.apply(this, arguments);\n    }\n\n    return mfsLs;\n  }();\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs-mfs/src/core/ls.js"],"names":["exporter","require","applyDefaultOptions","toMfsPath","FILE_SEPARATOR","FILE_TYPES","defaultOptions","toOutput","fsEntry","type","size","node","length","unixfs","fileSize","cid","name","module","exports","context","path","options","String","mfsPath","ipld","fsDir","includes","content","mfsLs"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,sBAAD,CAAxB;;AACA,IAAMC,mBAAmB,GAAGD,OAAO,CAAC,+BAAD,CAAnC;;AACA,IAAME,SAAS,GAAGF,OAAO,CAAC,qBAAD,CAAzB;;AACA,eAGIA,OAAO,CAAC,mBAAD,CAHX;AAAA,IACEG,cADF,YACEA,cADF;AAAA,IAEEC,UAFF,YAEEA,UAFF;;AAKA,IAAMC,cAAc,GAAG,EAAvB;;AAIA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACC,OAAD,EAAa;AAC5B,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,IAAI,GAAGF,OAAO,CAACG,IAAR,CAAaD,IAAb,IAAqBF,OAAO,CAACG,IAAR,CAAaC,MAA7C;;AAEA,MAAIJ,OAAO,CAACK,MAAZ,EAAoB;AAClBH,IAAAA,IAAI,GAAGF,OAAO,CAACK,MAAR,CAAeC,QAAf,EAAP;AACAL,IAAAA,IAAI,GAAGJ,UAAU,CAACG,OAAO,CAACK,MAAR,CAAeJ,IAAhB,CAAjB;AACD;;AAED,SAAO;AACLM,IAAAA,GAAG,EAAEP,OAAO,CAACO,GADR;AAELC,IAAAA,IAAI,EAAER,OAAO,CAACQ,IAFT;AAGLP,IAAAA,IAAI,EAAJA,IAHK;AAILC,IAAAA,IAAI,EAAJA;AAJK,GAAP;AAMD,CAfD;;AAiBAO,MAAM,CAACC,OAAP,GAAiB,UAACC,OAAD,EAAa;AAC5B;AAAA,4EAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAwBC,cAAAA,IAAxB,2DAA+BhB,cAA/B;AAA+CiB,cAAAA,OAA/C,2DAAyD,EAAzD;;AACL,kBAAI,OAAOD,IAAP,KAAgB,QAAhB,IAA4B,EAAEA,IAAI,YAAYE,MAAlB,CAAhC,EAA2D;AACzDD,gBAAAA,OAAO,GAAGD,IAAV;AACAA,gBAAAA,IAAI,GAAGhB,cAAP;AACD;;AAEDiB,cAAAA,OAAO,GAAGnB,mBAAmB,CAACmB,OAAD,EAAUf,cAAV,CAA7B;AANK;AAAA,0CAQiBH,SAAS,CAACgB,OAAD,EAAUC,IAAV,CAR1B;;AAAA;AAQCG,cAAAA,OARD;AAAA;AAAA,0CASevB,QAAQ,CAACuB,OAAO,CAACA,OAAT,EAAkBJ,OAAO,CAACK,IAA1B,CATvB;;AAAA;AASCC,cAAAA,KATD;;AAAA,oBAYD,CAACA,KAAK,CAACZ,MAAP,IAAiB,CAACY,KAAK,CAACZ,MAAN,CAAaJ,IAAb,CAAkBiB,QAAlB,CAA2B,WAA3B,CAZjB;AAAA;AAAA;AAAA;;AAAA;AAaH,qBAAMnB,QAAQ,CAACkB,KAAD,CAAd;;AAbG;AAAA;;AAAA;AAkBL;AAlBK;AAAA;AAAA;AAAA,yCAmBuBA,KAAK,CAACE,OAAN,CAAcN,OAAd,CAnBvB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAmBYb,cAAAA,OAnBZ;AAAA;AAoBH,qBAAMD,QAAQ,CAACC,OAAD,CAAd;;AApBG;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAP;;AAAA,aAAwBoB,KAAxB;AAAA;AAAA;;AAAA,WAAwBA,KAAxB;AAAA;AAuBD,CAxBD","sourcesContent":["'use strict'\n\nconst exporter = require('ipfs-unixfs-exporter')\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst {\n  FILE_SEPARATOR,\n  FILE_TYPES\n} = require('./utils/constants')\n\nconst defaultOptions = {\n\n}\n\nconst toOutput = (fsEntry) => {\n  let type = 0\n  let size = fsEntry.node.size || fsEntry.node.length\n\n  if (fsEntry.unixfs) {\n    size = fsEntry.unixfs.fileSize()\n    type = FILE_TYPES[fsEntry.unixfs.type]\n  }\n\n  return {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type,\n    size\n  }\n}\n\nmodule.exports = (context) => {\n  return async function * mfsLs (path = FILE_SEPARATOR, options = {}) {\n    if (typeof path === 'object' && !(path instanceof String)) {\n      options = path\n      path = FILE_SEPARATOR\n    }\n\n    options = applyDefaultOptions(options, defaultOptions)\n\n    const mfsPath = await toMfsPath(context, path)\n    const fsDir = await exporter(mfsPath.mfsPath, context.ipld)\n\n    // single file/node\n    if (!fsDir.unixfs || !fsDir.unixfs.type.includes('directory')) {\n      yield toOutput(fsDir)\n\n      return\n    }\n\n    // directory, perhaps sharded\n    for await (const fsEntry of fsDir.content(options)) {\n      yield toOutput(fsEntry)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}