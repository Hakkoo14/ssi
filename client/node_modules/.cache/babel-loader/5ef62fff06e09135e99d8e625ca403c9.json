{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar errCode = require('err-code');\n\nvar UnixFS = require('ipfs-unixfs');\n\nvar findShardCid = require('../../utils/find-cid-in-shard');\n\nvar findLinkCid = function findLinkCid(node, name) {\n  var link = node.Links.find(function (link) {\n    return link.Name === name;\n  });\n  return link && link.Hash;\n};\n\nvar contentExporters = {\n  raw: require('./content/file'),\n  file: require('./content/file'),\n  directory: require('./content/directory'),\n  'hamt-sharded-directory': require('./content/hamt-sharded-directory'),\n  metadata: function metadata(cid, node, unixfs, path, resolve, depth, ipld) {},\n  symlink: function symlink(cid, node, unixfs, path, resolve, depth, ipld) {}\n};\n\nvar unixFsResolver = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cid, name, path, toResolve, resolve, depth, ipld) {\n    var node, unixfs, next, linkCid, nextName, nextPath;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return ipld.get(cid);\n\n          case 2:\n            node = _context.sent;\n\n            if (!name) {\n              name = cid.toBaseEncodedString();\n            }\n\n            _context.prev = 4;\n            unixfs = UnixFS.unmarshal(node.Data);\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](4);\n            throw errCode(_context.t0, 'ERR_NOT_UNIXFS');\n\n          case 11:\n            if (!path) {\n              path = name;\n            }\n\n            if (!toResolve.length) {\n              _context.next = 25;\n              break;\n            }\n\n            if (!(unixfs && unixfs.type === 'hamt-sharded-directory')) {\n              _context.next = 19;\n              break;\n            }\n\n            _context.next = 16;\n            return findShardCid(node, toResolve[0], ipld);\n\n          case 16:\n            linkCid = _context.sent;\n            _context.next = 20;\n            break;\n\n          case 19:\n            linkCid = findLinkCid(node, toResolve[0]);\n\n          case 20:\n            if (linkCid) {\n              _context.next = 22;\n              break;\n            }\n\n            throw errCode(new Error(\"file does not exist\"), 'ERR_NOT_FOUND');\n\n          case 22:\n            // remove the path component we have resolved\n            nextName = toResolve.shift();\n            nextPath = \"\".concat(path, \"/\").concat(nextName);\n            next = {\n              cid: linkCid,\n              toResolve: toResolve,\n              name: nextName,\n              path: nextPath\n            };\n\n          case 25:\n            return _context.abrupt(\"return\", {\n              entry: {\n                name: name,\n                path: path,\n                cid: cid,\n                node: node,\n                content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, ipld),\n                unixfs: unixfs,\n                depth: depth\n              },\n              next: next\n            });\n\n          case 26:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 8]]);\n  }));\n\n  return function unixFsResolver(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = unixFsResolver;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js"],"names":["errCode","require","UnixFS","findShardCid","findLinkCid","node","name","link","Links","find","Name","Hash","contentExporters","raw","file","directory","metadata","cid","unixfs","path","resolve","depth","ipld","symlink","unixFsResolver","toResolve","get","toBaseEncodedString","unmarshal","Data","length","type","linkCid","Error","nextName","shift","nextPath","next","entry","content","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst UnixFS = require('ipfs-unixfs')\nconst findShardCid = require('../../utils/find-cid-in-shard')\n\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name)\n\n  return link && link.Hash\n}\n\nconst contentExporters = {\n  raw: require('./content/file'),\n  file: require('./content/file'),\n  directory: require('./content/directory'),\n  'hamt-sharded-directory': require('./content/hamt-sharded-directory'),\n  metadata: (cid, node, unixfs, path, resolve, depth, ipld) => {},\n  symlink: (cid, node, unixfs, path, resolve, depth, ipld) => {}\n}\n\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, ipld) => {\n  const node = await ipld.get(cid)\n  let unixfs\n  let next\n\n  if (!name) {\n    name = cid.toBaseEncodedString()\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data)\n  } catch (err) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw errCode(err, 'ERR_NOT_UNIXFS')\n  }\n\n  if (!path) {\n    path = name\n  }\n\n  if (toResolve.length) {\n    let linkCid\n\n    if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], ipld)\n    } else {\n      linkCid = findLinkCid(node, toResolve[0])\n    }\n\n    if (!linkCid) {\n      throw errCode(new Error(`file does not exist`), 'ERR_NOT_FOUND')\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift()\n    const nextPath = `${path}/${nextName}`\n\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName,\n      path: nextPath\n    }\n  }\n\n  return {\n    entry: {\n      name,\n      path,\n      cid,\n      node,\n      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, ipld),\n      unixfs,\n      depth\n    },\n    next\n  }\n}\n\nmodule.exports = unixFsResolver\n"]},"metadata":{},"sourceType":"script"}