{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar waterfall = require('async/waterfall');\n\nvar reject = require('async/reject');\n\nvar each = require('async/each');\n\nvar series = require('async/series');\n\nvar map = require('async/map');\n\nvar nextTick = require('async/nextTick');\n\nvar WantManager = require('./want-manager');\n\nvar Network = require('./network');\n\nvar DecisionEngine = require('./decision-engine');\n\nvar Notifications = require('./notifications');\n\nvar logger = require('./utils').logger;\n\nvar Stats = require('./stats');\n\nvar defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nvar statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n */\n\nvar Bitswap = /*#__PURE__*/function () {\n  function Bitswap(libp2p, blockstore, options) {\n    _classCallCheck(this, Bitswap);\n\n    this._libp2p = libp2p;\n    this._log = logger(this.peerInfo.id);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, {}, this._stats); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerInfo.id, blockstore, this.network, this._stats); // handle message sending\n\n    this.wm = new WantManager(this.peerInfo.id, this.network, this._stats);\n    this.notifications = new Notifications(this.peerInfo.id);\n  }\n\n  _createClass(Bitswap, [{\n    key: \"peerInfo\",\n    get: function get() {\n      return this._libp2p.peerInfo;\n    } // handle messages received through the network\n\n  }, {\n    key: \"_receiveMessage\",\n    value: function _receiveMessage(peerId, incoming, callback) {\n      var _this = this;\n\n      this.engine.messageReceived(peerId, incoming, function (err) {\n        if (err) {\n          // Only logging the issue to process as much as possible\n          // of the message. Currently `messageReceived` does not\n          // return any errors, but this could change in the future.\n          _this._log('failed to receive message', incoming);\n        }\n\n        if (incoming.blocks.size === 0) {\n          return callback();\n        }\n\n        var blocks = Array.from(incoming.blocks.values()); // quickly send out cancels, reduces chances of duplicate block receives\n\n        var wanted = blocks.filter(function (b) {\n          return _this.wm.wantlist.contains(b.cid);\n        }).map(function (b) {\n          return b.cid;\n        });\n\n        _this.wm.cancelWants(wanted);\n\n        each(blocks, function (b, cb) {\n          var wasWanted = wanted.includes(b.cid);\n\n          _this._handleReceivedBlock(peerId, b, wasWanted, cb);\n        }, callback);\n      });\n    }\n  }, {\n    key: \"_handleReceivedBlock\",\n    value: function _handleReceivedBlock(peerId, block, wasWanted, callback) {\n      var _this2 = this;\n\n      this._log('received block');\n\n      waterfall([function (cb) {\n        return _this2.blockstore.has(block.cid, cb);\n      }, function (has, cb) {\n        _this2._updateReceiveCounters(peerId.toB58String(), block, has);\n\n        if (has || !wasWanted) {\n          return nextTick(cb);\n        }\n\n        _this2._putBlock(block, cb);\n      }], callback);\n    }\n  }, {\n    key: \"_updateReceiveCounters\",\n    value: function _updateReceiveCounters(peerId, block, exists) {\n      this._stats.push(peerId, 'blocksReceived', 1);\n\n      this._stats.push(peerId, 'dataReceived', block.data.length);\n\n      if (exists) {\n        this._stats.push(peerId, 'dupBlksReceived', 1);\n\n        this._stats.push(peerId, 'dupDataReceived', block.data.length);\n      }\n    } // handle errors on the receiving channel\n\n  }, {\n    key: \"_receiveError\",\n    value: function _receiveError(err) {\n      this._log.error('ReceiveError: %s', err.message);\n    } // handle new peers\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function _onPeerConnected(peerId) {\n      this.wm.connected(peerId);\n    } // handle peers being disconnected\n\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(peerId) {\n      this.wm.disconnected(peerId);\n      this.engine.peerDisconnected(peerId);\n\n      this._stats.disconnected(peerId);\n    }\n  }, {\n    key: \"_putBlock\",\n    value: function _putBlock(block, callback) {\n      var _this3 = this;\n\n      this.blockstore.put(block, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this3.notifications.hasBlock(block);\n\n        _this3.network.provide(block.cid, function (err) {\n          if (err) {\n            _this3._log.error('Failed to provide: %s', err.message);\n          }\n        });\n\n        _this3.engine.receivedBlocks([block.cid]);\n\n        callback();\n      });\n    }\n  }, {\n    key: \"enableStats\",\n    value: function enableStats() {\n      this._stats.enable();\n    }\n  }, {\n    key: \"disableStats\",\n    value: function disableStats() {\n      this._stats.disable();\n    }\n    /**\n     * Return the current wantlist for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     * @returns {Wantlist}\n     */\n\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId) {\n      return this.engine.wantlistForPeer(peerId);\n    }\n    /**\n     * Return ledger information for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     * @returns {?Object}\n     */\n\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      return this.engine.ledgerForPeer(peerId);\n    }\n    /**\n     * Fetch a given block by cid. If the block is in the local\n     * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n     *\n     * @param {CID} cid\n     * @param {function(Error, Block)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(cid, callback) {\n      this.getMany([cid], function (err, blocks) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (blocks && blocks.length > 0) {\n          callback(null, blocks[0]);\n        } else {\n          // when a unwant happens\n          callback();\n        }\n      });\n    }\n    /**\n     * Fetch a a list of blocks by cid. If the blocks are in the local\n     * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n     *\n     * @param {Array<CID>} cids\n     * @param {function(Error, Blocks)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids, callback) {\n      var _this4 = this;\n\n      var pendingStart = cids.length;\n      var wantList = [];\n      var promptedNetwork = false;\n\n      var getFromOutside = function getFromOutside(cid, cb) {\n        wantList.push(cid);\n\n        _this4.notifications.wantBlock(cid, // called on block receive\n        function (block) {\n          _this4.wm.cancelWants([cid]);\n\n          cb(null, block);\n        }, // called on unwant\n        function () {\n          _this4.wm.cancelWants([cid]);\n\n          cb(null, undefined);\n        });\n\n        if (!pendingStart) {\n          _this4.wm.wantBlocks(wantList);\n        }\n      };\n\n      map(cids, function (cid, cb) {\n        waterfall([function (cb) {\n          return _this4.blockstore.has(cid, cb);\n        }, function (has, cb) {\n          pendingStart--;\n\n          if (has) {\n            if (!pendingStart) {\n              _this4.wm.wantBlocks(wantList);\n            }\n\n            return _this4.blockstore.get(cid, cb);\n          }\n\n          if (!promptedNetwork) {\n            promptedNetwork = true;\n\n            _this4.network.findAndConnect(cids[0], function (err) {\n              if (err) {\n                _this4._log.error(err);\n              }\n            });\n          } // we don't have the block here\n\n\n          getFromOutside(cid, cb);\n        }], cb);\n      }, callback);\n    } // removes the given cids from the wantlist independent of any ref counts\n\n  }, {\n    key: \"unwant\",\n    value: function unwant(cids) {\n      var _this5 = this;\n\n      if (!Array.isArray(cids)) {\n        cids = [cids];\n      }\n\n      this.wm.unwantBlocks(cids);\n      cids.forEach(function (cid) {\n        return _this5.notifications.unwantBlock(cid);\n      });\n    } // removes the given keys from the want list\n\n  }, {\n    key: \"cancelWants\",\n    value: function cancelWants(cids) {\n      if (!Array.isArray(cids)) {\n        cids = [cids];\n      }\n\n      this.wm.cancelWants(cids);\n    }\n    /**\n     * Put the given block to the underlying blockstore and\n     * send it to nodes that have it in their wantlist.\n     *\n     * @param {Block} block\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(block, callback) {\n      var _this6 = this;\n\n      this._log('putting block');\n\n      waterfall([function (cb) {\n        return _this6.blockstore.has(block.cid, cb);\n      }, function (has, cb) {\n        if (has) {\n          return nextTick(cb);\n        }\n\n        _this6._putBlock(block, cb);\n      }], callback);\n    }\n    /**\n     * Put the given blocks to the underlying blockstore and\n     * send it to nodes that have it them their wantlist.\n     *\n     * @param {Array<Block>} blocks\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"putMany\",\n    value: function putMany(blocks, callback) {\n      var _this7 = this;\n\n      waterfall([function (cb) {\n        return reject(blocks, function (b, cb) {\n          _this7.blockstore.has(b.cid, cb);\n        }, cb);\n      }, function (newBlocks, cb) {\n        return _this7.blockstore.putMany(newBlocks, function (err) {\n          if (err) {\n            return cb(err);\n          }\n\n          newBlocks.forEach(function (block) {\n            _this7.notifications.hasBlock(block);\n\n            _this7.engine.receivedBlocks([block.cid]);\n\n            _this7.network.provide(block.cid, function (err) {\n              if (err) {\n                _this7._log.error('Failed to provide: %s', err.message);\n              }\n            });\n          });\n          cb();\n        });\n      }], callback);\n    }\n    /**\n     * Get the current list of wants.\n     *\n     * @returns {Iterator<WantlistEntry>}\n     */\n\n  }, {\n    key: \"getWantlist\",\n    value: function getWantlist() {\n      return this.wm.wantlist.entries();\n    }\n    /**\n     * Get the current list of partners.\n     *\n     * @returns {Array<PeerId>}\n     */\n\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return this.engine.peers();\n    }\n    /**\n     * Get stats about the bitswap node.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"stat\",\n    value: function stat() {\n      return this._stats;\n    }\n    /**\n     * Start the bitswap node.\n     *\n     * @param {function(Error)} callback\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      var _this8 = this;\n\n      series([function (cb) {\n        return _this8.wm.start(cb);\n      }, function (cb) {\n        return _this8.network.start(cb);\n      }, function (cb) {\n        return _this8.engine.start(cb);\n      }], callback);\n    }\n    /**\n     * Stop the bitswap node.\n     *\n     * @param {function(Error)} callback\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var _this9 = this;\n\n      this._stats.stop();\n\n      series([function (cb) {\n        return _this9.wm.stop(cb);\n      }, function (cb) {\n        return _this9.network.stop(cb);\n      }, function (cb) {\n        return _this9.engine.stop(cb);\n      }], callback);\n    }\n  }]);\n\n  return Bitswap;\n}();\n\nmodule.exports = Bitswap;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs-bitswap/src/index.js"],"names":["waterfall","require","reject","each","series","map","nextTick","WantManager","Network","DecisionEngine","Notifications","logger","Stats","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","libp2p","blockstore","options","_libp2p","_log","peerInfo","id","_options","Object","assign","_stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","network","engine","wm","notifications","peerId","incoming","callback","messageReceived","err","blocks","size","Array","from","values","wanted","filter","b","wantlist","contains","cid","cancelWants","cb","wasWanted","includes","_handleReceivedBlock","block","has","_updateReceiveCounters","toB58String","_putBlock","exists","push","data","length","error","message","connected","disconnected","peerDisconnected","put","hasBlock","provide","receivedBlocks","enable","disable","wantlistForPeer","ledgerForPeer","getMany","cids","pendingStart","wantList","promptedNetwork","getFromOutside","wantBlock","undefined","wantBlocks","get","findAndConnect","isArray","unwantBlocks","forEach","unwantBlock","newBlocks","putMany","entries","peers","start","stop","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst waterfall = require('async/waterfall')\nconst reject = require('async/reject')\nconst each = require('async/each')\nconst series = require('async/series')\nconst map = require('async/map')\nconst nextTick = require('async/nextTick')\n\nconst WantManager = require('./want-manager')\nconst Network = require('./network')\nconst DecisionEngine = require('./decision-engine')\nconst Notifications = require('./notifications')\nconst logger = require('./utils').logger\nconst Stats = require('./stats')\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n}\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n]\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n */\nclass Bitswap {\n  constructor (libp2p, blockstore, options) {\n    this._libp2p = libp2p\n    this._log = logger(this.peerInfo.id)\n\n    this._options = Object.assign({}, defaultOptions, options)\n\n    // stats\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    })\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, {}, this._stats)\n\n    // local database\n    this.blockstore = blockstore\n\n    this.engine = new DecisionEngine(this.peerInfo.id, blockstore, this.network, this._stats)\n\n    // handle message sending\n    this.wm = new WantManager(this.peerInfo.id, this.network, this._stats)\n\n    this.notifications = new Notifications(this.peerInfo.id)\n  }\n\n  get peerInfo () {\n    return this._libp2p.peerInfo\n  }\n\n  // handle messages received through the network\n  _receiveMessage (peerId, incoming, callback) {\n    this.engine.messageReceived(peerId, incoming, (err) => {\n      if (err) {\n        // Only logging the issue to process as much as possible\n        // of the message. Currently `messageReceived` does not\n        // return any errors, but this could change in the future.\n        this._log('failed to receive message', incoming)\n      }\n\n      if (incoming.blocks.size === 0) {\n        return callback()\n      }\n\n      const blocks = Array.from(incoming.blocks.values())\n\n      // quickly send out cancels, reduces chances of duplicate block receives\n      const wanted = blocks\n        .filter((b) => this.wm.wantlist.contains(b.cid))\n        .map((b) => b.cid)\n\n      this.wm.cancelWants(wanted)\n\n      each(\n        blocks,\n        (b, cb) => {\n          const wasWanted = wanted.includes(b.cid)\n          this._handleReceivedBlock(peerId, b, wasWanted, cb)\n        },\n        callback\n      )\n    })\n  }\n\n  _handleReceivedBlock (peerId, block, wasWanted, callback) {\n    this._log('received block')\n\n    waterfall([\n      (cb) => this.blockstore.has(block.cid, cb),\n      (has, cb) => {\n        this._updateReceiveCounters(peerId.toB58String(), block, has)\n        if (has || !wasWanted) {\n          return nextTick(cb)\n        }\n\n        this._putBlock(block, cb)\n      }\n    ], callback)\n  }\n\n  _updateReceiveCounters (peerId, block, exists) {\n    this._stats.push(peerId, 'blocksReceived', 1)\n    this._stats.push(peerId, 'dataReceived', block.data.length)\n\n    if (exists) {\n      this._stats.push(peerId, 'dupBlksReceived', 1)\n      this._stats.push(peerId, 'dupDataReceived', block.data.length)\n    }\n  }\n\n  // handle errors on the receiving channel\n  _receiveError (err) {\n    this._log.error('ReceiveError: %s', err.message)\n  }\n\n  // handle new peers\n  _onPeerConnected (peerId) {\n    this.wm.connected(peerId)\n  }\n\n  // handle peers being disconnected\n  _onPeerDisconnected (peerId) {\n    this.wm.disconnected(peerId)\n    this.engine.peerDisconnected(peerId)\n    this._stats.disconnected(peerId)\n  }\n\n  _putBlock (block, callback) {\n    this.blockstore.put(block, (err) => {\n      if (err) {\n        return callback(err)\n      }\n\n      this.notifications.hasBlock(block)\n      this.network.provide(block.cid, (err) => {\n        if (err) {\n          this._log.error('Failed to provide: %s', err.message)\n        }\n      })\n\n      this.engine.receivedBlocks([block.cid])\n      callback()\n    })\n  }\n\n  enableStats () {\n    this._stats.enable()\n  }\n\n  disableStats () {\n    this._stats.disable()\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Wantlist}\n   */\n  wantlistForPeer (peerId) {\n    return this.engine.wantlistForPeer(peerId)\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {?Object}\n   */\n  ledgerForPeer (peerId) {\n    return this.engine.ledgerForPeer(peerId)\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {function(Error, Block)} callback\n   * @returns {void}\n   */\n  get (cid, callback) {\n    this.getMany([cid], (err, blocks) => {\n      if (err) {\n        return callback(err)\n      }\n\n      if (blocks && blocks.length > 0) {\n        callback(null, blocks[0])\n      } else {\n        // when a unwant happens\n        callback()\n      }\n    })\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {Array<CID>} cids\n   * @param {function(Error, Blocks)} callback\n   * @returns {void}\n   */\n  getMany (cids, callback) {\n    let pendingStart = cids.length\n    const wantList = []\n    let promptedNetwork = false\n\n    const getFromOutside = (cid, cb) => {\n      wantList.push(cid)\n\n      this.notifications.wantBlock(\n        cid,\n        // called on block receive\n        (block) => {\n          this.wm.cancelWants([cid])\n          cb(null, block)\n        },\n        // called on unwant\n        () => {\n          this.wm.cancelWants([cid])\n          cb(null, undefined)\n        }\n      )\n\n      if (!pendingStart) {\n        this.wm.wantBlocks(wantList)\n      }\n    }\n\n    map(cids, (cid, cb) => {\n      waterfall(\n        [\n          (cb) => this.blockstore.has(cid, cb),\n          (has, cb) => {\n            pendingStart--\n            if (has) {\n              if (!pendingStart) {\n                this.wm.wantBlocks(wantList)\n              }\n              return this.blockstore.get(cid, cb)\n            }\n\n            if (!promptedNetwork) {\n              promptedNetwork = true\n              this.network.findAndConnect(cids[0], (err) => {\n                if (err) {\n                  this._log.error(err)\n                }\n              })\n            }\n\n            // we don't have the block here\n            getFromOutside(cid, cb)\n          }\n        ],\n        cb)\n    }, callback)\n  }\n\n  // removes the given cids from the wantlist independent of any ref counts\n  unwant (cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n\n    this.wm.unwantBlocks(cids)\n    cids.forEach((cid) => this.notifications.unwantBlock(cid))\n  }\n\n  // removes the given keys from the want list\n  cancelWants (cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n    this.wm.cancelWants(cids)\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {Block} block\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  put (block, callback) {\n    this._log('putting block')\n\n    waterfall([\n      (cb) => this.blockstore.has(block.cid, cb),\n      (has, cb) => {\n        if (has) {\n          return nextTick(cb)\n        }\n\n        this._putBlock(block, cb)\n      }\n    ], callback)\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Array<Block>} blocks\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  putMany (blocks, callback) {\n    waterfall([\n      (cb) => reject(blocks, (b, cb) => {\n        this.blockstore.has(b.cid, cb)\n      }, cb),\n      (newBlocks, cb) => this.blockstore.putMany(newBlocks, (err) => {\n        if (err) {\n          return cb(err)\n        }\n\n        newBlocks.forEach((block) => {\n          this.notifications.hasBlock(block)\n          this.engine.receivedBlocks([block.cid])\n          this.network.provide(block.cid, (err) => {\n            if (err) {\n              this._log.error('Failed to provide: %s', err.message)\n            }\n          })\n        })\n        cb()\n      })\n    ], callback)\n  }\n\n  /**\n   * Get the current list of wants.\n   *\n   * @returns {Iterator<WantlistEntry>}\n   */\n  getWantlist () {\n    return this.wm.wantlist.entries()\n  }\n\n  /**\n   * Get the current list of partners.\n   *\n   * @returns {Array<PeerId>}\n   */\n  peers () {\n    return this.engine.peers()\n  }\n\n  /**\n   * Get stats about the bitswap node.\n   *\n   * @returns {Object}\n   */\n  stat () {\n    return this._stats\n  }\n\n  /**\n   * Start the bitswap node.\n   *\n   * @param {function(Error)} callback\n   *\n   * @returns {void}\n   */\n  start (callback) {\n    series([\n      (cb) => this.wm.start(cb),\n      (cb) => this.network.start(cb),\n      (cb) => this.engine.start(cb)\n    ], callback)\n  }\n\n  /**\n   * Stop the bitswap node.\n   *\n   * @param {function(Error)} callback\n   *\n   * @returns {void}\n   */\n  stop (callback) {\n    this._stats.stop()\n    series([\n      (cb) => this.wm.stop(cb),\n      (cb) => this.network.stop(cb),\n      (cb) => this.engine.stop(cb)\n    ], callback)\n  }\n}\n\nmodule.exports = Bitswap\n"]},"metadata":{},"sourceType":"script"}