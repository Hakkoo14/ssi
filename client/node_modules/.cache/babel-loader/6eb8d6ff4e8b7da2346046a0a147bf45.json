{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar cache = require('hashlru');\n\nvar varint = require('varint');\n\nvar PeerId = require('peer-id');\n\nvar Key = require('interface-datastore').Key;\n\nvar _require = require('p-queue'),\n    Queue = _require.default;\n\nvar promisify = require('promisify-es6');\n\nvar toIterator = require('pull-stream-to-async-iterator');\n\nvar c = require('./constants');\n\nvar utils = require('./utils');\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\n\n\nvar Providers = /*#__PURE__*/function () {\n  /**\n   * @param {Object} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  function Providers(datastore, self, cacheSize) {\n    _classCallCheck(this, Providers);\n\n    this.datastore = datastore;\n    this._log = utils.logger(self, 'providers');\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL;\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.provideValidity = c.PROVIDERS_VALIDITY;\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE;\n    this.providers = cache(this.lruCacheSize);\n    this.syncQueue = new Queue({\n      concurrency: 1\n    });\n  }\n  /**\n   * Release any resources.\n   *\n   * @returns {undefined}\n   */\n\n\n  _createClass(Providers, [{\n    key: \"stop\",\n    value: function stop() {\n      if (this._cleaner) {\n        clearInterval(this._cleaner);\n        this._cleaner = null;\n      }\n    }\n    /**\n     * Check all providers if they are still valid, and if not delete them.\n     *\n     * @returns {Promise}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      var _this = this;\n\n      return this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var start, count, deleteCount, deleted, batch, query, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, entry, _parseProviderKey, cid, peerId, time, now, delta, expired, peers, _iterator3, _step3, _step3$value, _cid, _peers, key, provs, _iterator4, _step4, _peerId;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this._log('start cleanup');\n\n                start = Date.now();\n                count = 0;\n                deleteCount = 0;\n                deleted = new Map();\n                batch = _this.datastore.batch(); // Get all provider entries from the datastore\n\n                query = _this.datastore.query({\n                  prefix: c.PROVIDERS_KEY_PREFIX\n                });\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context.prev = 9;\n                _iterator = _asyncIterator(toIterator(query));\n\n              case 11:\n                _context.next = 13;\n                return _iterator.next();\n\n              case 13:\n                _step = _context.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context.next = 17;\n                return _step.value;\n\n              case 17:\n                _value = _context.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context.next = 24;\n                  break;\n                }\n\n                entry = _value;\n\n                try {\n                  // Add a delete to the batch for each expired entry\n                  _parseProviderKey = parseProviderKey(entry.key), cid = _parseProviderKey.cid, peerId = _parseProviderKey.peerId;\n                  time = readTime(entry.value);\n                  now = Date.now();\n                  delta = now - time;\n                  expired = delta > _this.provideValidity;\n\n                  _this._log('comparing: %d - %d = %d > %d %s', now, time, delta, _this.provideValidity, expired ? '(expired)' : '');\n\n                  if (expired) {\n                    deleteCount++;\n                    batch.delete(entry.key);\n                    peers = deleted.get(cid) || new Set();\n                    peers.add(peerId);\n                    deleted.set(cid, peers);\n                  }\n\n                  count++;\n                } catch (err) {\n                  _this._log.error(err.message);\n                }\n\n              case 21:\n                _iteratorNormalCompletion = true;\n                _context.next = 11;\n                break;\n\n              case 24:\n                _context.next = 30;\n                break;\n\n              case 26:\n                _context.prev = 26;\n                _context.t0 = _context[\"catch\"](9);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 30:\n                _context.prev = 30;\n                _context.prev = 31;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context.next = 35;\n                  break;\n                }\n\n                _context.next = 35;\n                return _iterator.return();\n\n              case 35:\n                _context.prev = 35;\n\n                if (!_didIteratorError) {\n                  _context.next = 38;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 38:\n                return _context.finish(35);\n\n              case 39:\n                return _context.finish(30);\n\n              case 40:\n                _this._log('deleting %d / %d entries', deleteCount, count); // Commit the deletes to the datastore\n\n\n                if (!deleted.size) {\n                  _context.next = 44;\n                  break;\n                }\n\n                _context.next = 44;\n                return promisify(function (cb) {\n                  return batch.commit(cb);\n                })();\n\n              case 44:\n                // Clear expired entries from the cache\n                _iterator3 = _createForOfIteratorHelper(deleted);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    _step3$value = _slicedToArray(_step3.value, 2), _cid = _step3$value[0], _peers = _step3$value[1];\n                    key = makeProviderKey(_cid);\n                    provs = _this.providers.get(key);\n\n                    if (provs) {\n                      _iterator4 = _createForOfIteratorHelper(_peers);\n\n                      try {\n                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                          _peerId = _step4.value;\n                          provs.delete(_peerId);\n                        }\n                      } catch (err) {\n                        _iterator4.e(err);\n                      } finally {\n                        _iterator4.f();\n                      }\n\n                      if (provs.size === 0) {\n                        _this.providers.remove(key);\n                      } else {\n                        _this.providers.set(key, provs);\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                _this._log('Cleanup successful (%dms)', Date.now() - start);\n\n              case 47:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[9, 26, 30, 40], [31,, 35, 39]]);\n      })));\n    }\n    /**\n     * Get the currently known provider peer ids for a given CID.\n     *\n     * @param {CID} cid\n     * @returns {Promise<Map<String, Date>>}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_getProvidersMap\",\n    value: function () {\n      var _getProvidersMap2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(cid) {\n        var cacheKey, provs;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cacheKey = makeProviderKey(cid);\n                provs = this.providers.get(cacheKey);\n\n                if (provs) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 5;\n                return loadProviders(this.datastore, cid);\n\n              case 5:\n                provs = _context2.sent;\n                this.providers.set(cacheKey, provs);\n\n              case 7:\n                return _context2.abrupt(\"return\", provs);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _getProvidersMap(_x) {\n        return _getProvidersMap2.apply(this, arguments);\n      }\n\n      return _getProvidersMap;\n    }()\n  }, {\n    key: \"cleanupInterval\",\n    get: function get() {\n      return this._cleanupInterval;\n    },\n    set: function set(val) {\n      var _this2 = this;\n\n      this._cleanupInterval = val;\n\n      if (this._cleaner) {\n        clearInterval(this._cleaner);\n      }\n\n      this._cleaner = setInterval(function () {\n        return _this2._cleanup();\n      }, this.cleanupInterval);\n    }\n    /**\n     * Add a new provider for the given CID.\n     *\n     * @param {CID} cid\n     * @param {PeerId} provider\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"addProvider\",\n    value: function () {\n      var _addProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(cid, provider) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                  var provs, now, dsKey;\n                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          _this3._log('addProvider %s', cid.toBaseEncodedString());\n\n                          _context3.next = 3;\n                          return _this3._getProvidersMap(cid);\n\n                        case 3:\n                          provs = _context3.sent;\n\n                          _this3._log('loaded %s provs', provs.size);\n\n                          now = Date.now();\n                          provs.set(utils.encodeBase32(provider.id), now);\n                          dsKey = makeProviderKey(cid);\n\n                          _this3.providers.set(dsKey, provs);\n\n                          return _context3.abrupt(\"return\", writeProviderEntry(_this3.datastore, cid, provider, now));\n\n                        case 10:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                }))));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function addProvider(_x2, _x3) {\n        return _addProvider.apply(this, arguments);\n      }\n\n      return addProvider;\n    }()\n    /**\n     * Get a list of providers for the given CID.\n     *\n     * @param {CID} cid\n     * @returns {Promise<Array<PeerId>>}\n     */\n\n  }, {\n    key: \"getProviders\",\n    value: function () {\n      var _getProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(cid) {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                  var provs;\n                  return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _this4._log('getProviders %s', cid.toBaseEncodedString());\n\n                          _context5.next = 3;\n                          return _this4._getProvidersMap(cid);\n\n                        case 3:\n                          provs = _context5.sent;\n                          return _context5.abrupt(\"return\", _toConsumableArray(provs.keys()).map(function (base32PeerId) {\n                            return new PeerId(utils.decodeBase32(base32PeerId));\n                          }));\n\n                        case 5:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5);\n                }))));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getProviders(_x4) {\n        return _getProviders.apply(this, arguments);\n      }\n\n      return getProviders;\n    }()\n  }]);\n\n  return Providers;\n}();\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\n\n\nfunction makeProviderKey(cid) {\n  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.buffer);\n  return c.PROVIDERS_KEY_PREFIX + cid;\n}\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {number} time\n * @returns {Promise}\n *\n * @private\n */\n\n\nfunction writeProviderEntry(_x5, _x6, _x7, _x8) {\n  return _writeProviderEntry.apply(this, arguments);\n}\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {DKey} key\n * @returns {Object} object with peer id and cid\n *\n * @private\n */\n\n\nfunction _writeProviderEntry() {\n  _writeProviderEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(store, cid, peer, time) {\n    var dsKey, key, buffer;\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            dsKey = [makeProviderKey(cid), '/', utils.encodeBase32(peer.id)].join('');\n            key = new Key(dsKey);\n            buffer = Buffer.from(varint.encode(time));\n            return _context7.abrupt(\"return\", promisify(function (cb) {\n              return store.put(key, buffer, cb);\n            })());\n\n          case 4:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _writeProviderEntry.apply(this, arguments);\n}\n\nfunction parseProviderKey(key) {\n  var parts = key.toString().split('/');\n\n  if (parts.length !== 4) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key);\n  }\n\n  return {\n    cid: parts[2],\n    peerId: parts[3]\n  };\n}\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\n\n\nfunction loadProviders(_x9, _x10) {\n  return _loadProviders.apply(this, arguments);\n}\n\nfunction _loadProviders() {\n  _loadProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(store, cid) {\n    var providers, query, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, entry, _parseProviderKey2, peerId;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            providers = new Map();\n            query = store.query({\n              prefix: makeProviderKey(cid)\n            });\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context8.prev = 4;\n            _iterator2 = _asyncIterator(toIterator(query));\n\n          case 6:\n            _context8.next = 8;\n            return _iterator2.next();\n\n          case 8:\n            _step2 = _context8.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context8.next = 12;\n            return _step2.value;\n\n          case 12:\n            _value2 = _context8.sent;\n\n            if (_iteratorNormalCompletion2) {\n              _context8.next = 20;\n              break;\n            }\n\n            entry = _value2;\n            _parseProviderKey2 = parseProviderKey(entry.key), peerId = _parseProviderKey2.peerId;\n            providers.set(peerId, readTime(entry.value));\n\n          case 17:\n            _iteratorNormalCompletion2 = true;\n            _context8.next = 6;\n            break;\n\n          case 20:\n            _context8.next = 26;\n            break;\n\n          case 22:\n            _context8.prev = 22;\n            _context8.t0 = _context8[\"catch\"](4);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context8.t0;\n\n          case 26:\n            _context8.prev = 26;\n            _context8.prev = 27;\n\n            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n              _context8.next = 31;\n              break;\n            }\n\n            _context8.next = 31;\n            return _iterator2.return();\n\n          case 31:\n            _context8.prev = 31;\n\n            if (!_didIteratorError2) {\n              _context8.next = 34;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 34:\n            return _context8.finish(31);\n\n          case 35:\n            return _context8.finish(26);\n\n          case 36:\n            return _context8.abrupt(\"return\", providers);\n\n          case 37:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[4, 22, 26, 36], [27,, 31, 35]]);\n  }));\n  return _loadProviders.apply(this, arguments);\n}\n\nfunction readTime(buf) {\n  return varint.decode(buf);\n}\n\nmodule.exports = Providers;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/libp2p-kad-dht/src/providers.js"],"names":["cache","require","varint","PeerId","Key","Queue","default","promisify","toIterator","c","utils","Providers","datastore","self","cacheSize","_log","logger","cleanupInterval","PROVIDERS_CLEANUP_INTERVAL","provideValidity","PROVIDERS_VALIDITY","lruCacheSize","PROVIDERS_LRU_CACHE_SIZE","providers","syncQueue","concurrency","_cleaner","clearInterval","add","start","Date","now","count","deleteCount","deleted","Map","batch","query","prefix","PROVIDERS_KEY_PREFIX","entry","parseProviderKey","key","cid","peerId","time","readTime","value","delta","expired","delete","peers","get","Set","set","err","error","message","size","cb","commit","makeProviderKey","provs","remove","cacheKey","loadProviders","_cleanupInterval","val","setInterval","_cleanup","provider","toBaseEncodedString","_getProvidersMap","encodeBase32","id","dsKey","writeProviderEntry","keys","map","base32PeerId","decodeBase32","buffer","store","peer","join","Buffer","from","encode","put","parts","toString","split","length","Error","buf","decode","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst cache = require('hashlru')\nconst varint = require('varint')\nconst PeerId = require('peer-id')\nconst Key = require('interface-datastore').Key\nconst { default: Queue } = require('p-queue')\nconst promisify = require('promisify-es6')\nconst toIterator = require('pull-stream-to-async-iterator')\n\nconst c = require('./constants')\nconst utils = require('./utils')\n\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nclass Providers {\n  /**\n   * @param {Object} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  constructor (datastore, self, cacheSize) {\n    this.datastore = datastore\n\n    this._log = utils.logger(self, 'providers')\n\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL\n\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n    this.provideValidity = c.PROVIDERS_VALIDITY\n\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE\n\n    this.providers = cache(this.lruCacheSize)\n\n    this.syncQueue = new Queue({ concurrency: 1 })\n  }\n\n  /**\n   * Release any resources.\n   *\n   * @returns {undefined}\n   */\n  stop () {\n    if (this._cleaner) {\n      clearInterval(this._cleaner)\n      this._cleaner = null\n    }\n  }\n\n  /**\n   * Check all providers if they are still valid, and if not delete them.\n   *\n   * @returns {Promise}\n   *\n   * @private\n   */\n  _cleanup () {\n    return this.syncQueue.add(async () => {\n      this._log('start cleanup')\n      const start = Date.now()\n\n      let count = 0\n      let deleteCount = 0\n      const deleted = new Map()\n      const batch = this.datastore.batch()\n\n      // Get all provider entries from the datastore\n      const query = this.datastore.query({ prefix: c.PROVIDERS_KEY_PREFIX })\n      for await (const entry of toIterator(query)) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const { cid, peerId } = parseProviderKey(entry.key)\n          const time = readTime(entry.value)\n          const now = Date.now()\n          const delta = now - time\n          const expired = delta > this.provideValidity\n          this._log('comparing: %d - %d = %d > %d %s',\n            now, time, delta, this.provideValidity, expired ? '(expired)' : '')\n          if (expired) {\n            deleteCount++\n            batch.delete(entry.key)\n            const peers = deleted.get(cid) || new Set()\n            peers.add(peerId)\n            deleted.set(cid, peers)\n          }\n          count++\n        } catch (err) {\n          this._log.error(err.message)\n        }\n      }\n      this._log('deleting %d / %d entries', deleteCount, count)\n\n      // Commit the deletes to the datastore\n      if (deleted.size) {\n        await promisify(cb => batch.commit(cb))()\n      }\n\n      // Clear expired entries from the cache\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid)\n        const provs = this.providers.get(key)\n        if (provs) {\n          for (const peerId of peers) {\n            provs.delete(peerId)\n          }\n          if (provs.size === 0) {\n            this.providers.remove(key)\n          } else {\n            this.providers.set(key, provs)\n          }\n        }\n      }\n\n      this._log('Cleanup successful (%dms)', Date.now() - start)\n    })\n  }\n\n  /**\n   * Get the currently known provider peer ids for a given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Map<String, Date>>}\n   *\n   * @private\n   */\n  async _getProvidersMap (cid) {\n    const cacheKey = makeProviderKey(cid)\n    let provs = this.providers.get(cacheKey)\n    if (!provs) {\n      provs = await loadProviders(this.datastore, cid)\n      this.providers.set(cacheKey, provs)\n    }\n    return provs\n  }\n\n  get cleanupInterval () {\n    return this._cleanupInterval\n  }\n\n  set cleanupInterval (val) {\n    this._cleanupInterval = val\n\n    if (this._cleaner) {\n      clearInterval(this._cleaner)\n    }\n\n    this._cleaner = setInterval(\n      () => this._cleanup(),\n      this.cleanupInterval\n    )\n  }\n\n  /**\n   * Add a new provider for the given CID.\n   *\n   * @param {CID} cid\n   * @param {PeerId} provider\n   * @returns {Promise}\n   */\n  async addProvider (cid, provider) {\n    return this.syncQueue.add(async () => {\n      this._log('addProvider %s', cid.toBaseEncodedString())\n      const provs = await this._getProvidersMap(cid)\n\n      this._log('loaded %s provs', provs.size)\n      const now = Date.now()\n      provs.set(utils.encodeBase32(provider.id), now)\n\n      const dsKey = makeProviderKey(cid)\n      this.providers.set(dsKey, provs)\n      return writeProviderEntry(this.datastore, cid, provider, now)\n    })\n  }\n\n  /**\n   * Get a list of providers for the given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Array<PeerId>>}\n   */\n  async getProviders (cid) {\n    return this.syncQueue.add(async () => {\n      this._log('getProviders %s', cid.toBaseEncodedString())\n      const provs = await this._getProvidersMap(cid)\n      return [...provs.keys()].map((base32PeerId) => {\n        return new PeerId(utils.decodeBase32(base32PeerId))\n      })\n    })\n  }\n}\n\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\nfunction makeProviderKey (cid) {\n  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.buffer)\n  return c.PROVIDERS_KEY_PREFIX + cid\n}\n\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {number} time\n * @returns {Promise}\n *\n * @private\n */\nasync function writeProviderEntry (store, cid, peer, time) {\n  const dsKey = [\n    makeProviderKey(cid),\n    '/',\n    utils.encodeBase32(peer.id)\n  ].join('')\n\n  const key = new Key(dsKey)\n  const buffer = Buffer.from(varint.encode(time))\n  return promisify(cb => store.put(key, buffer, cb))()\n}\n\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {DKey} key\n * @returns {Object} object with peer id and cid\n *\n * @private\n */\nfunction parseProviderKey (key) {\n  const parts = key.toString().split('/')\n  if (parts.length !== 4) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key)\n  }\n\n  return {\n    cid: parts[2],\n    peerId: parts[3]\n  }\n}\n\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\nasync function loadProviders (store, cid) {\n  const providers = new Map()\n  const query = store.query({ prefix: makeProviderKey(cid) })\n  for await (const entry of toIterator(query)) {\n    const { peerId } = parseProviderKey(entry.key)\n    providers.set(peerId, readTime(entry.value))\n  }\n  return providers\n}\n\nfunction readTime (buf) {\n  return varint.decode(buf)\n}\n\nmodule.exports = Providers\n"]},"metadata":{},"sourceType":"script"}