{"ast":null,"code":"'use strict';\n\nvar CID = require('cids');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('../../../utils/cid'),\n    cidToString = _require2.cidToString;\n\nvar toPullStream = require('async-iterator-to-pull-stream');\n\nvar normalizePath = function normalizePath(path) {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString();\n  }\n\n  if (CID.isCID(path)) {\n    return path.toString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Parses chunker string into options used by DAGBuilder in ipfs-unixfs-engine\n *\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                    \"size-{size}\"\n *                    \"rabin\"\n *                    \"rabin-{avg}\"\n *                    \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   Chunker options for DAGBuilder\n */\n\n\nvar parseChunkerString = function parseChunkerString(chunker) {\n  if (!chunker) {\n    return {\n      chunker: 'fixed'\n    };\n  } else if (chunker.startsWith('size-')) {\n    var sizeStr = chunker.split('-')[1];\n    var size = parseInt(sizeStr);\n\n    if (isNaN(size)) {\n      throw new Error('Chunker parameter size must be an integer');\n    }\n\n    return {\n      chunker: 'fixed',\n      chunkerOptions: {\n        maxChunkSize: size\n      }\n    };\n  } else if (chunker.startsWith('rabin')) {\n    return {\n      chunker: 'rabin',\n      chunkerOptions: parseRabinString(chunker)\n    };\n  } else {\n    throw new Error(\"Unrecognized chunker option: \".concat(chunker));\n  }\n};\n/**\n * Parses rabin chunker string\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                            \"rabin\"\n *                            \"rabin-{avg}\"\n *                            \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   rabin chunker options\n */\n\n\nvar parseRabinString = function parseRabinString(chunker) {\n  var options = {};\n  var parts = chunker.split('-');\n\n  switch (parts.length) {\n    case 1:\n      options.avgChunkSize = 262144;\n      break;\n\n    case 2:\n      options.avgChunkSize = parseChunkSize(parts[1], 'avg');\n      break;\n\n    case 4:\n      options.minChunkSize = parseChunkSize(parts[1], 'min');\n      options.avgChunkSize = parseChunkSize(parts[2], 'avg');\n      options.maxChunkSize = parseChunkSize(parts[3], 'max');\n      break;\n\n    default:\n      throw new Error('Incorrect chunker format (expected \"rabin\" \"rabin-[avg]\" or \"rabin-[min]-[avg]-[max]\"');\n  }\n\n  return options;\n};\n\nvar parseChunkSize = function parseChunkSize(str, name) {\n  var size = parseInt(str);\n\n  if (isNaN(size)) {\n    throw new Error(\"Chunker parameter \".concat(name, \" must be an integer\"));\n  }\n\n  return size;\n};\n\nvar mapFile = function mapFile() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (file) {\n    var size = 0;\n    var type = 'dir';\n\n    if (file.unixfs && file.unixfs.type === 'file') {\n      size = file.unixfs.fileSize();\n      type = 'file';\n    }\n\n    var output = {\n      hash: cidToString(file.cid, {\n        base: options.cidBase\n      }),\n      path: file.path,\n      name: file.name,\n      depth: file.path.split('/').length,\n      size: size,\n      type: type\n    };\n\n    if (options.includeContent && file.unixfs && file.unixfs.type === 'file') {\n      output.content = toPullStream.source(file.content());\n    }\n\n    return output;\n  };\n};\n\nmodule.exports = {\n  normalizePath: normalizePath,\n  parseChunkSize: parseChunkSize,\n  parseRabinString: parseRabinString,\n  parseChunkerString: parseChunkerString,\n  mapFile: mapFile\n};","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs/src/core/components/files-regular/utils.js"],"names":["CID","require","Buffer","cidToString","toPullStream","normalizePath","path","isBuffer","toString","isCID","indexOf","substring","length","charAt","parseChunkerString","chunker","startsWith","sizeStr","split","size","parseInt","isNaN","Error","chunkerOptions","maxChunkSize","parseRabinString","options","parts","avgChunkSize","parseChunkSize","minChunkSize","str","name","mapFile","file","type","unixfs","fileSize","output","hash","cid","base","cidBase","depth","includeContent","content","source","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst { Buffer } = require('buffer')\nconst { cidToString } = require('../../../utils/cid')\nconst toPullStream = require('async-iterator-to-pull-stream')\n\nconst normalizePath = (path) => {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString()\n  }\n  if (CID.isCID(path)) {\n    return path.toString()\n  }\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length)\n  }\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1)\n  }\n  return path\n}\n\n/**\n * Parses chunker string into options used by DAGBuilder in ipfs-unixfs-engine\n *\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                    \"size-{size}\"\n *                    \"rabin\"\n *                    \"rabin-{avg}\"\n *                    \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   Chunker options for DAGBuilder\n */\nconst parseChunkerString = (chunker) => {\n  if (!chunker) {\n    return {\n      chunker: 'fixed'\n    }\n  } else if (chunker.startsWith('size-')) {\n    const sizeStr = chunker.split('-')[1]\n    const size = parseInt(sizeStr)\n    if (isNaN(size)) {\n      throw new Error('Chunker parameter size must be an integer')\n    }\n    return {\n      chunker: 'fixed',\n      chunkerOptions: {\n        maxChunkSize: size\n      }\n    }\n  } else if (chunker.startsWith('rabin')) {\n    return {\n      chunker: 'rabin',\n      chunkerOptions: parseRabinString(chunker)\n    }\n  } else {\n    throw new Error(`Unrecognized chunker option: ${chunker}`)\n  }\n}\n\n/**\n * Parses rabin chunker string\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                            \"rabin\"\n *                            \"rabin-{avg}\"\n *                            \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   rabin chunker options\n */\nconst parseRabinString = (chunker) => {\n  const options = {}\n  const parts = chunker.split('-')\n  switch (parts.length) {\n    case 1:\n      options.avgChunkSize = 262144\n      break\n    case 2:\n      options.avgChunkSize = parseChunkSize(parts[1], 'avg')\n      break\n    case 4:\n      options.minChunkSize = parseChunkSize(parts[1], 'min')\n      options.avgChunkSize = parseChunkSize(parts[2], 'avg')\n      options.maxChunkSize = parseChunkSize(parts[3], 'max')\n      break\n    default:\n      throw new Error('Incorrect chunker format (expected \"rabin\" \"rabin-[avg]\" or \"rabin-[min]-[avg]-[max]\"')\n  }\n\n  return options\n}\n\nconst parseChunkSize = (str, name) => {\n  let size = parseInt(str)\n  if (isNaN(size)) {\n    throw new Error(`Chunker parameter ${name} must be an integer`)\n  }\n\n  return size\n}\n\nconst mapFile = (options = {}) => {\n  return (file) => {\n    let size = 0\n    let type = 'dir'\n\n    if (file.unixfs && file.unixfs.type === 'file') {\n      size = file.unixfs.fileSize()\n      type = 'file'\n    }\n\n    const output = {\n      hash: cidToString(file.cid, { base: options.cidBase }),\n      path: file.path,\n      name: file.name,\n      depth: file.path.split('/').length,\n      size,\n      type\n    }\n\n    if (options.includeContent && file.unixfs && file.unixfs.type === 'file') {\n      output.content = toPullStream.source(file.content())\n    }\n\n    return output\n  }\n}\n\nmodule.exports = {\n  normalizePath,\n  parseChunkSize,\n  parseRabinString,\n  parseChunkerString,\n  mapFile\n}\n"]},"metadata":{},"sourceType":"script"}