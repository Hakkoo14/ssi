{"ast":null,"code":"'use strict';\n\nvar setImmediate = require('async/setImmediate');\n\nvar multicodec = require('./multicodec');\n\nvar EE = require('events').EventEmitter;\n\nvar multiaddr = require('multiaddr');\n\nvar mafmt = require('mafmt');\n\nvar Stop = require('./circuit/stop');\n\nvar Hop = require('./circuit/hop');\n\nvar proto = require('./protocol');\n\nvar utilsFactory = require('./circuit/utils');\n\nvar StreamHandler = require('./circuit/stream-handler');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:circuit:listener');\nlog.err = debug('libp2p:circuit:error:listener');\n\nmodule.exports = function (swarm, options, connHandler) {\n  var listener = new EE();\n  var utils = utilsFactory(swarm);\n  listener.stopHandler = new Stop(swarm);\n  listener.stopHandler.on('connection', function (conn) {\n    return listener.emit('connection', conn);\n  });\n  listener.hopHandler = new Hop(swarm, options.hop);\n  /**\n   * Add swarm handler and listen for incoming connections\n   *\n   * @param {Multiaddr} ma\n   * @param {Function} callback\n   * @return {void}\n   */\n\n  listener.listen = function (ma, callback) {\n    callback = callback || function () {};\n\n    swarm.handle(multicodec.relay, function (_, conn) {\n      var sh = new StreamHandler(conn);\n      sh.read(function (err, msg) {\n        if (err) {\n          log.err(err);\n          return;\n        }\n\n        var request = null;\n\n        try {\n          request = proto.CircuitRelay.decode(msg);\n        } catch (err) {\n          return utils.writeResponse(sh, proto.CircuitRelay.Status.MALFORMED_MESSAGE);\n        }\n\n        switch (request.type) {\n          case proto.CircuitRelay.Type.CAN_HOP:\n          case proto.CircuitRelay.Type.HOP:\n            {\n              return listener.hopHandler.handle(request, sh);\n            }\n\n          case proto.CircuitRelay.Type.STOP:\n            {\n              return listener.stopHandler.handle(request, sh, connHandler);\n            }\n\n          default:\n            {\n              utils.writeResponse(sh, proto.CircuitRelay.Status.INVALID_MSG_TYPE);\n              return sh.close();\n            }\n        }\n      });\n    });\n    setImmediate(function () {\n      return listener.emit('listen');\n    });\n    callback();\n  };\n  /**\n   * Remove swarm listener\n   *\n   * @param {Function} cb\n   * @return {void}\n   */\n\n\n  listener.close = function (cb) {\n    swarm.unhandle(multicodec.relay);\n    setImmediate(function () {\n      return listener.emit('close');\n    });\n    cb();\n  };\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   *    `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   *    address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   *    `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   *    addr, such when dialing over a relay with this address, it will create the circuit using\n   *    the encapsulated transport address. This is useful when for example, a peer should only\n   *    be dialed over TCP rather than any other transport\n   *\n   * @param {Function} callback\n   * @return {void}\n   */\n\n\n  listener.getAddrs = function (callback) {\n    var addrs = swarm._peerInfo.multiaddrs.toArray(); // get all the explicit relay addrs excluding self\n\n\n    var p2pAddrs = addrs.filter(function (addr) {\n      return mafmt.Circuit.matches(addr) && !addr.toString().includes(swarm._peerInfo.id.toB58String());\n    }); // use the explicit relays instead of any relay\n\n    if (p2pAddrs.length) {\n      addrs = p2pAddrs;\n    }\n\n    var listenAddrs = [];\n    addrs.forEach(function (addr) {\n      var peerMa = \"/p2p-circuit/ipfs/\".concat(swarm._peerInfo.id.toB58String());\n\n      if (addr.toString() === peerMa) {\n        listenAddrs.push(multiaddr(peerMa));\n        return;\n      }\n\n      if (!mafmt.Circuit.matches(addr)) {\n        if (addr.getPeerId()) {\n          // by default we're reachable over any relay\n          listenAddrs.push(multiaddr(\"/p2p-circuit\").encapsulate(addr));\n        } else {\n          var ma = \"\".concat(addr, \"/ipfs/\").concat(swarm._peerInfo.id.toB58String());\n          listenAddrs.push(multiaddr(\"/p2p-circuit\").encapsulate(ma));\n        }\n      } else {\n        listenAddrs.push(addr.encapsulate(\"/ipfs/\".concat(swarm._peerInfo.id.toB58String())));\n      }\n    });\n    callback(null, listenAddrs);\n  };\n\n  return listener;\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/libp2p-circuit/src/listener.js"],"names":["setImmediate","require","multicodec","EE","EventEmitter","multiaddr","mafmt","Stop","Hop","proto","utilsFactory","StreamHandler","debug","log","err","module","exports","swarm","options","connHandler","listener","utils","stopHandler","on","conn","emit","hopHandler","hop","listen","ma","callback","handle","relay","_","sh","read","msg","request","CircuitRelay","decode","writeResponse","Status","MALFORMED_MESSAGE","type","Type","CAN_HOP","HOP","STOP","INVALID_MSG_TYPE","close","cb","unhandle","getAddrs","addrs","_peerInfo","multiaddrs","toArray","p2pAddrs","filter","addr","Circuit","matches","toString","includes","id","toB58String","length","listenAddrs","forEach","peerMa","push","getPeerId","encapsulate"],"mappings":"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","sourcesContent":["'use strict'\n\nconst setImmediate = require('async/setImmediate')\n\nconst multicodec = require('./multicodec')\nconst EE = require('events').EventEmitter\nconst multiaddr = require('multiaddr')\nconst mafmt = require('mafmt')\nconst Stop = require('./circuit/stop')\nconst Hop = require('./circuit/hop')\nconst proto = require('./protocol')\nconst utilsFactory = require('./circuit/utils')\n\nconst StreamHandler = require('./circuit/stream-handler')\n\nconst debug = require('debug')\n\nconst log = debug('libp2p:circuit:listener')\nlog.err = debug('libp2p:circuit:error:listener')\n\nmodule.exports = (swarm, options, connHandler) => {\n  const listener = new EE()\n  const utils = utilsFactory(swarm)\n\n  listener.stopHandler = new Stop(swarm)\n  listener.stopHandler.on('connection', (conn) => listener.emit('connection', conn))\n  listener.hopHandler = new Hop(swarm, options.hop)\n\n  /**\n   * Add swarm handler and listen for incoming connections\n   *\n   * @param {Multiaddr} ma\n   * @param {Function} callback\n   * @return {void}\n   */\n  listener.listen = (ma, callback) => {\n    callback = callback || (() => {})\n\n    swarm.handle(multicodec.relay, (_, conn) => {\n      const sh = new StreamHandler(conn)\n\n      sh.read((err, msg) => {\n        if (err) {\n          log.err(err)\n          return\n        }\n\n        let request = null\n        try {\n          request = proto.CircuitRelay.decode(msg)\n        } catch (err) {\n          return utils.writeResponse(\n            sh,\n            proto.CircuitRelay.Status.MALFORMED_MESSAGE)\n        }\n\n        switch (request.type) {\n          case proto.CircuitRelay.Type.CAN_HOP:\n          case proto.CircuitRelay.Type.HOP: {\n            return listener.hopHandler.handle(request, sh)\n          }\n\n          case proto.CircuitRelay.Type.STOP: {\n            return listener.stopHandler.handle(request, sh, connHandler)\n          }\n\n          default: {\n            utils.writeResponse(\n              sh,\n              proto.CircuitRelay.Status.INVALID_MSG_TYPE)\n            return sh.close()\n          }\n        }\n      })\n    })\n\n    setImmediate(() => listener.emit('listen'))\n    callback()\n  }\n\n  /**\n   * Remove swarm listener\n   *\n   * @param {Function} cb\n   * @return {void}\n   */\n  listener.close = (cb) => {\n    swarm.unhandle(multicodec.relay)\n    setImmediate(() => listener.emit('close'))\n    cb()\n  }\n\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   *    `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   *    address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   *    `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   *    addr, such when dialing over a relay with this address, it will create the circuit using\n   *    the encapsulated transport address. This is useful when for example, a peer should only\n   *    be dialed over TCP rather than any other transport\n   *\n   * @param {Function} callback\n   * @return {void}\n   */\n  listener.getAddrs = (callback) => {\n    let addrs = swarm._peerInfo.multiaddrs.toArray()\n\n    // get all the explicit relay addrs excluding self\n    let p2pAddrs = addrs.filter((addr) => {\n      return mafmt.Circuit.matches(addr) &&\n        !addr.toString().includes(swarm._peerInfo.id.toB58String())\n    })\n\n    // use the explicit relays instead of any relay\n    if (p2pAddrs.length) {\n      addrs = p2pAddrs\n    }\n\n    let listenAddrs = []\n    addrs.forEach((addr) => {\n      const peerMa = `/p2p-circuit/ipfs/${swarm._peerInfo.id.toB58String()}`\n      if (addr.toString() === peerMa) {\n        listenAddrs.push(multiaddr(peerMa))\n        return\n      }\n\n      if (!mafmt.Circuit.matches(addr)) {\n        if (addr.getPeerId()) {\n          // by default we're reachable over any relay\n          listenAddrs.push(multiaddr(`/p2p-circuit`).encapsulate(addr))\n        } else {\n          const ma = `${addr}/ipfs/${swarm._peerInfo.id.toB58String()}`\n          listenAddrs.push(multiaddr(`/p2p-circuit`).encapsulate(ma))\n        }\n      } else {\n        listenAddrs.push(addr.encapsulate(`/ipfs/${swarm._peerInfo.id.toB58String()}`))\n      }\n    })\n\n    callback(null, listenAddrs)\n  }\n\n  return listener\n}\n"]},"metadata":{},"sourceType":"script"}