{"ast":null,"code":"var node = require('./node');\n\nvar browser = require('./browser');\n\nvar _require = require('p-queue'),\n    Queue = _require.default;\n\nvar _require2 = require('promise-timeout'),\n    timeout = _require2.timeout;\n\nvar observe = require('observable-webworkers');\n\nvar mutexes = {};\nvar implementation;\n\nvar createMutex = function createMutex(name, options) {\n  if (implementation.isWorker) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    };\n  }\n\n  var masterQueue = new Queue({\n    concurrency: 1\n  });\n  var readQueue = null;\n  return {\n    readLock: function readLock(fn) {\n      // If there's already a read queue, just add the task to it\n      if (readQueue) {\n        return readQueue.add(function () {\n          return timeout(fn(), options.timeout);\n        });\n      } // Create a new read queue\n\n\n      readQueue = new Queue({\n        concurrency: options.concurrency,\n        autoStart: false\n      });\n      var localReadQueue = readQueue; // Add the task to the read queue\n\n      var readPromise = readQueue.add(function () {\n        return timeout(fn(), options.timeout);\n      });\n      masterQueue.add(function () {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start(); // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n\n        return localReadQueue.onIdle().then(function () {\n          if (readQueue === localReadQueue) {\n            readQueue = null;\n          }\n        });\n      });\n      return readPromise;\n    },\n    writeLock: function writeLock(fn) {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null;\n      return masterQueue.add(function () {\n        return timeout(fn(), options.timeout);\n      });\n    }\n  };\n};\n\nvar defaultOptions = {\n  concurrency: Infinity,\n  timeout: 84600000,\n  global: global,\n  singleProcess: false\n};\n\nmodule.exports = function (name, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof name === 'object') {\n    options = name;\n    name = 'lock';\n  }\n\n  if (!name) {\n    name = 'lock';\n  }\n\n  options = Object.assign({}, defaultOptions, options);\n\n  if (!implementation) {\n    implementation = node(options) || browser(options);\n\n    if (!implementation.isWorker) {\n      // we are master, set up worker requests\n      implementation.on('requestReadLock', function (name, fn) {\n        mutexes[name] && mutexes[name].readLock(fn);\n      });\n      implementation.on('requestWriteLock', function (name, fn) {\n        mutexes[name] && mutexes[name].writeLock(fn);\n      });\n    }\n  }\n\n  if (!mutexes[name]) {\n    mutexes[name] = createMutex(name, options);\n  }\n\n  return mutexes[name];\n};\n\nmodule.exports.Worker = function (script, Impl) {\n  Impl = Impl || global.Worker;\n  var worker;\n\n  try {\n    worker = new Impl(script);\n  } catch (error) {\n    if (error.message.includes('not a constructor')) {\n      worker = Impl(script);\n    }\n  }\n\n  if (!worker) {\n    throw new Error('Could not create Worker from', Impl);\n  }\n\n  observe(worker);\n  return worker;\n};","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/mortice/lib/index.js"],"names":["node","require","browser","Queue","default","timeout","observe","mutexes","implementation","createMutex","name","options","isWorker","readLock","writeLock","masterQueue","concurrency","readQueue","fn","add","autoStart","localReadQueue","readPromise","start","onIdle","then","defaultOptions","Infinity","global","singleProcess","module","exports","Object","assign","on","Worker","script","Impl","worker","error","message","includes","Error"],"mappings":"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","sourcesContent":["const node = require('./node')\nconst browser = require('./browser')\nconst { default: Queue } = require('p-queue')\nconst { timeout } = require('promise-timeout')\nconst observe = require('observable-webworkers')\n\nconst mutexes = {}\nlet implementation\n\nconst createMutex = (name, options) => {\n  if (implementation.isWorker) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    }\n  }\n\n  const masterQueue = new Queue({ concurrency: 1 })\n  let readQueue = null\n\n  return {\n    readLock: (fn) => {\n      // If there's already a read queue, just add the task to it\n      if (readQueue) {\n        return readQueue.add(() => timeout(fn(), options.timeout))\n      }\n\n      // Create a new read queue\n      readQueue = new Queue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = readQueue.add(() => timeout(fn(), options.timeout))\n\n      masterQueue.add(() => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        return localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return readPromise\n    },\n    writeLock: (fn) => {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return masterQueue.add(() => timeout(fn(), options.timeout))\n    }\n  }\n}\n\nconst defaultOptions = {\n  concurrency: Infinity,\n  timeout: 84600000,\n  global: global,\n  singleProcess: false\n}\n\nmodule.exports = (name, options) => {\n  if (!options) {\n    options = {}\n  }\n\n  if (typeof name === 'object') {\n    options = name\n    name = 'lock'\n  }\n\n  if (!name) {\n    name = 'lock'\n  }\n\n  options = Object.assign({}, defaultOptions, options)\n\n  if (!implementation) {\n    implementation = node(options) || browser(options)\n\n    if (!implementation.isWorker) {\n      // we are master, set up worker requests\n      implementation.on('requestReadLock', (name, fn) => {\n        mutexes[name] && mutexes[name].readLock(fn)\n      })\n\n      implementation.on('requestWriteLock', (name, fn) => {\n        mutexes[name] && mutexes[name].writeLock(fn)\n      })\n    }\n  }\n\n  if (!mutexes[name]) {\n    mutexes[name] = createMutex(name, options)\n  }\n\n  return mutexes[name]\n}\n\nmodule.exports.Worker = function (script, Impl) {\n  Impl = Impl || global.Worker\n  let worker\n\n  try {\n    worker = new Impl(script)\n  } catch (error) {\n    if (error.message.includes('not a constructor')) {\n      worker = Impl(script)\n    }\n  }\n\n  if (!worker) {\n    throw new Error('Could not create Worker from', Impl)\n  }\n\n  observe(worker)\n\n  return worker\n}\n"]},"metadata":{},"sourceType":"script"}