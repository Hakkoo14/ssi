{"ast":null,"code":"'use strict';\n\nvar promisify = require('promisify-es6');\n\nvar repoVersion = require('ipfs-repo').repoVersion;\n\nmodule.exports = function repo(self) {\n  return {\n    init: function init(bits, empty, callback) {// 1. check if repo already exists\n    },\n\n    /**\n     * If the repo has been initialized, report the current version.\n     * Otherwise report the version that would be initialized.\n     *\n     * @param {function(Error, Number)} [callback]\n     * @returns {undefined}\n     */\n    version: promisify(function (callback) {\n      self._repo._isInitialized(function (err) {\n        if (err) {\n          // TODO: (dryajov) This is really hacky, there must be a better way\n          var match = [/Key not found in database \\[\\/version\\]/, /ENOENT/, /repo is not initialized yet/].some(function (m) {\n            return m.test(err.message);\n          });\n\n          if (match) {\n            // this repo has not been initialized\n            return callback(null, repoVersion);\n          }\n\n          return callback(err);\n        }\n\n        self._repo.version.get(callback);\n      });\n    }),\n    gc: promisify(function (options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      callback(new Error('Not implemented'));\n    }),\n    stat: promisify(function (options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      self._repo.stat(options, function (err, stats) {\n        if (err) return callback(err);\n        callback(null, {\n          numObjects: stats.numObjects,\n          repoSize: stats.repoSize,\n          repoPath: stats.repoPath,\n          version: stats.version.toString(),\n          storageMax: stats.storageMax\n        });\n      });\n    }),\n    path: function path() {\n      return self._repo.path;\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs/src/core/components/repo.js"],"names":["promisify","require","repoVersion","module","exports","repo","self","init","bits","empty","callback","version","_repo","_isInitialized","err","match","some","m","test","message","get","gc","options","Error","stat","stats","numObjects","repoSize","repoPath","toString","storageMax","path"],"mappings":"AAAA;;AAEA,IAAMA,SAAS,GAAGC,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAMC,WAAW,GAAGD,OAAO,CAAC,WAAD,CAAP,CAAqBC,WAAzC;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,IAAT,CAAeC,IAAf,EAAqB;AACpC,SAAO;AACLC,IAAAA,IAAI,EAAE,cAACC,IAAD,EAAOC,KAAP,EAAcC,QAAd,EAA2B,CAC/B;AACD,KAHI;;AAKL;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,IAAAA,OAAO,EAAEX,SAAS,CAAC,UAACU,QAAD,EAAc;AAC/BJ,MAAAA,IAAI,CAACM,KAAL,CAAWC,cAAX,CAA0B,UAAAC,GAAG,EAAI;AAC/B,YAAIA,GAAJ,EAAS;AACP;AACA,cAAMC,KAAK,GAAG,CACZ,yCADY,EAEZ,QAFY,EAGZ,6BAHY,EAIZC,IAJY,CAIP,UAACC,CAAD,EAAO;AACZ,mBAAOA,CAAC,CAACC,IAAF,CAAOJ,GAAG,CAACK,OAAX,CAAP;AACD,WANa,CAAd;;AAOA,cAAIJ,KAAJ,EAAW;AACT;AACA,mBAAOL,QAAQ,CAAC,IAAD,EAAOR,WAAP,CAAf;AACD;;AACD,iBAAOQ,QAAQ,CAACI,GAAD,CAAf;AACD;;AAEDR,QAAAA,IAAI,CAACM,KAAL,CAAWD,OAAX,CAAmBS,GAAnB,CAAuBV,QAAvB;AACD,OAlBD;AAmBD,KApBiB,CAZb;AAkCLW,IAAAA,EAAE,EAAErB,SAAS,CAAC,UAACsB,OAAD,EAAUZ,QAAV,EAAuB;AACnC,UAAI,OAAOY,OAAP,KAAmB,UAAvB,EAAmC;AACjCZ,QAAAA,QAAQ,GAAGY,OAAX;AACAA,QAAAA,OAAO,GAAG,EAAV;AACD;;AAEDZ,MAAAA,QAAQ,CAAC,IAAIa,KAAJ,CAAU,iBAAV,CAAD,CAAR;AACD,KAPY,CAlCR;AA2CLC,IAAAA,IAAI,EAAExB,SAAS,CAAC,UAACsB,OAAD,EAAUZ,QAAV,EAAuB;AACrC,UAAI,OAAOY,OAAP,KAAmB,UAAvB,EAAmC;AACjCZ,QAAAA,QAAQ,GAAGY,OAAX;AACAA,QAAAA,OAAO,GAAG,EAAV;AACD;;AAEDhB,MAAAA,IAAI,CAACM,KAAL,CAAWY,IAAX,CAAgBF,OAAhB,EAAyB,UAACR,GAAD,EAAMW,KAAN,EAAgB;AACvC,YAAIX,GAAJ,EAAS,OAAOJ,QAAQ,CAACI,GAAD,CAAf;AAETJ,QAAAA,QAAQ,CAAC,IAAD,EAAO;AACbgB,UAAAA,UAAU,EAAED,KAAK,CAACC,UADL;AAEbC,UAAAA,QAAQ,EAAEF,KAAK,CAACE,QAFH;AAGbC,UAAAA,QAAQ,EAAEH,KAAK,CAACG,QAHH;AAIbjB,UAAAA,OAAO,EAAEc,KAAK,CAACd,OAAN,CAAckB,QAAd,EAJI;AAKbC,UAAAA,UAAU,EAAEL,KAAK,CAACK;AALL,SAAP,CAAR;AAOD,OAVD;AAWD,KAjBc,CA3CV;AA8DLC,IAAAA,IAAI,EAAE;AAAA,aAAMzB,IAAI,CAACM,KAAL,CAAWmB,IAAjB;AAAA;AA9DD,GAAP;AAgED,CAjED","sourcesContent":["'use strict'\n\nconst promisify = require('promisify-es6')\nconst repoVersion = require('ipfs-repo').repoVersion\n\nmodule.exports = function repo (self) {\n  return {\n    init: (bits, empty, callback) => {\n      // 1. check if repo already exists\n    },\n\n    /**\n     * If the repo has been initialized, report the current version.\n     * Otherwise report the version that would be initialized.\n     *\n     * @param {function(Error, Number)} [callback]\n     * @returns {undefined}\n     */\n    version: promisify((callback) => {\n      self._repo._isInitialized(err => {\n        if (err) {\n          // TODO: (dryajov) This is really hacky, there must be a better way\n          const match = [\n            /Key not found in database \\[\\/version\\]/,\n            /ENOENT/,\n            /repo is not initialized yet/\n          ].some((m) => {\n            return m.test(err.message)\n          })\n          if (match) {\n            // this repo has not been initialized\n            return callback(null, repoVersion)\n          }\n          return callback(err)\n        }\n\n        self._repo.version.get(callback)\n      })\n    }),\n\n    gc: promisify((options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      callback(new Error('Not implemented'))\n    }),\n\n    stat: promisify((options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      self._repo.stat(options, (err, stats) => {\n        if (err) return callback(err)\n\n        callback(null, {\n          numObjects: stats.numObjects,\n          repoSize: stats.repoSize,\n          repoPath: stats.repoPath,\n          version: stats.version.toString(),\n          storageMax: stats.storageMax\n        })\n      })\n    }),\n\n    path: () => self._repo.path\n  }\n}\n"]},"metadata":{},"sourceType":"script"}