{"ast":null,"code":"'use strict';\n\nvar promisify = require('promisify-es6');\n\nvar CID = require('cids');\n\nvar pull = require('pull-stream');\n\nvar iterToPull = require('async-iterator-to-pull-stream');\n\nvar mapAsync = require('async/map');\n\nvar setImmediate = require('async/setImmediate');\n\nvar flattenDeep = require('just-flatten-it');\n\nvar errCode = require('err-code');\n\nvar multicodec = require('multicodec');\n\nmodule.exports = function dag(self) {\n  return {\n    put: promisify(function (dagNode, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (options.cid && (options.format || options.hashAlg)) {\n        return callback(new Error('Can\\'t put dag node. Please provide either `cid` OR `format` and `hashAlg` options.'));\n      } else if (options.format && !options.hashAlg || !options.format && options.hashAlg) {\n        return callback(new Error('Can\\'t put dag node. Please provide `format` AND `hashAlg` options.'));\n      }\n\n      var optionDefaults = {\n        format: multicodec.DAG_CBOR,\n        hashAlg: multicodec.SHA2_256\n      }; // The IPLD expects the format and hashAlg as constants\n\n      if (options.format && typeof options.format === 'string') {\n        var constantName = options.format.toUpperCase().replace(/-/g, '_');\n        options.format = multicodec[constantName];\n      }\n\n      if (options.hashAlg && typeof options.hashAlg === 'string') {\n        var _constantName = options.hashAlg.toUpperCase().replace(/-/g, '_');\n\n        options.hashAlg = multicodec[_constantName];\n      }\n\n      options = options.cid ? options : Object.assign({}, optionDefaults, options); // js-ipld defaults to verion 1 CIDs. Hence set version 0 explicitly for\n      // dag-pb nodes\n\n      if (options.version === undefined) {\n        if (options.format === multicodec.DAG_PB && options.hashAlg === multicodec.SHA2_256) {\n          options.version = 0;\n        } else {\n          options.version = 1;\n        }\n      }\n\n      self._ipld.put(dagNode, options.format, {\n        hashAlg: options.hashAlg,\n        cidVersion: options.version\n      }).then(function (cid) {\n        if (options.preload !== false) {\n          self._preload(cid);\n        }\n\n        return callback(null, cid);\n      }, function (error) {\n        return callback(error);\n      });\n    }),\n    get: promisify(function (cid, path, options, callback) {\n      if (typeof path === 'function') {\n        callback = path;\n        path = undefined;\n      }\n\n      if (typeof options === 'function') {\n        callback = options; // Allow options in path position\n\n        if (typeof path !== 'string') {\n          options = path;\n          path = undefined;\n        } else {\n          options = {};\n        }\n      }\n\n      options = options || {};\n\n      if (typeof cid === 'string') {\n        var split = cid.split('/');\n\n        try {\n          cid = new CID(split[0]);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n\n        split.shift();\n\n        if (split.length > 0) {\n          path = split.join('/');\n        } else {\n          path = '/';\n        }\n      } else if (Buffer.isBuffer(cid)) {\n        try {\n          cid = new CID(cid);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      if (path === undefined || path === '/') {\n        self._ipld.get(cid).then(function (value) {\n          callback(null, {\n            value: value,\n            remainderPath: ''\n          });\n        }, function (error) {\n          return callback(error);\n        });\n      } else {\n        var result = self._ipld.resolve(cid, path);\n\n        var promisedValue = options.localResolve ? result.first() : result.last();\n        promisedValue.then(function (value) {\n          return callback(null, value);\n        }, function (error) {\n          return callback(error);\n        });\n      }\n    }),\n    tree: promisify(function (cid, path, options, callback) {\n      if (typeof path === 'object') {\n        callback = options;\n        options = path;\n        path = undefined;\n      }\n\n      if (typeof path === 'function') {\n        callback = path;\n        path = undefined;\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (typeof cid === 'string') {\n        var split = cid.split('/');\n\n        try {\n          cid = new CID(split[0]);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n\n        split.shift();\n\n        if (split.length > 0) {\n          path = split.join('/');\n        } else {\n          path = undefined;\n        }\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      pull(iterToPull(self._ipld.tree(cid, path, options)), pull.collect(callback));\n    }),\n    // TODO - use IPLD selectors once they are implemented\n    _getRecursive: promisify(function (multihash, options, callback) {\n      // gets flat array of all DAGNodes in tree given by multihash\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var cid;\n\n      try {\n        cid = new CID(multihash);\n      } catch (err) {\n        return setImmediate(function () {\n          return callback(errCode(err, 'ERR_INVALID_CID'));\n        });\n      }\n\n      self.dag.get(cid, '', options, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        mapAsync(res.value.Links, function (link, cb) {\n          self.dag._getRecursive(link.Hash, options, cb);\n        }, function (err, nodes) {\n          // console.log('nodes:', nodes)\n          if (err) return callback(err);\n          callback(null, flattenDeep([res.value, nodes]));\n        });\n      });\n    })\n  };\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs/src/core/components/dag.js"],"names":["promisify","require","CID","pull","iterToPull","mapAsync","setImmediate","flattenDeep","errCode","multicodec","module","exports","dag","self","put","dagNode","options","callback","cid","format","hashAlg","Error","optionDefaults","DAG_CBOR","SHA2_256","constantName","toUpperCase","replace","Object","assign","version","undefined","DAG_PB","_ipld","cidVersion","then","preload","_preload","error","get","path","split","err","shift","length","join","Buffer","isBuffer","value","remainderPath","result","resolve","promisedValue","localResolve","first","last","tree","collect","_getRecursive","multihash","res","Links","link","cb","Hash","nodes"],"mappings":"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","sourcesContent":["'use strict'\n\nconst promisify = require('promisify-es6')\nconst CID = require('cids')\nconst pull = require('pull-stream')\nconst iterToPull = require('async-iterator-to-pull-stream')\nconst mapAsync = require('async/map')\nconst setImmediate = require('async/setImmediate')\nconst flattenDeep = require('just-flatten-it')\nconst errCode = require('err-code')\nconst multicodec = require('multicodec')\n\nmodule.exports = function dag (self) {\n  return {\n    put: promisify((dagNode, options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      options = options || {}\n\n      if (options.cid && (options.format || options.hashAlg)) {\n        return callback(new Error('Can\\'t put dag node. Please provide either `cid` OR `format` and `hashAlg` options.'))\n      } else if (((options.format && !options.hashAlg) || (!options.format && options.hashAlg))) {\n        return callback(new Error('Can\\'t put dag node. Please provide `format` AND `hashAlg` options.'))\n      }\n\n      const optionDefaults = {\n        format: multicodec.DAG_CBOR,\n        hashAlg: multicodec.SHA2_256\n      }\n\n      // The IPLD expects the format and hashAlg as constants\n      if (options.format && typeof options.format === 'string') {\n        const constantName = options.format.toUpperCase().replace(/-/g, '_')\n        options.format = multicodec[constantName]\n      }\n      if (options.hashAlg && typeof options.hashAlg === 'string') {\n        const constantName = options.hashAlg.toUpperCase().replace(/-/g, '_')\n        options.hashAlg = multicodec[constantName]\n      }\n\n      options = options.cid ? options : Object.assign({}, optionDefaults, options)\n\n      // js-ipld defaults to verion 1 CIDs. Hence set version 0 explicitly for\n      // dag-pb nodes\n      if (options.version === undefined) {\n        if (options.format === multicodec.DAG_PB && options.hashAlg === multicodec.SHA2_256) {\n          options.version = 0\n        } else {\n          options.version = 1\n        }\n      }\n\n      self._ipld.put(dagNode, options.format, {\n        hashAlg: options.hashAlg,\n        cidVersion: options.version\n      }).then(\n        (cid) => {\n          if (options.preload !== false) {\n            self._preload(cid)\n          }\n          return callback(null, cid)\n        },\n        (error) => callback(error)\n      )\n    }),\n\n    get: promisify((cid, path, options, callback) => {\n      if (typeof path === 'function') {\n        callback = path\n        path = undefined\n      }\n\n      if (typeof options === 'function') {\n        callback = options\n\n        // Allow options in path position\n        if (typeof path !== 'string') {\n          options = path\n          path = undefined\n        } else {\n          options = {}\n        }\n      }\n\n      options = options || {}\n\n      if (typeof cid === 'string') {\n        const split = cid.split('/')\n\n        try {\n          cid = new CID(split[0])\n        } catch (err) {\n          return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))\n        }\n\n        split.shift()\n\n        if (split.length > 0) {\n          path = split.join('/')\n        } else {\n          path = '/'\n        }\n      } else if (Buffer.isBuffer(cid)) {\n        try {\n          cid = new CID(cid)\n        } catch (err) {\n          return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))\n        }\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid)\n      }\n\n      if (path === undefined || path === '/') {\n        self._ipld.get(cid).then(\n          (value) => {\n            callback(null, {\n              value,\n              remainderPath: ''\n            })\n          },\n          (error) => callback(error)\n        )\n      } else {\n        const result = self._ipld.resolve(cid, path)\n        const promisedValue = options.localResolve ? result.first() : result.last()\n        promisedValue.then(\n          (value) => callback(null, value),\n          (error) => callback(error)\n        )\n      }\n    }),\n\n    tree: promisify((cid, path, options, callback) => {\n      if (typeof path === 'object') {\n        callback = options\n        options = path\n        path = undefined\n      }\n\n      if (typeof path === 'function') {\n        callback = path\n        path = undefined\n      }\n\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      options = options || {}\n\n      if (typeof cid === 'string') {\n        const split = cid.split('/')\n\n        try {\n          cid = new CID(split[0])\n        } catch (err) {\n          return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))\n        }\n\n        split.shift()\n\n        if (split.length > 0) {\n          path = split.join('/')\n        } else {\n          path = undefined\n        }\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid)\n      }\n\n      pull(\n        iterToPull(self._ipld.tree(cid, path, options)),\n        pull.collect(callback)\n      )\n    }),\n\n    // TODO - use IPLD selectors once they are implemented\n    _getRecursive: promisify((multihash, options, callback) => {\n      // gets flat array of all DAGNodes in tree given by multihash\n\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      options = options || {}\n\n      let cid\n\n      try {\n        cid = new CID(multihash)\n      } catch (err) {\n        return setImmediate(() => callback(errCode(err, 'ERR_INVALID_CID')))\n      }\n\n      self.dag.get(cid, '', options, (err, res) => {\n        if (err) { return callback(err) }\n\n        mapAsync(res.value.Links, (link, cb) => {\n          self.dag._getRecursive(link.Hash, options, cb)\n        }, (err, nodes) => {\n          // console.log('nodes:', nodes)\n          if (err) return callback(err)\n          callback(null, flattenDeep([res.value, nodes]))\n        })\n      })\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}