{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar mkdir = require('./mkdir');\n\nvar log = require('debug')('ipfs:mfs:cp');\n\nvar errCode = require('err-code');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar addLink = require('./utils/add-link');\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar toSourcesAndDestination = require('./utils/to-sources-and-destination');\n\nvar toTrail = require('./utils/to-trail');\n\nvar defaultOptions = {\n  parents: false,\n  flush: true,\n  format: 'dag-pb',\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n};\n\nmodule.exports = function (context) {\n  return /*#__PURE__*/function () {\n    var _mfsCp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _len,\n          args,\n          _key,\n          options,\n          _yield$toSourcesAndDe,\n          sources,\n          destination,\n          missing,\n          destinationIsDirectory,\n          destinationPath,\n          trail,\n          source,\n          destinationName,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = _args[_key];\n              }\n\n              options = applyDefaultOptions(args, defaultOptions);\n              _context.next = 4;\n              return toSourcesAndDestination(context, args);\n\n            case 4:\n              _yield$toSourcesAndDe = _context.sent;\n              sources = _yield$toSourcesAndDe.sources;\n              destination = _yield$toSourcesAndDe.destination;\n\n              if (sources.length) {\n                _context.next = 9;\n                break;\n              }\n\n              throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');\n\n            case 9:\n              if (destination) {\n                _context.next = 11;\n                break;\n              }\n\n              throw errCode(new Error('Please supply a destination'), 'ERR_INVALID_PARAMS');\n\n            case 11:\n              options.parents = options.p || options.parents; // make sure all sources exist\n\n              missing = sources.find(function (source) {\n                return !source.exists;\n              });\n\n              if (!missing) {\n                _context.next = 15;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(missing.path, \" does not exist\")), 'ERR_INVALID_PARAMS');\n\n            case 15:\n              destinationIsDirectory = isDirectory(destination);\n\n              if (!destination.exists) {\n                _context.next = 22;\n                break;\n              }\n\n              log('Destination exists');\n\n              if (!(sources.length === 1 && !destinationIsDirectory)) {\n                _context.next = 20;\n                break;\n              }\n\n              throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');\n\n            case 20:\n              _context.next = 31;\n              break;\n\n            case 22:\n              log('Destination does not exist');\n\n              if (!(sources.length > 1)) {\n                _context.next = 31;\n                break;\n              }\n\n              if (options.parents) {\n                _context.next = 26;\n                break;\n              }\n\n              throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n\n            case 26:\n              _context.next = 28;\n              return mkdir(context)(destination.path, options);\n\n            case 28:\n              _context.next = 30;\n              return toMfsPath(context, destination.path);\n\n            case 30:\n              destination = _context.sent;\n\n            case 31:\n              destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;\n              _context.next = 34;\n              return toTrail(context, destinationPath, options);\n\n            case 34:\n              trail = _context.sent;\n\n              if (!(sources.length === 1)) {\n                _context.next = 40;\n                break;\n              }\n\n              source = sources.pop();\n              destinationName = destinationIsDirectory ? source.name : destination.name;\n              log(\"Only one source, copying to destination \".concat(destinationIsDirectory ? 'directory' : 'file', \" \").concat(destinationName));\n              return _context.abrupt(\"return\", copyToFile(context, source, destinationName, trail, options));\n\n            case 40:\n              log('Multiple sources, wrapping in a directory');\n              return _context.abrupt(\"return\", copyToDirectory(context, sources, destination, trail, options));\n\n            case 42:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function mfsCp() {\n      return _mfsCp.apply(this, arguments);\n    }\n\n    return mfsCp;\n  }();\n};\n\nvar isDirectory = function isDirectory(destination) {\n  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');\n};\n\nvar copyToFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, source, destination, destinationTrail, options) {\n    var parent, newRootCid;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            parent = destinationTrail.pop();\n            _context2.next = 3;\n            return addSourceToParent(context, source, destination, parent, options);\n\n          case 3:\n            parent = _context2.sent;\n            // update the tree with the new containg directory\n            destinationTrail.push(parent);\n            _context2.next = 7;\n            return updateTree(context, destinationTrail, options);\n\n          case 7:\n            newRootCid = _context2.sent;\n            _context2.next = 10;\n            return updateMfsRoot(context, newRootCid);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function copyToFile(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar copyToDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(context, sources, destination, destinationTrail, options) {\n    var i, source, newRootCid;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < sources.length)) {\n              _context3.next = 9;\n              break;\n            }\n\n            source = sources[i];\n            _context3.next = 5;\n            return addSourceToParent(context, source, source.name, destination, options);\n\n          case 5:\n            destination = _context3.sent;\n\n          case 6:\n            i++;\n            _context3.next = 1;\n            break;\n\n          case 9:\n            // update the tree with the new containg directory\n            destinationTrail[destinationTrail.length - 1] = destination;\n            _context3.next = 12;\n            return updateTree(context, destinationTrail, options);\n\n          case 12:\n            newRootCid = _context3.sent;\n            _context3.next = 15;\n            return updateMfsRoot(context, newRootCid);\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function copyToDirectory(_x6, _x7, _x8, _x9, _x10) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar addSourceToParent = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(context, source, childName, parent, options) {\n    var sourceBlock, _yield$addLink, node, cid;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return context.repo.blocks.get(source.cid);\n\n          case 2:\n            sourceBlock = _context4.sent;\n            _context4.next = 5;\n            return addLink(context, {\n              parentCid: parent.cid,\n              size: sourceBlock.data.length,\n              cid: source.cid,\n              name: childName,\n              format: options.format,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion\n            });\n\n          case 5:\n            _yield$addLink = _context4.sent;\n            node = _yield$addLink.node;\n            cid = _yield$addLink.cid;\n            parent.node = node;\n            parent.cid = cid;\n            parent.size = node.size;\n            return _context4.abrupt(\"return\", parent);\n\n          case 12:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function addSourceToParent(_x11, _x12, _x13, _x14, _x15) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs-mfs/src/core/cp.js"],"names":["mkdir","require","log","errCode","updateTree","updateMfsRoot","addLink","applyDefaultOptions","toMfsPath","toSourcesAndDestination","toTrail","defaultOptions","parents","flush","format","hashAlg","cidVersion","shardSplitThreshold","module","exports","context","args","options","sources","destination","length","Error","p","missing","find","source","exists","path","destinationIsDirectory","isDirectory","destinationPath","mfsPath","mfsDirectory","trail","pop","destinationName","name","copyToFile","copyToDirectory","mfsCp","unixfs","type","includes","destinationTrail","parent","addSourceToParent","push","newRootCid","i","childName","repo","blocks","get","cid","sourceBlock","parentCid","size","data","node"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mkdir = require('./mkdir')\nconst log = require('debug')('ipfs:mfs:cp')\nconst errCode = require('err-code')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst addLink = require('./utils/add-link')\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst toSourcesAndDestination = require('./utils/to-sources-and-destination')\nconst toTrail = require('./utils/to-trail')\n\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  format: 'dag-pb',\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n}\n\nmodule.exports = (context) => {\n  return async function mfsCp (...args) {\n    const options = applyDefaultOptions(args, defaultOptions)\n    let {\n      sources, destination\n    } = await toSourcesAndDestination(context, args)\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS')\n    }\n\n    if (!destination) {\n      throw errCode(new Error('Please supply a destination'), 'ERR_INVALID_PARAMS')\n    }\n\n    options.parents = options.p || options.parents\n\n    // make sure all sources exist\n    const missing = sources.find(source => !source.exists)\n\n    if (missing) {\n      throw errCode(new Error(`${missing.path} does not exist`), 'ERR_INVALID_PARAMS')\n    }\n\n    const destinationIsDirectory = isDirectory(destination)\n\n    if (destination.exists) {\n      log('Destination exists')\n\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS')\n      }\n    } else {\n      log('Destination does not exist')\n\n      if (sources.length > 1) {\n        if (!options.parents) {\n          throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n        }\n\n        await mkdir(context)(destination.path, options)\n        destination = await toMfsPath(context, destination.path)\n      }\n    }\n\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory\n    const trail = await toTrail(context, destinationPath, options)\n\n    if (sources.length === 1) {\n      const source = sources.pop()\n      const destinationName = destinationIsDirectory ? source.name : destination.name\n\n      log(`Only one source, copying to destination ${destinationIsDirectory ? 'directory' : 'file'} ${destinationName}`)\n\n      return copyToFile(context, source, destinationName, trail, options)\n    }\n\n    log('Multiple sources, wrapping in a directory')\n    return copyToDirectory(context, sources, destination, trail, options)\n  }\n}\n\nconst isDirectory = (destination) => {\n  return destination.unixfs &&\n    destination.unixfs.type &&\n    destination.unixfs.type.includes('directory')\n}\n\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop()\n\n  parent = await addSourceToParent(context, source, destination, parent, options)\n\n  // update the tree with the new containg directory\n  destinationTrail.push(parent)\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid)\n}\n\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  // copy all the sources to the destination\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i]\n\n    destination = await addSourceToParent(context, source, source.name, destination, options)\n  }\n\n  // update the tree with the new containg directory\n  destinationTrail[destinationTrail.length - 1] = destination\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid)\n}\n\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid)\n\n  const {\n    node,\n    cid\n  } = await addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.data.length,\n    cid: source.cid,\n    name: childName,\n    format: options.format,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion\n  })\n\n  parent.node = node\n  parent.cid = cid\n  parent.size = node.size\n\n  return parent\n}\n"]},"metadata":{},"sourceType":"script"}