{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncIterator = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _awaitAsyncGenerator = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar errCode = require('err-code');\n\nvar CID = require('cids');\n\nvar resolve = require('./resolvers');\n\nvar last = require('async-iterator-last');\n\nvar toPathComponents = function toPathComponents() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  // split on / unless escaped with \\\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n\nvar cidAndRest = function cidAndRest(path) {\n  if (Buffer.isBuffer(path)) {\n    return {\n      cid: new CID(path),\n      toResolve: []\n    };\n  }\n\n  if (CID.isCID(path)) {\n    return {\n      cid: path,\n      toResolve: []\n    };\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n\n    var output = toPathComponents(path);\n    return {\n      cid: new CID(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n\n  throw errCode(new Error(\"Unknown path type \".concat(path)), 'ERR_BAD_PATH');\n};\n\nvar walkPath = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, ipld) {\n    var _cidAndRest, cid, toResolve, name, entryPath, startingDepth, result;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _cidAndRest = cidAndRest(path), cid = _cidAndRest.cid, toResolve = _cidAndRest.toResolve;\n            name = cid.toBaseEncodedString();\n            entryPath = name;\n            startingDepth = toResolve.length;\n\n          case 4:\n            if (!true) {\n              _context.next = 21;\n              break;\n            }\n\n            _context.next = 7;\n            return _awaitAsyncGenerator(resolve(cid, name, entryPath, toResolve, startingDepth, ipld));\n\n          case 7:\n            result = _context.sent;\n\n            if (!(!result.entry && !result.next)) {\n              _context.next = 10;\n              break;\n            }\n\n            throw errCode(new Error(\"Could not resolve \".concat(path)), 'ERR_NOT_FOUND');\n\n          case 10:\n            if (!result.entry) {\n              _context.next = 13;\n              break;\n            }\n\n            _context.next = 13;\n            return result.entry;\n\n          case 13:\n            if (result.next) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 15:\n            // resolve further parts\n            toResolve = result.next.toResolve;\n            cid = result.next.cid;\n            name = result.next.name;\n            entryPath = result.next.path;\n            _context.next = 4;\n            break;\n\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function walkPath(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar exporter = function exporter(path, ipld) {\n  return last(walkPath(path, ipld));\n};\n\nvar recursive = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(path, ipld) {\n    var node, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, child, recurse, _recurse;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _recurse = function _recurse3() {\n              _recurse = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(node) {\n                var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, file, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, subFile;\n\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _iteratorNormalCompletion2 = true;\n                        _didIteratorError2 = false;\n                        _context2.prev = 2;\n                        _iterator2 = _asyncIterator(node.content());\n\n                      case 4:\n                        _context2.next = 6;\n                        return _awaitAsyncGenerator(_iterator2.next());\n\n                      case 6:\n                        _step2 = _context2.sent;\n                        _iteratorNormalCompletion2 = _step2.done;\n                        _context2.next = 10;\n                        return _awaitAsyncGenerator(_step2.value);\n\n                      case 10:\n                        _value2 = _context2.sent;\n\n                        if (_iteratorNormalCompletion2) {\n                          _context2.next = 53;\n                          break;\n                        }\n\n                        file = _value2;\n                        _context2.next = 15;\n                        return file;\n\n                      case 15:\n                        if (!file.unixfs.type.includes('dir')) {\n                          _context2.next = 50;\n                          break;\n                        }\n\n                        _iteratorNormalCompletion3 = true;\n                        _didIteratorError3 = false;\n                        _context2.prev = 18;\n                        _iterator3 = _asyncIterator(recurse(file));\n\n                      case 20:\n                        _context2.next = 22;\n                        return _awaitAsyncGenerator(_iterator3.next());\n\n                      case 22:\n                        _step3 = _context2.sent;\n                        _iteratorNormalCompletion3 = _step3.done;\n                        _context2.next = 26;\n                        return _awaitAsyncGenerator(_step3.value);\n\n                      case 26:\n                        _value3 = _context2.sent;\n\n                        if (_iteratorNormalCompletion3) {\n                          _context2.next = 34;\n                          break;\n                        }\n\n                        subFile = _value3;\n                        _context2.next = 31;\n                        return subFile;\n\n                      case 31:\n                        _iteratorNormalCompletion3 = true;\n                        _context2.next = 20;\n                        break;\n\n                      case 34:\n                        _context2.next = 40;\n                        break;\n\n                      case 36:\n                        _context2.prev = 36;\n                        _context2.t0 = _context2[\"catch\"](18);\n                        _didIteratorError3 = true;\n                        _iteratorError3 = _context2.t0;\n\n                      case 40:\n                        _context2.prev = 40;\n                        _context2.prev = 41;\n\n                        if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {\n                          _context2.next = 45;\n                          break;\n                        }\n\n                        _context2.next = 45;\n                        return _awaitAsyncGenerator(_iterator3.return());\n\n                      case 45:\n                        _context2.prev = 45;\n\n                        if (!_didIteratorError3) {\n                          _context2.next = 48;\n                          break;\n                        }\n\n                        throw _iteratorError3;\n\n                      case 48:\n                        return _context2.finish(45);\n\n                      case 49:\n                        return _context2.finish(40);\n\n                      case 50:\n                        _iteratorNormalCompletion2 = true;\n                        _context2.next = 4;\n                        break;\n\n                      case 53:\n                        _context2.next = 59;\n                        break;\n\n                      case 55:\n                        _context2.prev = 55;\n                        _context2.t1 = _context2[\"catch\"](2);\n                        _didIteratorError2 = true;\n                        _iteratorError2 = _context2.t1;\n\n                      case 59:\n                        _context2.prev = 59;\n                        _context2.prev = 60;\n\n                        if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                          _context2.next = 64;\n                          break;\n                        }\n\n                        _context2.next = 64;\n                        return _awaitAsyncGenerator(_iterator2.return());\n\n                      case 64:\n                        _context2.prev = 64;\n\n                        if (!_didIteratorError2) {\n                          _context2.next = 67;\n                          break;\n                        }\n\n                        throw _iteratorError2;\n\n                      case 67:\n                        return _context2.finish(64);\n\n                      case 68:\n                        return _context2.finish(59);\n\n                      case 69:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2, null, [[2, 55, 59, 69], [18, 36, 40, 50], [41,, 45, 49], [60,, 64, 68]]);\n              }));\n              return _recurse.apply(this, arguments);\n            };\n\n            recurse = function _recurse2(_x5) {\n              return _recurse.apply(this, arguments);\n            };\n\n            _context3.next = 4;\n            return _awaitAsyncGenerator(exporter(path, ipld));\n\n          case 4:\n            node = _context3.sent;\n            _context3.next = 7;\n            return node;\n\n          case 7:\n            if (!(node.unixfs && node.unixfs.type.includes('dir'))) {\n              _context3.next = 42;\n              break;\n            }\n\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context3.prev = 10;\n            _iterator = _asyncIterator(recurse(node));\n\n          case 12:\n            _context3.next = 14;\n            return _awaitAsyncGenerator(_iterator.next());\n\n          case 14:\n            _step = _context3.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context3.next = 18;\n            return _awaitAsyncGenerator(_step.value);\n\n          case 18:\n            _value = _context3.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context3.next = 26;\n              break;\n            }\n\n            child = _value;\n            _context3.next = 23;\n            return child;\n\n          case 23:\n            _iteratorNormalCompletion = true;\n            _context3.next = 12;\n            break;\n\n          case 26:\n            _context3.next = 32;\n            break;\n\n          case 28:\n            _context3.prev = 28;\n            _context3.t0 = _context3[\"catch\"](10);\n            _didIteratorError = true;\n            _iteratorError = _context3.t0;\n\n          case 32:\n            _context3.prev = 32;\n            _context3.prev = 33;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context3.next = 37;\n              break;\n            }\n\n            _context3.next = 37;\n            return _awaitAsyncGenerator(_iterator.return());\n\n          case 37:\n            _context3.prev = 37;\n\n            if (!_didIteratorError) {\n              _context3.next = 40;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 40:\n            return _context3.finish(37);\n\n          case 41:\n            return _context3.finish(32);\n\n          case 42:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[10, 28, 32, 42], [33,, 37, 41]]);\n  }));\n\n  return function recursive(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nmodule.exports = exporter;\nmodule.exports.path = walkPath;\nmodule.exports.recursive = recursive;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/ipfs-unixfs-exporter/src/index.js"],"names":["errCode","require","CID","resolve","last","toPathComponents","path","trim","match","filter","Boolean","cidAndRest","Buffer","isBuffer","cid","toResolve","isCID","indexOf","substring","output","slice","Error","walkPath","ipld","name","toBaseEncodedString","entryPath","startingDepth","length","result","entry","next","exporter","recursive","recurse","node","content","file","unixfs","type","includes","subFile","child","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst CID = require('cids')\nconst resolve = require('./resolvers')\nconst last = require('async-iterator-last')\n\nconst toPathComponents = (path = '') => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) || [])\n    .filter(Boolean)\n}\n\nconst cidAndRest = (path) => {\n  if (Buffer.isBuffer(path)) {\n    return {\n      cid: new CID(path),\n      toResolve: []\n    }\n  }\n\n  if (CID.isCID(path)) {\n    return {\n      cid: path,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: new CID(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH')\n}\n\nconst walkPath = async function * (path, ipld) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toBaseEncodedString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, ipld)\n\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND')\n    }\n\n    if (result.entry) {\n      yield result.entry\n    }\n\n    if (!result.next) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\nconst exporter = (path, ipld) => {\n  return last(walkPath(path, ipld))\n}\n\nconst recursive = async function * (path, ipld) {\n  const node = await exporter(path, ipld)\n\n  yield node\n\n  if (node.unixfs && node.unixfs.type.includes('dir')) {\n    for await (const child of recurse(node)) {\n      yield child\n    }\n  }\n\n  async function * recurse (node) {\n    for await (const file of node.content()) {\n      yield file\n\n      if (file.unixfs.type.includes('dir')) {\n        for await (const subFile of recurse(file)) {\n          yield subFile\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = exporter\nmodule.exports.path = walkPath\nmodule.exports.recursive = recursive\n"]},"metadata":{},"sourceType":"script"}