{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pull = require('pull-stream');\n\nvar timeout = require('async/timeout');\n\nvar lp = require('pull-length-prefixed');\n\nvar setImmediate = require('async/setImmediate');\n\nvar errcode = require('err-code');\n\nvar rpc = require('./rpc');\n\nvar c = require('./constants');\n\nvar Message = require('./message');\n\nvar utils = require('./utils');\n/**\n * Handle network operations for the dht\n */\n\n\nvar Network = /*#__PURE__*/function () {\n  /**\n   * Create a new network.\n   *\n   * @param {KadDHT} self\n   */\n  function Network(self) {\n    _classCallCheck(this, Network);\n\n    this.dht = self;\n    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT;\n    this._log = utils.logger(this.dht.peerInfo.id, 'net');\n    this._rpc = rpc(this.dht);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._running = false;\n  }\n  /**\n   * Start the network.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(Network, [{\n    key: \"start\",\n    value: function start(callback) {\n      var cb = function cb(err) {\n        return setImmediate(function () {\n          return callback(err);\n        });\n      };\n\n      if (this._running) {\n        return cb(errcode(new Error('Network is already running'), 'ERR_NETWORK_ALREADY_RUNNING'));\n      } // TODO add a way to check if switch has started or not\n\n\n      if (!this.dht.isStarted) {\n        return cb(errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK'));\n      }\n\n      this._running = true; // handle incoming connections\n\n      this.dht.switch.handle(c.PROTOCOL_DHT, this._rpc); // handle new connections\n\n      this.dht.switch.on('peer-mux-established', this._onPeerConnected);\n      cb();\n    }\n    /**\n     * Stop all network activity.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var cb = function cb(err) {\n        return setImmediate(function () {\n          return callback(err);\n        });\n      };\n\n      if (!this.dht.isStarted && !this.isStarted) {\n        return cb(errcode(new Error('Network is already stopped'), 'ERR_NETWORK_ALREADY_STOPPED'));\n      }\n\n      this._running = false;\n      this.dht.switch.removeListener('peer-mux-established', this._onPeerConnected);\n      this.dht.switch.unhandle(c.PROTOCOL_DHT);\n      cb();\n    }\n    /**\n     * Is the network online?\n     *\n     * @type {bool}\n     */\n\n  }, {\n    key: \"isStarted\",\n    get: function get() {\n      return this._running;\n    }\n    /**\n     * Are all network components there?\n     *\n     * @type {bool}\n     */\n\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      // TODO add a way to check if switch has started or not\n      return this.dht.isStarted && this.isStarted;\n    }\n    /**\n     * Handle new connections in the switch.\n     *\n     * @param {PeerInfo} peer\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function _onPeerConnected(peer) {\n      var _this = this;\n\n      if (!this.isConnected) {\n        return this._log.error('Network is offline');\n      }\n\n      this.dht.switch.dial(peer, c.PROTOCOL_DHT, function (err, conn) {\n        if (err) {\n          return _this._log('%s does not support protocol: %s', peer.id.toB58String(), c.PROTOCOL_DHT);\n        } // TODO: conn.close()\n\n\n        pull(pull.empty(), conn);\n\n        _this.dht._add(peer, function (err) {\n          if (err) {\n            return _this._log.error('Failed to add to the routing table', err);\n          }\n\n          _this._log('added to the routing table: %s', peer.id.toB58String());\n        });\n      });\n    }\n    /**\n     * Send a request and record RTT for latency measurements.\n     *\n     * @param {PeerId} to - The peer that should receive a message\n     * @param {Message} msg - The message to send.\n     * @param {function(Error, Message)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"sendRequest\",\n    value: function sendRequest(to, msg, callback) {\n      var _this2 = this;\n\n      // TODO: record latency\n      if (!this.isConnected) {\n        return callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE'));\n      }\n\n      this._log('sending to: %s', to.toB58String());\n\n      this.dht.switch.dial(to, c.PROTOCOL_DHT, function (err, conn) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this2._writeReadMessage(conn, msg.serialize(), callback);\n      });\n    }\n    /**\n     * Sends a message without expecting an answer.\n     *\n     * @param {PeerId} to\n     * @param {Message} msg\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(to, msg, callback) {\n      var _this3 = this;\n\n      if (!this.isConnected) {\n        return setImmediate(function () {\n          return callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE'));\n        });\n      }\n\n      this._log('sending to: %s', to.toB58String());\n\n      this.dht.switch.dial(to, c.PROTOCOL_DHT, function (err, conn) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this3._writeMessage(conn, msg.serialize(), callback);\n      });\n    }\n    /**\n     * Write a message and read its response.\n     * If no response is received after the specified timeout\n     * this will error out.\n     *\n     * @param {Connection} conn - the connection to use\n     * @param {Buffer} msg - the message to send\n     * @param {function(Error, Message)} callback\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_writeReadMessage\",\n    value: function _writeReadMessage(conn, msg, callback) {\n      timeout(writeReadMessage, this.readMessageTimeout)(conn, msg, callback);\n    }\n    /**\n     * Write a message to the given connection.\n     *\n     * @param {Connection} conn - the connection to use\n     * @param {Buffer} msg - the message to send\n     * @param {function(Error)} callback\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_writeMessage\",\n    value: function _writeMessage(conn, msg, callback) {\n      pull(pull.values([msg]), lp.encode(), conn, pull.onEnd(callback));\n    }\n  }]);\n\n  return Network;\n}();\n\nfunction writeReadMessage(conn, msg, callback) {\n  pull(pull.values([msg]), lp.encode(), conn, pull.filter(function (msg) {\n    return msg.length < c.maxMessageSize;\n  }), lp.decode(), pull.collect(function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (res.length === 0) {\n      return callback(errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED'));\n    }\n\n    var response;\n\n    try {\n      response = Message.deserialize(res[0]);\n    } catch (err) {\n      return callback(errcode(err, 'ERR_FAILED_DESERIALIZE_RESPONSE'));\n    }\n\n    callback(null, response);\n  }));\n}\n\nmodule.exports = Network;","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/libp2p-kad-dht/src/network.js"],"names":["pull","require","timeout","lp","setImmediate","errcode","rpc","c","Message","utils","Network","self","dht","readMessageTimeout","READ_MESSAGE_TIMEOUT","_log","logger","peerInfo","id","_rpc","_onPeerConnected","bind","_running","callback","cb","err","Error","isStarted","switch","handle","PROTOCOL_DHT","on","removeListener","unhandle","peer","isConnected","error","dial","conn","toB58String","empty","_add","to","msg","_writeReadMessage","serialize","_writeMessage","writeReadMessage","values","encode","onEnd","filter","length","maxMessageSize","decode","collect","res","response","deserialize","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream')\nconst timeout = require('async/timeout')\nconst lp = require('pull-length-prefixed')\nconst setImmediate = require('async/setImmediate')\n\nconst errcode = require('err-code')\n\nconst rpc = require('./rpc')\nconst c = require('./constants')\nconst Message = require('./message')\nconst utils = require('./utils')\n\n/**\n * Handle network operations for the dht\n */\nclass Network {\n  /**\n   * Create a new network.\n   *\n   * @param {KadDHT} self\n   */\n  constructor (self) {\n    this.dht = self\n    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT\n    this._log = utils.logger(this.dht.peerInfo.id, 'net')\n    this._rpc = rpc(this.dht)\n    this._onPeerConnected = this._onPeerConnected.bind(this)\n    this._running = false\n  }\n\n  /**\n   * Start the network.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  start (callback) {\n    const cb = (err) => setImmediate(() => callback(err))\n\n    if (this._running) {\n      return cb(errcode(new Error('Network is already running'), 'ERR_NETWORK_ALREADY_RUNNING'))\n    }\n\n    // TODO add a way to check if switch has started or not\n    if (!this.dht.isStarted) {\n      return cb(errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK'))\n    }\n\n    this._running = true\n\n    // handle incoming connections\n    this.dht.switch.handle(c.PROTOCOL_DHT, this._rpc)\n\n    // handle new connections\n    this.dht.switch.on('peer-mux-established', this._onPeerConnected)\n\n    cb()\n  }\n\n  /**\n   * Stop all network activity.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  stop (callback) {\n    const cb = (err) => setImmediate(() => callback(err))\n\n    if (!this.dht.isStarted && !this.isStarted) {\n      return cb(errcode(new Error('Network is already stopped'), 'ERR_NETWORK_ALREADY_STOPPED'))\n    }\n    this._running = false\n    this.dht.switch.removeListener('peer-mux-established', this._onPeerConnected)\n\n    this.dht.switch.unhandle(c.PROTOCOL_DHT)\n    cb()\n  }\n\n  /**\n   * Is the network online?\n   *\n   * @type {bool}\n   */\n  get isStarted () {\n    return this._running\n  }\n\n  /**\n   * Are all network components there?\n   *\n   * @type {bool}\n   */\n  get isConnected () {\n    // TODO add a way to check if switch has started or not\n    return this.dht.isStarted && this.isStarted\n  }\n\n  /**\n   * Handle new connections in the switch.\n   *\n   * @param {PeerInfo} peer\n   * @returns {void}\n   * @private\n   */\n  _onPeerConnected (peer) {\n    if (!this.isConnected) {\n      return this._log.error('Network is offline')\n    }\n\n    this.dht.switch.dial(peer, c.PROTOCOL_DHT, (err, conn) => {\n      if (err) {\n        return this._log('%s does not support protocol: %s', peer.id.toB58String(), c.PROTOCOL_DHT)\n      }\n\n      // TODO: conn.close()\n      pull(pull.empty(), conn)\n\n      this.dht._add(peer, (err) => {\n        if (err) {\n          return this._log.error('Failed to add to the routing table', err)\n        }\n\n        this._log('added to the routing table: %s', peer.id.toB58String())\n      })\n    })\n  }\n\n  /**\n   * Send a request and record RTT for latency measurements.\n   *\n   * @param {PeerId} to - The peer that should receive a message\n   * @param {Message} msg - The message to send.\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   */\n  sendRequest (to, msg, callback) {\n    // TODO: record latency\n    if (!this.isConnected) {\n      return callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE'))\n    }\n\n    this._log('sending to: %s', to.toB58String())\n    this.dht.switch.dial(to, c.PROTOCOL_DHT, (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n\n      this._writeReadMessage(conn, msg.serialize(), callback)\n    })\n  }\n\n  /**\n   * Sends a message without expecting an answer.\n   *\n   * @param {PeerId} to\n   * @param {Message} msg\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  sendMessage (to, msg, callback) {\n    if (!this.isConnected) {\n      return setImmediate(() => callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE')))\n    }\n\n    this._log('sending to: %s', to.toB58String())\n\n    this.dht.switch.dial(to, c.PROTOCOL_DHT, (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n\n      this._writeMessage(conn, msg.serialize(), callback)\n    })\n  }\n\n  /**\n   * Write a message and read its response.\n   * If no response is received after the specified timeout\n   * this will error out.\n   *\n   * @param {Connection} conn - the connection to use\n   * @param {Buffer} msg - the message to send\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   * @private\n   */\n  _writeReadMessage (conn, msg, callback) {\n    timeout(\n      writeReadMessage,\n      this.readMessageTimeout\n    )(conn, msg, callback)\n  }\n\n  /**\n   * Write a message to the given connection.\n   *\n   * @param {Connection} conn - the connection to use\n   * @param {Buffer} msg - the message to send\n   * @param {function(Error)} callback\n   * @returns {void}\n   * @private\n   */\n  _writeMessage (conn, msg, callback) {\n    pull(\n      pull.values([msg]),\n      lp.encode(),\n      conn,\n      pull.onEnd(callback)\n    )\n  }\n}\n\nfunction writeReadMessage (conn, msg, callback) {\n  pull(\n    pull.values([msg]),\n    lp.encode(),\n    conn,\n    pull.filter((msg) => msg.length < c.maxMessageSize),\n    lp.decode(),\n    pull.collect((err, res) => {\n      if (err) {\n        return callback(err)\n      }\n      if (res.length === 0) {\n        return callback(errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED'))\n      }\n\n      let response\n      try {\n        response = Message.deserialize(res[0])\n      } catch (err) {\n        return callback(errcode(err, 'ERR_FAILED_DESERIALIZE_RESPONSE'))\n      }\n\n      callback(null, response)\n    })\n  )\n}\n\nmodule.exports = Network\n"]},"metadata":{},"sourceType":"script"}