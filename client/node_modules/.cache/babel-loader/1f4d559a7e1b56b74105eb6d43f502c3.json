{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar Identify = require('libp2p-identify');\n/**\n * For a given multistream, registers to handle the given connection\n * @param {MultistreamDialer} multistream\n * @param {Connection} connection\n * @returns {Promise}\n */\n\n\nmodule.exports.msHandle = function (multistream, connection) {\n  return new Promise(function (resolve, reject) {\n    multistream.handle(connection, function (err) {\n      if (err) return reject(err);\n      resolve();\n    });\n  });\n};\n/**\n * For a given multistream, selects the given protocol\n * @param {MultistreamDialer} multistream\n * @param {string} protocol\n * @returns {Promise} Resolves the selected Connection\n */\n\n\nmodule.exports.msSelect = function (multistream, protocol) {\n  return new Promise(function (resolve, reject) {\n    multistream.select(protocol, function (err, connection) {\n      if (err) return reject(err);\n      resolve(connection);\n    });\n  });\n};\n/**\n * Runs identify for the given connection and verifies it against the\n * PeerInfo provided\n * @param {Connection} connection\n * @param {PeerInfo} cryptoPeerInfo The PeerInfo determined during crypto exchange\n * @returns {Promise} Resolves {peerInfo, observedAddrs}\n */\n\n\nmodule.exports.identifyDialer = function (connection, cryptoPeerInfo) {\n  return new Promise(function (resolve, reject) {\n    Identify.dialer(connection, cryptoPeerInfo, function (err, peerInfo, observedAddrs) {\n      if (err) return reject(err);\n      resolve({\n        peerInfo: peerInfo,\n        observedAddrs: observedAddrs\n      });\n    });\n  });\n};\n/**\n * Get unique values from `arr` using `getValue` to determine\n * what is used for uniqueness\n * @param {Array} arr The array to get unique values for\n * @param {function(value)} getValue The function to determine what is compared\n * @returns {Array}\n */\n\n\nmodule.exports.uniqueBy = function (arr, getValue) {\n  return _toConsumableArray(new Map(arr.map(function (i) {\n    return [getValue(i), i];\n  })).values());\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-switch/src/utils.js"],"names":["Identify","require","module","exports","msHandle","multistream","connection","Promise","resolve","reject","handle","err","msSelect","protocol","select","identifyDialer","cryptoPeerInfo","dialer","peerInfo","observedAddrs","uniqueBy","arr","getValue","Map","map","i","values"],"mappings":"AAAA;;;;AAEA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,iBAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,CAAeC,QAAf,GAA0B,UAACC,WAAD,EAAcC,UAAd,EAA6B;AACrD,SAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtCJ,IAAAA,WAAW,CAACK,MAAZ,CAAmBJ,UAAnB,EAA+B,UAACK,GAAD,EAAS;AACtC,UAAIA,GAAJ,EAAS,OAAOF,MAAM,CAACE,GAAD,CAAb;AACTH,MAAAA,OAAO;AACR,KAHD;AAID,GALM,CAAP;AAMD,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;;;AACAN,MAAM,CAACC,OAAP,CAAeS,QAAf,GAA0B,UAACP,WAAD,EAAcQ,QAAd,EAA2B;AACnD,SAAO,IAAIN,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtCJ,IAAAA,WAAW,CAACS,MAAZ,CAAmBD,QAAnB,EAA6B,UAACF,GAAD,EAAML,UAAN,EAAqB;AAChD,UAAIK,GAAJ,EAAS,OAAOF,MAAM,CAACE,GAAD,CAAb;AACTH,MAAAA,OAAO,CAACF,UAAD,CAAP;AACD,KAHD;AAID,GALM,CAAP;AAMD,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAJ,MAAM,CAACC,OAAP,CAAeY,cAAf,GAAgC,UAACT,UAAD,EAAaU,cAAb,EAAgC;AAC9D,SAAO,IAAIT,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtCT,IAAAA,QAAQ,CAACiB,MAAT,CAAgBX,UAAhB,EAA4BU,cAA5B,EAA4C,UAACL,GAAD,EAAMO,QAAN,EAAgBC,aAAhB,EAAkC;AAC5E,UAAIR,GAAJ,EAAS,OAAOF,MAAM,CAACE,GAAD,CAAb;AACTH,MAAAA,OAAO,CAAC;AAAEU,QAAAA,QAAQ,EAARA,QAAF;AAAYC,QAAAA,aAAa,EAAbA;AAAZ,OAAD,CAAP;AACD,KAHD;AAID,GALM,CAAP;AAMD,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAjB,MAAM,CAACC,OAAP,CAAeiB,QAAf,GAA0B,UAACC,GAAD,EAAMC,QAAN,EAAmB;AAC3C,4BAAW,IAAIC,GAAJ,CAAQF,GAAG,CAACG,GAAJ,CAAQ,UAACC,CAAD;AAAA,WAAO,CAACH,QAAQ,CAACG,CAAD,CAAT,EAAcA,CAAd,CAAP;AAAA,GAAR,CAAR,EAA0CC,MAA1C,EAAX;AACD,CAFD","sourcesContent":["'use strict'\n\nconst Identify = require('libp2p-identify')\n\n/**\n * For a given multistream, registers to handle the given connection\n * @param {MultistreamDialer} multistream\n * @param {Connection} connection\n * @returns {Promise}\n */\nmodule.exports.msHandle = (multistream, connection) => {\n  return new Promise((resolve, reject) => {\n    multistream.handle(connection, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\n/**\n * For a given multistream, selects the given protocol\n * @param {MultistreamDialer} multistream\n * @param {string} protocol\n * @returns {Promise} Resolves the selected Connection\n */\nmodule.exports.msSelect = (multistream, protocol) => {\n  return new Promise((resolve, reject) => {\n    multistream.select(protocol, (err, connection) => {\n      if (err) return reject(err)\n      resolve(connection)\n    })\n  })\n}\n\n/**\n * Runs identify for the given connection and verifies it against the\n * PeerInfo provided\n * @param {Connection} connection\n * @param {PeerInfo} cryptoPeerInfo The PeerInfo determined during crypto exchange\n * @returns {Promise} Resolves {peerInfo, observedAddrs}\n */\nmodule.exports.identifyDialer = (connection, cryptoPeerInfo) => {\n  return new Promise((resolve, reject) => {\n    Identify.dialer(connection, cryptoPeerInfo, (err, peerInfo, observedAddrs) => {\n      if (err) return reject(err)\n      resolve({ peerInfo, observedAddrs })\n    })\n  })\n}\n\n/**\n * Get unique values from `arr` using `getValue` to determine\n * what is used for uniqueness\n * @param {Array} arr The array to get unique values for\n * @param {function(value)} getValue The function to determine what is compared\n * @returns {Array}\n */\nmodule.exports.uniqueBy = (arr, getValue) => {\n  return [...new Map(arr.map((i) => [getValue(i), i])).values()]\n}\n"]},"metadata":{},"sourceType":"script"}