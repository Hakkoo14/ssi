{"ast":null,"code":"'use strict';\n\nvar multiaddr = require('multiaddr');\n\nvar PeerInfo = require('peer-info');\n\nvar PeerId = require('peer-id');\n\nvar proto = require('../protocol');\n\nmodule.exports = function (swarm) {\n  /**\n   * Get b58 string from multiaddr or peerinfo\n   *\n   * @param {Multiaddr|PeerInfo} peer\n   * @return {*}\n   */\n  function getB58String(peer) {\n    var b58Id = null;\n\n    if (multiaddr.isMultiaddr(peer)) {\n      var relayMa = multiaddr(peer);\n      b58Id = relayMa.getPeerId();\n    } else if (PeerInfo.isPeerInfo(peer)) {\n      b58Id = peer.id.toB58String();\n    }\n\n    return b58Id;\n  }\n  /**\n   * Helper to make a peer info from a multiaddrs\n   *\n   * @param {Multiaddr|PeerInfo|PeerId} ma\n   * @param {Swarm} swarm\n   * @return {PeerInfo}\n   * @private\n   */\n  // TODO: this is ripped off of libp2p, should probably be a generally available util function\n\n\n  function peerInfoFromMa(peer) {\n    var p; // PeerInfo\n\n    if (PeerInfo.isPeerInfo(peer)) {\n      p = peer; // Multiaddr instance (not string)\n    } else if (multiaddr.isMultiaddr(peer)) {\n      var peerIdB58Str = peer.getPeerId();\n\n      try {\n        p = swarm._peerBook.get(peerIdB58Str);\n      } catch (err) {\n        p = new PeerInfo(PeerId.createFromB58String(peerIdB58Str));\n      }\n\n      p.multiaddrs.add(peer); // PeerId\n    } else if (PeerId.isPeerId(peer)) {\n      var _peerIdB58Str = peer.toB58String();\n\n      p = swarm._peerBook.has(_peerIdB58Str) ? swarm._peerBook.get(_peerIdB58Str) : peer;\n    }\n\n    return p;\n  }\n  /**\n   * Checks if peer has an existing connection\n   *\n   * @param {String} peerId\n   * @param {Swarm} swarm\n   * @return {Boolean}\n   */\n\n\n  function isPeerConnected(peerId) {\n    return swarm.muxedConns[peerId] || swarm.conns[peerId];\n  }\n  /**\n   * Write a response\n   *\n   * @param {StreamHandler} streamHandler\n   * @param {CircuitRelay.Status} status\n   * @param {Function} cb\n   * @returns {*}\n   */\n\n\n  function writeResponse(streamHandler, status, cb) {\n    cb = cb || function () {};\n\n    streamHandler.write(proto.CircuitRelay.encode({\n      type: proto.CircuitRelay.Type.STATUS,\n      code: status\n    }));\n    return cb();\n  }\n  /**\n   * Validate incomming HOP/STOP message\n   *\n   * @param {CircuitRelay} msg\n   * @param {StreamHandler} streamHandler\n   * @param {CircuitRelay.Type} type\n   * @returns {*}\n   * @param {Function} cb\n   */\n\n\n  function validateAddrs(msg, streamHandler, type, cb) {\n    try {\n      msg.dstPeer.addrs.forEach(function (addr) {\n        return multiaddr(addr);\n      });\n    } catch (err) {\n      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP ? proto.CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : proto.CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);\n      return cb(err);\n    }\n\n    try {\n      msg.srcPeer.addrs.forEach(function (addr) {\n        return multiaddr(addr);\n      });\n    } catch (err) {\n      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP ? proto.CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : proto.CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);\n      return cb(err);\n    }\n\n    return cb(null);\n  }\n\n  function peerIdFromId(id) {\n    if (typeof id === 'string') {\n      return PeerId.createFromB58String(id);\n    }\n\n    return PeerId.createFromBytes(id);\n  }\n\n  return {\n    getB58String: getB58String,\n    peerInfoFromMa: peerInfoFromMa,\n    isPeerConnected: isPeerConnected,\n    validateAddrs: validateAddrs,\n    writeResponse: writeResponse,\n    peerIdFromId: peerIdFromId\n  };\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p-circuit/src/circuit/utils.js"],"names":["multiaddr","require","PeerInfo","PeerId","proto","module","exports","swarm","getB58String","peer","b58Id","isMultiaddr","relayMa","getPeerId","isPeerInfo","id","toB58String","peerInfoFromMa","p","peerIdB58Str","_peerBook","get","err","createFromB58String","multiaddrs","add","isPeerId","has","isPeerConnected","peerId","muxedConns","conns","writeResponse","streamHandler","status","cb","write","CircuitRelay","encode","type","Type","STATUS","code","validateAddrs","msg","dstPeer","addrs","forEach","addr","HOP","Status","HOP_DST_MULTIADDR_INVALID","STOP_DST_MULTIADDR_INVALID","srcPeer","HOP_SRC_MULTIADDR_INVALID","STOP_SRC_MULTIADDR_INVALID","peerIdFromId","createFromBytes"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multiaddr = require('multiaddr')\nconst PeerInfo = require('peer-info')\nconst PeerId = require('peer-id')\nconst proto = require('../protocol')\n\nmodule.exports = function (swarm) {\n  /**\n   * Get b58 string from multiaddr or peerinfo\n   *\n   * @param {Multiaddr|PeerInfo} peer\n   * @return {*}\n   */\n  function getB58String (peer) {\n    let b58Id = null\n    if (multiaddr.isMultiaddr(peer)) {\n      const relayMa = multiaddr(peer)\n      b58Id = relayMa.getPeerId()\n    } else if (PeerInfo.isPeerInfo(peer)) {\n      b58Id = peer.id.toB58String()\n    }\n\n    return b58Id\n  }\n\n  /**\n   * Helper to make a peer info from a multiaddrs\n   *\n   * @param {Multiaddr|PeerInfo|PeerId} ma\n   * @param {Swarm} swarm\n   * @return {PeerInfo}\n   * @private\n   */\n  // TODO: this is ripped off of libp2p, should probably be a generally available util function\n  function peerInfoFromMa (peer) {\n    let p\n    // PeerInfo\n    if (PeerInfo.isPeerInfo(peer)) {\n      p = peer\n      // Multiaddr instance (not string)\n    } else if (multiaddr.isMultiaddr(peer)) {\n      const peerIdB58Str = peer.getPeerId()\n      try {\n        p = swarm._peerBook.get(peerIdB58Str)\n      } catch (err) {\n        p = new PeerInfo(PeerId.createFromB58String(peerIdB58Str))\n      }\n      p.multiaddrs.add(peer)\n      // PeerId\n    } else if (PeerId.isPeerId(peer)) {\n      const peerIdB58Str = peer.toB58String()\n      p = swarm._peerBook.has(peerIdB58Str) ? swarm._peerBook.get(peerIdB58Str) : peer\n    }\n\n    return p\n  }\n\n  /**\n   * Checks if peer has an existing connection\n   *\n   * @param {String} peerId\n   * @param {Swarm} swarm\n   * @return {Boolean}\n   */\n  function isPeerConnected (peerId) {\n    return swarm.muxedConns[peerId] || swarm.conns[peerId]\n  }\n\n  /**\n   * Write a response\n   *\n   * @param {StreamHandler} streamHandler\n   * @param {CircuitRelay.Status} status\n   * @param {Function} cb\n   * @returns {*}\n   */\n  function writeResponse (streamHandler, status, cb) {\n    cb = cb || (() => {})\n    streamHandler.write(proto.CircuitRelay.encode({\n      type: proto.CircuitRelay.Type.STATUS,\n      code: status\n    }))\n    return cb()\n  }\n\n  /**\n   * Validate incomming HOP/STOP message\n   *\n   * @param {CircuitRelay} msg\n   * @param {StreamHandler} streamHandler\n   * @param {CircuitRelay.Type} type\n   * @returns {*}\n   * @param {Function} cb\n   */\n  function validateAddrs (msg, streamHandler, type, cb) {\n    try {\n      msg.dstPeer.addrs.forEach((addr) => {\n        return multiaddr(addr)\n      })\n    } catch (err) {\n      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP\n        ? proto.CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID\n        : proto.CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID)\n      return cb(err)\n    }\n\n    try {\n      msg.srcPeer.addrs.forEach((addr) => {\n        return multiaddr(addr)\n      })\n    } catch (err) {\n      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP\n        ? proto.CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID\n        : proto.CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID)\n      return cb(err)\n    }\n\n    return cb(null)\n  }\n\n  function peerIdFromId (id) {\n    if (typeof id === 'string') {\n      return PeerId.createFromB58String(id)\n    }\n\n    return PeerId.createFromBytes(id)\n  }\n\n  return {\n    getB58String,\n    peerInfoFromMa,\n    isPeerConnected,\n    validateAddrs,\n    writeResponse,\n    peerIdFromId\n  }\n}\n"]},"metadata":{},"sourceType":"script"}