{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ipns = require('ipns');\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:resolver');\nlog.error = debug('ipfs:ipns:resolver:error');\nvar defaultMaximumRecursiveDepth = 32;\n\nvar IpnsResolver = /*#__PURE__*/function () {\n  function IpnsResolver(routing) {\n    _classCallCheck(this, IpnsResolver);\n\n    this._routing = routing;\n  }\n\n  _createClass(IpnsResolver, [{\n    key: \"resolve\",\n    value: function resolve(name, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (typeof name !== 'string') {\n        var errMsg = \"one or more of the provided parameters are not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PARAMETER'));\n      }\n\n      options = options || {};\n      var recursive = options.recursive && options.recursive.toString() === 'true';\n      var nameSegments = name.split('/');\n\n      if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n        var _errMsg = \"invalid name syntax for \".concat(name);\n\n        log.error(_errMsg);\n        return callback(errcode(new Error(_errMsg), 'ERR_INVALID_NAME_SYNTAX'));\n      }\n\n      var key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n      var depth;\n\n      if (recursive) {\n        depth = defaultMaximumRecursiveDepth;\n      }\n\n      this.resolver(key, depth, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        log(\"\".concat(name, \" was locally resolved correctly\"));\n        callback(null, res);\n      });\n    } // Recursive resolver according to the specified depth\n\n  }, {\n    key: \"resolver\",\n    value: function resolver(name, depth, callback) {\n      var _this = this;\n\n      // Exceeded recursive maximum depth\n      if (depth === 0) {\n        var errMsg = \"could not resolve name (recursion limit of \".concat(defaultMaximumRecursiveDepth, \" exceeded)\");\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT'));\n      }\n\n      this._resolveName(name, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        var nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n        if (nameSegments[1] === 'ipfs' || !depth) {\n          return callback(null, res);\n        } // continue recursively until depth equals 0\n\n\n        _this.resolver(nameSegments[2], depth - 1, callback);\n      });\n    } // resolve ipns entries from the provided routing\n\n  }, {\n    key: \"_resolveName\",\n    value: function _resolveName(name, callback) {\n      var _this2 = this;\n\n      var peerId;\n\n      try {\n        peerId = PeerId.createFromB58String(name);\n      } catch (err) {\n        return callback(err);\n      }\n\n      var _ipns$getIdKeys = ipns.getIdKeys(peerId.toBytes()),\n          routingKey = _ipns$getIdKeys.routingKey,\n          routingPubKey = _ipns$getIdKeys.routingPubKey;\n\n      this._routing.get(routingKey.toBuffer(), function (err, record) {\n        if (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            var _errMsg2 = \"unexpected error getting the ipns record \".concat(peerId.id);\n\n            log.error(_errMsg2);\n            return callback(errcode(new Error(_errMsg2), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD'));\n          }\n\n          var errMsg = \"record requested was not found for \".concat(name, \" (\").concat(routingKey, \") in the network\");\n          log.error(errMsg);\n          return callback(errcode(new Error(errMsg), 'ERR_NO_RECORD_FOUND'));\n        } // IPNS entry\n\n\n        var ipnsEntry;\n\n        try {\n          ipnsEntry = ipns.unmarshal(record);\n        } catch (err) {\n          var _errMsg3 = \"found ipns record that we couldn't convert to a value\";\n          log.error(_errMsg3);\n          return callback(errcode(new Error(_errMsg3), 'ERR_INVALID_RECORD_RECEIVED'));\n        } // if the record has a public key validate it\n\n\n        if (ipnsEntry.pubKey) {\n          return _this2._validateRecord(peerId, ipnsEntry, callback);\n        } // Otherwise, try to get the public key from routing\n\n\n        _this2._routing.get(routingKey.toBuffer(), function (err, pubKey) {\n          if (err) {\n            if (err.code !== 'ERR_NOT_FOUND') {\n              var _errMsg5 = \"unexpected error getting the public key for the ipns record \".concat(peerId.id);\n\n              log.error(_errMsg5);\n              return callback(errcode(new Error(_errMsg5), 'ERR_UNEXPECTED_ERROR_GETTING_PUB_KEY'));\n            }\n\n            var _errMsg4 = \"public key requested was not found for \".concat(name, \" (\").concat(routingPubKey, \") in the network\");\n\n            log.error(_errMsg4);\n            return callback(errcode(new Error(_errMsg4), 'ERR_NO_RECORD_FOUND'));\n          }\n\n          try {\n            // Insert it into the peer id, in order to be validated by IPNS validator\n            peerId.pubKey = crypto.keys.unmarshalPublicKey(pubKey);\n          } catch (err) {\n            var _errMsg6 = \"found public key record that we couldn't convert to a value\";\n            log.error(_errMsg6);\n            return callback(errcode(new Error(_errMsg6), 'ERR_INVALID_PUB_KEY_RECEIVED'));\n          }\n\n          _this2._validateRecord(peerId, ipnsEntry, callback);\n        });\n      });\n    } // validate a resolved record\n\n  }, {\n    key: \"_validateRecord\",\n    value: function _validateRecord(peerId, ipnsEntry, callback) {\n      ipns.extractPublicKey(peerId, ipnsEntry, function (err, pubKey) {\n        if (err) {\n          return callback(err);\n        } // IPNS entry validation\n\n\n        ipns.validate(pubKey, ipnsEntry, function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, ipnsEntry.value.toString());\n        });\n      });\n    }\n  }]);\n\n  return IpnsResolver;\n}();\n\nexports = module.exports = IpnsResolver;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs/src/core/ipns/resolver.js"],"names":["ipns","require","crypto","PeerId","errcode","debug","log","error","defaultMaximumRecursiveDepth","IpnsResolver","routing","_routing","name","options","callback","errMsg","Error","recursive","toString","nameSegments","split","length","key","depth","resolver","err","res","_resolveName","peerId","createFromB58String","getIdKeys","toBytes","routingKey","routingPubKey","get","toBuffer","record","code","id","ipnsEntry","unmarshal","pubKey","_validateRecord","keys","unmarshalPublicKey","extractPublicKey","validate","value","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\n\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:resolver')\nlog.error = debug('ipfs:ipns:resolver:error')\n\nconst defaultMaximumRecursiveDepth = 32\n\nclass IpnsResolver {\n  constructor (routing) {\n    this._routing = routing\n  }\n\n  resolve (name, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    if (typeof name !== 'string') {\n      const errMsg = `one or more of the provided parameters are not valid`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_PARAMETER'))\n    }\n\n    options = options || {}\n    const recursive = options.recursive && options.recursive.toString() === 'true'\n\n    const nameSegments = name.split('/')\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      const errMsg = `invalid name syntax for ${name}`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_NAME_SYNTAX'))\n    }\n\n    const key = nameSegments[2]\n\n    // Define a maximum depth if recursive option enabled\n    let depth\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth\n    }\n\n    this.resolver(key, depth, (err, res) => {\n      if (err) {\n        return callback(err)\n      }\n\n      log(`${name} was locally resolved correctly`)\n      callback(null, res)\n    })\n  }\n\n  // Recursive resolver according to the specified depth\n  resolver (name, depth, callback) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT'))\n    }\n\n    this._resolveName(name, (err, res) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const nameSegments = res.split('/')\n\n      // If obtained a ipfs cid or recursive option is disabled\n      if (nameSegments[1] === 'ipfs' || !depth) {\n        return callback(null, res)\n      }\n\n      // continue recursively until depth equals 0\n      this.resolver(nameSegments[2], depth - 1, callback)\n    })\n  }\n\n  // resolve ipns entries from the provided routing\n  _resolveName (name, callback) {\n    let peerId\n\n    try {\n      peerId = PeerId.createFromB58String(name)\n    } catch (err) {\n      return callback(err)\n    }\n\n    const { routingKey, routingPubKey } = ipns.getIdKeys(peerId.toBytes())\n\n    this._routing.get(routingKey.toBuffer(), (err, record) => {\n      if (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          const errMsg = `unexpected error getting the ipns record ${peerId.id}`\n\n          log.error(errMsg)\n          return callback(errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD'))\n        }\n        const errMsg = `record requested was not found for ${name} (${routingKey}) in the network`\n\n        log.error(errMsg)\n        return callback(errcode(new Error(errMsg), 'ERR_NO_RECORD_FOUND'))\n      }\n\n      // IPNS entry\n      let ipnsEntry\n      try {\n        ipnsEntry = ipns.unmarshal(record)\n      } catch (err) {\n        const errMsg = `found ipns record that we couldn't convert to a value`\n\n        log.error(errMsg)\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED'))\n      }\n\n      // if the record has a public key validate it\n      if (ipnsEntry.pubKey) {\n        return this._validateRecord(peerId, ipnsEntry, callback)\n      }\n\n      // Otherwise, try to get the public key from routing\n      this._routing.get(routingKey.toBuffer(), (err, pubKey) => {\n        if (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            const errMsg = `unexpected error getting the public key for the ipns record ${peerId.id}`\n\n            log.error(errMsg)\n            return callback(errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_PUB_KEY'))\n          }\n          const errMsg = `public key requested was not found for ${name} (${routingPubKey}) in the network`\n\n          log.error(errMsg)\n          return callback(errcode(new Error(errMsg), 'ERR_NO_RECORD_FOUND'))\n        }\n\n        try {\n          // Insert it into the peer id, in order to be validated by IPNS validator\n          peerId.pubKey = crypto.keys.unmarshalPublicKey(pubKey)\n        } catch (err) {\n          const errMsg = `found public key record that we couldn't convert to a value`\n\n          log.error(errMsg)\n          return callback(errcode(new Error(errMsg), 'ERR_INVALID_PUB_KEY_RECEIVED'))\n        }\n\n        this._validateRecord(peerId, ipnsEntry, callback)\n      })\n    })\n  }\n\n  // validate a resolved record\n  _validateRecord (peerId, ipnsEntry, callback) {\n    ipns.extractPublicKey(peerId, ipnsEntry, (err, pubKey) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // IPNS entry validation\n      ipns.validate(pubKey, ipnsEntry, (err) => {\n        if (err) {\n          return callback(err)\n        }\n\n        callback(null, ipnsEntry.value.toString())\n      })\n    })\n  }\n}\n\nexports = module.exports = IpnsResolver\n"]},"metadata":{},"sourceType":"script"}