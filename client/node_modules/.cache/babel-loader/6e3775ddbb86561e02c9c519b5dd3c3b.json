{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _classCallCheck = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar waterfall = require('async/waterfall');\n\nvar parallel = require('async/parallel');\n\nvar Key = require('interface-datastore').Key;\n\nvar sh = require('./shard');\n\nvar KeytransformStore = require('./keytransform');\n\nvar shardKey = new Key(sh.SHARDING_FN);\nvar shardReadmeKey = new Key(sh.README_FN);\n/* ::\nimport type {Datastore, Batch, Query, QueryResult, Callback} from 'interface-datastore'\n\nimport type {ShardV1} from './shard'\n*/\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\n\nvar ShardingDatastore = /*#__PURE__*/function () {\n  /* :: shard: ShardV1 */\n\n  /* :: child: Datastore<Buffer> */\n  function ShardingDatastore(store\n  /* : Datastore<Buffer> */\n  , shard\n  /* : ShardV1 */\n  ) {\n    _classCallCheck(this, ShardingDatastore);\n\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n\n  _createClass(ShardingDatastore, [{\n    key: \"open\",\n    value: function open(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.child.open(callback);\n    }\n  }, {\n    key: \"_convertKey\",\n    value: function _convertKey(key\n    /* : Key */\n    )\n    /* : Key */\n    {\n      var s = key.toString();\n\n      if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n        return key;\n      }\n\n      var parent = new Key(this.shard.fun(s));\n      return parent.child(key);\n    }\n  }, {\n    key: \"_invertKey\",\n    value: function _invertKey(key\n    /* : Key */\n    )\n    /* : Key */\n    {\n      var s = key.toString();\n\n      if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n        return key;\n      }\n\n      return Key.withNamespaces(key.list().slice(1));\n    }\n  }, {\n    key: \"put\",\n    value: function put(key\n    /* : Key */\n    , val\n    /* : Buffer */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.child.put(key, val, callback);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key\n    /* : Key */\n    , callback\n    /* : Callback<Buffer> */\n    )\n    /* : void */\n    {\n      this.child.get(key, callback);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key\n    /* : Key */\n    , callback\n    /* : Callback<bool> */\n    )\n    /* : void */\n    {\n      this.child.has(key, callback);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key\n    /* : Key */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.child.delete(key, callback);\n    }\n  }, {\n    key: \"batch\",\n    value: function batch()\n    /* : Batch<Buffer> */\n    {\n      return this.child.batch();\n    }\n  }, {\n    key: \"query\",\n    value: function query(q\n    /* : Query<Buffer> */\n    )\n    /* : QueryResult<Buffer> */\n    {\n      var _this = this;\n\n      var tq\n      /* : Query<Buffer> */\n      = {\n        keysOnly: q.keysOnly,\n        offset: q.offset,\n        limit: q.limit,\n        filters: [function (e, cb) {\n          return cb(null, e.key.toString() !== shardKey.toString());\n        }, function (e, cb) {\n          return cb(null, e.key.toString() !== shardReadmeKey.toString());\n        }]\n      };\n\n      if (q.prefix != null) {\n        tq.filters.push(function (e, cb) {\n          cb(null, _this._invertKey(e.key).toString().startsWith(q.prefix));\n        });\n      }\n\n      if (q.filters != null) {\n        var filters = q.filters.map(function (f) {\n          return function (e, cb) {\n            f(Object.assign({}, e, {\n              key: _this._invertKey(e.key)\n            }), cb);\n          };\n        });\n        tq.filters = tq.filters.concat(filters);\n      }\n\n      if (q.orders != null) {\n        tq.orders = q.orders.map(function (o) {\n          return function (res, cb) {\n            res.forEach(function (e) {\n              e.key = _this._invertKey(e.key);\n            });\n            o(res, function (err, ordered) {\n              if (err) {\n                return cb(err);\n              }\n\n              ordered.forEach(function (e) {\n                e.key = _this._convertKey(e.key);\n              });\n              cb(null, ordered);\n            });\n          };\n        });\n      }\n\n      return this.child.query(tq);\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.child.close(callback);\n    }\n  }], [{\n    key: \"createOrOpen\",\n    value: function createOrOpen(store\n    /* : Datastore<Buffer> */\n    , shard\n    /* : ShardV1 */\n    , callback\n    /* : Callback<ShardingDatastore> */\n    )\n    /* : void */\n    {\n      ShardingDatastore.create(store, shard, function (err) {\n        if (err && err.message !== 'datastore exists') {\n          return callback(err);\n        }\n\n        ShardingDatastore.open(store, callback);\n      });\n    }\n  }, {\n    key: \"open\",\n    value: function open(store\n    /* : Datastore<Buffer> */\n    , callback\n    /* : Callback<ShardingDatastore> */\n    )\n    /* : void */\n    {\n      waterfall([function (cb) {\n        return sh.readShardFun('/', store, cb);\n      }, function (shard, cb) {\n        cb(null, new ShardingDatastore(store, shard));\n      }], callback);\n    }\n  }, {\n    key: \"create\",\n    value: function create(store\n    /* : Datastore<Buffer> */\n    , shard\n    /* : ShardV1 */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      store.has(shardKey, function (err, exists) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!exists) {\n          var put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n          return parallel([function (cb) {\n            return put(shardKey, Buffer.from(shard.toString() + '\\n'), cb);\n          }, function (cb) {\n            return put(shardReadmeKey, Buffer.from(sh.readme), cb);\n          }], function (err) {\n            return callback(err);\n          });\n        }\n\n        sh.readShardFun('/', store, function (err, diskShard) {\n          if (err) {\n            return callback(err);\n          }\n\n          var a = (diskShard || '').toString();\n          var b = shard.toString();\n\n          if (a !== b) {\n            return callback(new Error(\"specified fun \".concat(b, \" does not match repo shard fun \").concat(a)));\n          }\n\n          callback(new Error('datastore exists'));\n        });\n      });\n    }\n  }]);\n\n  return ShardingDatastore;\n}();\n\nmodule.exports = ShardingDatastore;","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/datastore-core/src/sharding.js"],"names":["waterfall","require","parallel","Key","sh","KeytransformStore","shardKey","SHARDING_FN","shardReadmeKey","README_FN","ShardingDatastore","store","shard","child","convert","_convertKey","bind","invert","_invertKey","callback","open","key","s","toString","parent","fun","withNamespaces","list","slice","val","put","get","has","delete","batch","q","tq","keysOnly","offset","limit","filters","e","cb","prefix","push","startsWith","map","f","Object","assign","concat","orders","o","res","forEach","err","ordered","query","close","create","message","readShardFun","exists","putRaw","Buffer","from","readme","diskShard","a","b","Error","module","exports"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\nconst waterfall = require('async/waterfall')\nconst parallel = require('async/parallel')\nconst Key = require('interface-datastore').Key\n\nconst sh = require('./shard')\nconst KeytransformStore = require('./keytransform')\n\nconst shardKey = new Key(sh.SHARDING_FN)\nconst shardReadmeKey = new Key(sh.README_FN)\n\n/* ::\nimport type {Datastore, Batch, Query, QueryResult, Callback} from 'interface-datastore'\n\nimport type {ShardV1} from './shard'\n*/\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nclass ShardingDatastore {\n  /* :: shard: ShardV1 */\n  /* :: child: Datastore<Buffer> */\n\n  constructor (store /* : Datastore<Buffer> */, shard /* : ShardV1 */) {\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    })\n    this.shard = shard\n  }\n\n  open (callback /* : Callback<void> */) /* : void */ {\n    this.child.open(callback)\n  }\n\n  _convertKey (key/* : Key */)/* : Key */ {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n\n    const parent = new Key(this.shard.fun(s))\n    return parent.child(key)\n  }\n\n  _invertKey (key/* : Key */)/* : Key */ {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n    return Key.withNamespaces(key.list().slice(1))\n  }\n\n  static createOrOpen (store /* : Datastore<Buffer> */, shard /* : ShardV1 */, callback /* : Callback<ShardingDatastore> */) /* : void */ {\n    ShardingDatastore.create(store, shard, err => {\n      if (err && err.message !== 'datastore exists') {\n        return callback(err)\n      }\n\n      ShardingDatastore.open(store, callback)\n    })\n  }\n\n  static open (store /* : Datastore<Buffer> */, callback /* : Callback<ShardingDatastore> */) /* : void */ {\n    waterfall([\n      (cb) => sh.readShardFun('/', store, cb),\n      (shard, cb) => {\n        cb(null, new ShardingDatastore(store, shard))\n      }\n    ], callback)\n  }\n\n  static create (store /* : Datastore<Buffer> */, shard /* : ShardV1 */, callback /* : Callback<void> */) /* : void */ {\n    store.has(shardKey, (err, exists) => {\n      if (err) {\n        return callback(err)\n      }\n\n      if (!exists) {\n        const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store)\n        return parallel([\n          (cb) => put(shardKey, Buffer.from(shard.toString() + '\\n'), cb),\n          (cb) => put(shardReadmeKey, Buffer.from(sh.readme), cb)\n        ], err => callback(err))\n      }\n\n      sh.readShardFun('/', store, (err, diskShard) => {\n        if (err) {\n          return callback(err)\n        }\n\n        const a = (diskShard || '').toString()\n        const b = shard.toString()\n        if (a !== b) {\n          return callback(new Error(`specified fun ${b} does not match repo shard fun ${a}`))\n        }\n\n        callback(new Error('datastore exists'))\n      })\n    })\n  }\n\n  put (key /* : Key */, val /* : Buffer */, callback /* : Callback<void> */) /* : void */ {\n    this.child.put(key, val, callback)\n  }\n\n  get (key /* : Key */, callback /* : Callback<Buffer> */) /* : void */ {\n    this.child.get(key, callback)\n  }\n\n  has (key /* : Key */, callback /* : Callback<bool> */) /* : void */ {\n    this.child.has(key, callback)\n  }\n\n  delete (key /* : Key */, callback /* : Callback<void> */) /* : void */ {\n    this.child.delete(key, callback)\n  }\n\n  batch () /* : Batch<Buffer> */ {\n    return this.child.batch()\n  }\n\n  query (q /* : Query<Buffer> */) /* : QueryResult<Buffer> */ {\n    const tq/* : Query<Buffer> */ = {\n      keysOnly: q.keysOnly,\n      offset: q.offset,\n      limit: q.limit,\n      filters: [\n        (e, cb) => cb(null, e.key.toString() !== shardKey.toString()),\n        (e, cb) => cb(null, e.key.toString() !== shardReadmeKey.toString())\n      ]\n    }\n\n    if (q.prefix != null) {\n      tq.filters.push((e, cb) => {\n        cb(null, this._invertKey(e.key).toString().startsWith(q.prefix))\n      })\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map((f) => (e, cb) => {\n        f(Object.assign({}, e, {\n          key: this._invertKey(e.key)\n        }), cb)\n      })\n      tq.filters = tq.filters.concat(filters)\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map((o) => (res, cb) => {\n        res.forEach((e) => { e.key = this._invertKey(e.key) })\n        o(res, (err, ordered) => {\n          if (err) {\n            return cb(err)\n          }\n          ordered.forEach((e) => { e.key = this._convertKey(e.key) })\n          cb(null, ordered)\n        })\n      })\n    }\n\n    return this.child.query(tq)\n  }\n\n  close (callback /* : Callback<void> */) /* : void */ {\n    this.child.close(callback)\n  }\n}\n\nmodule.exports = ShardingDatastore\n"]},"metadata":{},"sourceType":"script"}