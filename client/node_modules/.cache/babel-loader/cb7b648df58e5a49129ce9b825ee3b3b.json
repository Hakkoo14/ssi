{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ipns = require('ipns');\n\nvar _require = require('multihashes'),\n    fromB58String = _require.fromB58String,\n    toB58String = _require.toB58String;\n\nvar PubsubDatastore = require('datastore-pubsub');\n\nvar withIs = require('class-is');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:pubsub');\nlog.error = debug('ipfs:ipns:pubsub:error'); // Pubsub datastore aims to manage the pubsub subscriptions for IPNS\n\nvar IpnsPubsubDatastore = /*#__PURE__*/function () {\n  function IpnsPubsubDatastore(pubsub, localDatastore, peerId) {\n    _classCallCheck(this, IpnsPubsubDatastore);\n\n    this._pubsub = pubsub;\n    this._subscriptions = {}; // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey);\n  }\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(IpnsPubsubDatastore, [{\n    key: \"put\",\n    value: function put(key, value, callback) {\n      this._pubsubDs.put(key, value, callback);\n    }\n    /**\n     * Get a value from the pubsub datastore indexed by the received key properly encoded.\n     * Moreover, the identifier topic is subscribed and the pubsub datastore records will be\n     * updated once new publishes occur.\n     * @param {Buffer} key identifier of the value to be obtained.\n     * @param {function(Error, Buffer)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, callback) {\n      var _this = this;\n\n      this._pubsubDs.get(key, function (err, res) {\n        // Add topic subscribed\n        var ns = key.slice(0, ipns.namespaceLength);\n\n        if (ns.toString() === ipns.namespace) {\n          var stringifiedTopic = key.toString();\n          var id = toB58String(key.slice(ipns.namespaceLength));\n          _this._subscriptions[stringifiedTopic] = id;\n          log(\"subscribed pubsub \".concat(stringifiedTopic, \": \").concat(id));\n        } // If no data was obtained, after storing the subscription, return the error.\n\n\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, res);\n      });\n    } // Modify subscription key to have a proper encoding\n\n  }, {\n    key: \"_handleSubscriptionKey\",\n    value: function _handleSubscriptionKey(key, callback) {\n      var subscriber = this._subscriptions[key];\n\n      if (!subscriber) {\n        var errMsg = \"key \".concat(key, \" does not correspond to a subscription\");\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'));\n      }\n\n      var keys;\n\n      try {\n        keys = ipns.getIdKeys(fromB58String(subscriber));\n      } catch (err) {\n        log.error(err);\n        return callback(err);\n      }\n\n      callback(null, keys.routingKey.toBuffer());\n    }\n    /**\n     * Get pubsub subscriptions related to ipns.\n     * @param {function(Error, Object)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getSubscriptions\",\n    value: function getSubscriptions(callback) {\n      var subscriptions = Object.values(this._subscriptions).filter(Boolean);\n      return callback(null, subscriptions.map(function (sub) {\n        return \"\".concat(ipns.namespace).concat(sub);\n      }));\n    }\n    /**\n     * Cancel pubsub subscriptions related to ipns.\n     * @param {String} name ipns path to cancel the pubsub subscription.\n     * @param {function(Error, Object)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(name, callback) {\n      var _this2 = this;\n\n      if (typeof name !== 'string') {\n        var errMsg = \"received subscription name is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_SUBSCRIPTION_NAME'));\n      } // Trim /ipns/ prefix from the name\n\n\n      if (name.startsWith(ipns.namespace)) {\n        name = name.substring(ipns.namespaceLength);\n      }\n\n      var stringifiedTopic = Object.keys(this._subscriptions).find(function (key) {\n        return _this2._subscriptions[key] === name;\n      }); // Not found topic\n\n      if (!stringifiedTopic) {\n        return callback(null, {\n          canceled: false\n        });\n      } // Unsubscribe topic\n\n\n      try {\n        var bufTopic = Buffer.from(stringifiedTopic);\n\n        this._pubsubDs.unsubscribe(bufTopic);\n      } catch (err) {\n        return callback(err);\n      }\n\n      this._subscriptions[stringifiedTopic] = undefined;\n      log(\"unsubscribed pubsub \".concat(stringifiedTopic, \": \").concat(name));\n      callback(null, {\n        canceled: true\n      });\n    }\n  }]);\n\n  return IpnsPubsubDatastore;\n}();\n\nexports = module.exports = withIs(IpnsPubsubDatastore, {\n  className: 'IpnsPubsubDatastore',\n  symbolName: '@js-ipfs/ipns/IpnsPubsubDatastore'\n});","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/ipfs/src/core/ipns/routing/pubsub-datastore.js"],"names":["ipns","require","fromB58String","toB58String","PubsubDatastore","withIs","errcode","debug","log","error","IpnsPubsubDatastore","pubsub","localDatastore","peerId","_pubsub","_subscriptions","_handleSubscriptionKey","bind","_pubsubDs","validator","key","value","callback","put","get","err","res","ns","slice","namespaceLength","toString","namespace","stringifiedTopic","id","subscriber","errMsg","Error","keys","getIdKeys","routingKey","toBuffer","subscriptions","Object","values","filter","Boolean","map","sub","name","startsWith","substring","find","canceled","bufTopic","Buffer","from","unsubscribe","undefined","exports","module","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst { fromB58String, toB58String } = require('multihashes')\nconst PubsubDatastore = require('datastore-pubsub')\n\nconst withIs = require('class-is')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:pubsub')\nlog.error = debug('ipfs:ipns:pubsub:error')\n\n// Pubsub datastore aims to manage the pubsub subscriptions for IPNS\nclass IpnsPubsubDatastore {\n  constructor (pubsub, localDatastore, peerId) {\n    this._pubsub = pubsub\n    this._subscriptions = {}\n\n    // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this)\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey)\n  }\n\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  put (key, value, callback) {\n    this._pubsubDs.put(key, value, callback)\n  }\n\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Moreover, the identifier topic is subscribed and the pubsub datastore records will be\n   * updated once new publishes occur.\n   * @param {Buffer} key identifier of the value to be obtained.\n   * @param {function(Error, Buffer)} callback\n   * @returns {void}\n   */\n  get (key, callback) {\n    this._pubsubDs.get(key, (err, res) => {\n      // Add topic subscribed\n      const ns = key.slice(0, ipns.namespaceLength)\n\n      if (ns.toString() === ipns.namespace) {\n        const stringifiedTopic = key.toString()\n        const id = toB58String(key.slice(ipns.namespaceLength))\n\n        this._subscriptions[stringifiedTopic] = id\n\n        log(`subscribed pubsub ${stringifiedTopic}: ${id}`)\n      }\n\n      // If no data was obtained, after storing the subscription, return the error.\n      if (err) {\n        return callback(err)\n      }\n\n      callback(null, res)\n    })\n  }\n\n  // Modify subscription key to have a proper encoding\n  _handleSubscriptionKey (key, callback) {\n    const subscriber = this._subscriptions[key]\n\n    if (!subscriber) {\n      const errMsg = `key ${key} does not correspond to a subscription`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_KEY'))\n    }\n\n    let keys\n    try {\n      keys = ipns.getIdKeys(fromB58String(subscriber))\n    } catch (err) {\n      log.error(err)\n      return callback(err)\n    }\n\n    callback(null, keys.routingKey.toBuffer())\n  }\n\n  /**\n   * Get pubsub subscriptions related to ipns.\n   * @param {function(Error, Object)} callback\n   * @returns {void}\n   */\n  getSubscriptions (callback) {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean)\n\n    return callback(null, subscriptions.map((sub) => `${ipns.namespace}${sub}`))\n  }\n\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   * @param {String} name ipns path to cancel the pubsub subscription.\n   * @param {function(Error, Object)} callback\n   * @returns {void}\n   */\n  cancel (name, callback) {\n    if (typeof name !== 'string') {\n      const errMsg = `received subscription name is not valid`\n\n      log.error(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_SUBSCRIPTION_NAME'))\n    }\n\n    // Trim /ipns/ prefix from the name\n    if (name.startsWith(ipns.namespace)) {\n      name = name.substring(ipns.namespaceLength)\n    }\n\n    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name)\n\n    // Not found topic\n    if (!stringifiedTopic) {\n      return callback(null, {\n        canceled: false\n      })\n    }\n\n    // Unsubscribe topic\n    try {\n      const bufTopic = Buffer.from(stringifiedTopic)\n\n      this._pubsubDs.unsubscribe(bufTopic)\n    } catch (err) {\n      return callback(err)\n    }\n\n    this._subscriptions[stringifiedTopic] = undefined\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`)\n\n    callback(null, {\n      canceled: true\n    })\n  }\n}\n\nexports = module.exports = withIs(IpnsPubsubDatastore, { className: 'IpnsPubsubDatastore', symbolName: '@js-ipfs/ipns/IpnsPubsubDatastore' })\n"]},"metadata":{},"sourceType":"script"}