{"ast":null,"code":"/*\nall pull streams have these states:\n\n{\n  START: {\n    read: READING,\n    abort: ABORTING\n  },\n  READY: {\n    read: READING,\n    abort: ABORTING\n  },\n  READING: {\n    cb: READY,\n    err: ERROR,\n    end: END\n  },\n  ABORTING: {\n    cb: END\n  },\n  ERROR: {},\n  END: {}\n}\n\nthis module takes a collection of pull-streams,\nand interleaves their states.\nif all the streams have ended, it ends.\nIf it is in reading state, and one stream goes has READING->cb\nit goes into READY\n\non read, trigger read on every stream in START or READY\n\non abort, trigger abort on all streams immediately***\n\nif a stream is in READY, and big stream is in ABORT,\ntrigger abort\n\nif every stream is in END or ERROR, trigger end or error\n\ncould you describe this declaritively or something?\n*/\nmodule.exports = function (ary) {\n  var capped = !!ary;\n  var inputs = (ary || []).map(create),\n      i = 0,\n      abort,\n      cb;\n\n  function create(stream) {\n    return {\n      ready: false,\n      reading: false,\n      ended: false,\n      read: stream,\n      data: null\n    };\n  }\n\n  function check() {\n    if (!cb) return;\n    clean();\n    var l = inputs.length;\n    var _cb = cb;\n\n    if (l === 0 && (abort || capped)) {\n      cb = null;\n\n      _cb(abort || true);\n\n      return;\n    } //scan the inputs to check whether there is one we can use.\n\n\n    for (var j = 0; j < l; j++) {\n      var current = inputs[(i + j) % l];\n\n      if (current.ready && !current.ended) {\n        var data = current.data;\n        current.ready = false;\n        current.data = null;\n        i++;\n        cb = null;\n        return _cb(null, data);\n      }\n    }\n  }\n\n  function clean() {\n    var l = inputs.length; //iterate backwards so that we can remove items.\n\n    while (l--) {\n      if (inputs[l].ended) inputs.splice(l, 1);\n    }\n  }\n\n  function next() {\n    var l = inputs.length;\n\n    while (l--) {\n      (function (current) {\n        //read the next item if we aren't already\n        if (l > inputs.length) throw new Error('this should never happen');\n        if (current.reading || current.ended || current.ready) return;\n        current.reading = true;\n        var sync = true;\n        current.read(abort, function next(end, data) {\n          current.data = data;\n          current.ready = true;\n          current.reading = false;\n          if (end === true || abort) current.ended = true;else if (end) abort = current.ended = end; //check whether we need to abort this stream.\n\n          if (abort && !end) current.read(abort, next);\n          if (!sync) check();\n        });\n        sync = false;\n      })(inputs[l]);\n    } //scan the feed\n\n\n    check();\n  }\n\n  function read(_abort, _cb) {\n    abort = abort || _abort;\n    cb = _cb;\n    next();\n  }\n\n  read.add = function (stream) {\n    if (!stream) {\n      //the stream will now end when all the streams end.\n      capped = true; //we just changed state, so we may need to cb\n\n      return next();\n    }\n\n    inputs.push(create(stream));\n    next();\n  };\n\n  read.cap = function (err) {\n    read.add(null);\n  };\n\n  return read;\n};","map":{"version":3,"sources":["C:/Users/gkhakurel/Downloads/Poject-main/Poject-main/client/node_modules/pull-many/index.js"],"names":["module","exports","ary","capped","inputs","map","create","i","abort","cb","stream","ready","reading","ended","read","data","check","clean","l","length","_cb","j","current","splice","next","Error","sync","end","_abort","add","push","cap","err"],"mappings":"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","sourcesContent":["\n\n/*\nall pull streams have these states:\n\n{\n  START: {\n    read: READING,\n    abort: ABORTING\n  },\n  READY: {\n    read: READING,\n    abort: ABORTING\n  },\n  READING: {\n    cb: READY,\n    err: ERROR,\n    end: END\n  },\n  ABORTING: {\n    cb: END\n  },\n  ERROR: {},\n  END: {}\n}\n\nthis module takes a collection of pull-streams,\nand interleaves their states.\nif all the streams have ended, it ends.\nIf it is in reading state, and one stream goes has READING->cb\nit goes into READY\n\non read, trigger read on every stream in START or READY\n\non abort, trigger abort on all streams immediately***\n\nif a stream is in READY, and big stream is in ABORT,\ntrigger abort\n\nif every stream is in END or ERROR, trigger end or error\n\ncould you describe this declaritively or something?\n*/\n\nmodule.exports = function (ary) {\n\n  var capped = !!ary\n  var inputs = (ary || []).map(create), i = 0, abort, cb\n\n  function create (stream) {\n    return {ready: false, reading: false, ended: false, read: stream, data: null}\n  }\n\n  function check () {\n    if(!cb) return\n    clean()\n    var l = inputs.length\n    var _cb = cb\n    if(l === 0 && (abort || capped)) {\n      cb = null; _cb(abort ||  true)\n      return\n    }\n\n    //scan the inputs to check whether there is one we can use.\n    for(var j = 0; j < l; j++) {\n      var current = inputs[(i + j) % l]\n      if(current.ready && !current.ended) {\n        var data = current.data\n        current.ready = false\n        current.data = null\n        i ++; cb = null\n        return _cb(null, data)\n      }\n    }\n  }\n\n  function clean () {\n    var l = inputs.length\n    //iterate backwards so that we can remove items.\n    while(l--) {\n      if(inputs[l].ended)\n        inputs.splice(l, 1)\n    }\n  }\n\n  function next () {\n    var l = inputs.length\n    while(l--)\n      (function (current) {\n        //read the next item if we aren't already\n        if(l > inputs.length) throw new Error('this should never happen')\n        if(current.reading || current.ended || current.ready) return\n        current.reading = true\n        var sync = true\n        current.read(abort, function next (end, data) {\n          current.data = data\n          current.ready = true\n          current.reading = false\n\n          if(end === true || abort) current.ended = true\n          else if(end) abort = current.ended = end\n          //check whether we need to abort this stream.\n          if(abort && !end) current.read(abort, next)\n          if(!sync) check()\n        })\n        sync = false\n      })(inputs[l])\n\n    //scan the feed\n    check()\n  }\n\n  function read (_abort, _cb) {\n    abort = abort || _abort; cb = _cb; next()\n  }\n\n  read.add = function (stream) {\n    if(!stream) {\n      //the stream will now end when all the streams end.\n      capped = true\n      //we just changed state, so we may need to cb\n      return next()\n    }\n    inputs.push(create(stream))\n    next()\n  }\n\n  read.cap = function (err) {\n    read.add(null)\n  }\n\n  return read\n}\n\n"]},"metadata":{},"sourceType":"script"}