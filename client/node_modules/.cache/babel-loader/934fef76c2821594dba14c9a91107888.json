{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _regeneratorRuntime = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _require = require('ipld-dag-pb'),\n    DAGLink = _require.DAGLink,\n    DAGNode = _require.DAGNode;\n\nvar UnixFS = require('ipfs-unixfs');\n\nvar multihashing = require('multihashing-async');\n\nvar Dir = require('./dir');\n\nvar persist = require('./utils/persist');\n\nvar Bucket = require('hamt-sharding');\n\nvar extend = require('deep-extend');\n\nvar hashFn = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n    var hash, justHash, length, result, i;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return multihashing(Buffer.from(value, 'utf8'), 'murmur3-128');\n\n          case 2:\n            hash = _context.sent;\n            // Multihashing inserts preamble of 2 bytes. Remove it.\n            // Also, murmur3 outputs 128 bit but, accidently, IPFS Go's\n            // implementation only uses the first 64, so we must do the same\n            // for parity..\n            justHash = hash.slice(2, 10);\n            length = justHash.length;\n            result = Buffer.alloc(length); // TODO: invert buffer because that's how Go impl does it\n\n            for (i = 0; i < length; i++) {\n              result[length - i - 1] = justHash[i];\n            }\n\n            return _context.abrupt(\"return\", result);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function hashFn(_x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nhashFn.code = 0x22; // TODO: get this from multihashing-async?\n\nvar defaultOptions = {\n  hashFn: hashFn\n};\n\nvar DirSharded = /*#__PURE__*/function (_Dir) {\n  _inherits(DirSharded, _Dir);\n\n  var _super = _createSuper(DirSharded);\n\n  function DirSharded(props, options) {\n    var _this3;\n\n    _classCallCheck(this, DirSharded);\n\n    options = extend({}, defaultOptions, options);\n    _this3 = _super.call(this, props, options);\n    _this3._bucket = Bucket(options);\n    return _this3;\n  }\n\n  _createClass(DirSharded, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, value) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._bucket.put(name, value);\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function put(_x6, _x7) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      return this._bucket.get(name);\n    }\n  }, {\n    key: \"childCount\",\n    value: function childCount() {\n      return this._bucket.leafCount();\n    }\n  }, {\n    key: \"directChildrenCount\",\n    value: function directChildrenCount() {\n      return this._bucket.childrenCount();\n    }\n  }, {\n    key: \"onlyChild\",\n    value: function onlyChild() {\n      return this._bucket.onlyChild();\n    }\n  }, {\n    key: \"eachChildSeries\",\n    value: function eachChildSeries() {\n      var _this = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, _value5, key, value;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context3.prev = 2;\n                _iterator = _asyncIterator(_this._bucket.eachLeafSeries());\n\n              case 4:\n                _context3.next = 6;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 6:\n                _step = _context3.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context3.next = 10;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 10:\n                _value = _context3.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context3.next = 18;\n                  break;\n                }\n\n                _value5 = _value, key = _value5.key, value = _value5.value;\n                _context3.next = 15;\n                return {\n                  key: key,\n                  child: value\n                };\n\n              case 15:\n                _iteratorNormalCompletion = true;\n                _context3.next = 4;\n                break;\n\n              case 18:\n                _context3.next = 24;\n                break;\n\n              case 20:\n                _context3.prev = 20;\n                _context3.t0 = _context3[\"catch\"](2);\n                _didIteratorError = true;\n                _iteratorError = _context3.t0;\n\n              case 24:\n                _context3.prev = 24;\n                _context3.prev = 25;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context3.next = 29;\n                  break;\n                }\n\n                _context3.next = 29;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 29:\n                _context3.prev = 29;\n\n                if (!_didIteratorError) {\n                  _context3.next = 32;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 32:\n                return _context3.finish(29);\n\n              case 33:\n                return _context3.finish(24);\n\n              case 34:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[2, 20, 24, 34], [25,, 29, 33]]);\n      }))();\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(path, ipld) {\n      var _this2 = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, entry;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _context4.prev = 2;\n                _iterator2 = _asyncIterator(_flush2(path, _this2._bucket, ipld, _this2.options));\n\n              case 4:\n                _context4.next = 6;\n                return _awaitAsyncGenerator(_iterator2.next());\n\n              case 6:\n                _step2 = _context4.sent;\n                _iteratorNormalCompletion2 = _step2.done;\n                _context4.next = 10;\n                return _awaitAsyncGenerator(_step2.value);\n\n              case 10:\n                _value2 = _context4.sent;\n\n                if (_iteratorNormalCompletion2) {\n                  _context4.next = 18;\n                  break;\n                }\n\n                entry = _value2;\n                _context4.next = 15;\n                return entry;\n\n              case 15:\n                _iteratorNormalCompletion2 = true;\n                _context4.next = 4;\n                break;\n\n              case 18:\n                _context4.next = 24;\n                break;\n\n              case 20:\n                _context4.prev = 20;\n                _context4.t0 = _context4[\"catch\"](2);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context4.t0;\n\n              case 24:\n                _context4.prev = 24;\n                _context4.prev = 25;\n\n                if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                  _context4.next = 29;\n                  break;\n                }\n\n                _context4.next = 29;\n                return _awaitAsyncGenerator(_iterator2.return());\n\n              case 29:\n                _context4.prev = 29;\n\n                if (!_didIteratorError2) {\n                  _context4.next = 32;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 32:\n                return _context4.finish(29);\n\n              case 33:\n                return _context4.finish(24);\n\n              case 34:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[2, 20, 24, 34], [25,, 29, 33]]);\n      }))();\n    }\n  }]);\n\n  return DirSharded;\n}(Dir);\n\nmodule.exports = DirSharded;\nmodule.exports.hashFn = hashFn;\n\nfunction _flush2(_x, _x2, _x3, _x4) {\n  return _flush.apply(this, arguments);\n}\n\nfunction _flush() {\n  _flush = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(path, bucket, ipld, options) {\n    var children, links, i, child, labelPrefix, shard, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, subShard, _dir, flushedDir, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _value4, entry, label, value, _label, size, data, dir, node, cid;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            children = bucket._children;\n            links = [];\n            i = 0;\n\n          case 3:\n            if (!(i < children.length)) {\n              _context5.next = 115;\n              break;\n            }\n\n            child = children.get(i);\n\n            if (child) {\n              _context5.next = 7;\n              break;\n            }\n\n            return _context5.abrupt(\"continue\", 112);\n\n          case 7:\n            labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n\n            if (!Bucket.isBucket(child)) {\n              _context5.next = 54;\n              break;\n            }\n\n            shard = void 0;\n            _iteratorNormalCompletion3 = true;\n            _didIteratorError3 = false;\n            _context5.prev = 12;\n            _context5.t0 = _asyncIterator;\n            _context5.next = 16;\n            return _awaitAsyncGenerator(_flush2('', child, ipld, options));\n\n          case 16:\n            _context5.t1 = _context5.sent;\n            _iterator3 = (0, _context5.t0)(_context5.t1);\n\n          case 18:\n            _context5.next = 20;\n            return _awaitAsyncGenerator(_iterator3.next());\n\n          case 20:\n            _step3 = _context5.sent;\n            _iteratorNormalCompletion3 = _step3.done;\n            _context5.next = 24;\n            return _awaitAsyncGenerator(_step3.value);\n\n          case 24:\n            _value3 = _context5.sent;\n\n            if (_iteratorNormalCompletion3) {\n              _context5.next = 31;\n              break;\n            }\n\n            subShard = _value3;\n            shard = subShard;\n\n          case 28:\n            _iteratorNormalCompletion3 = true;\n            _context5.next = 18;\n            break;\n\n          case 31:\n            _context5.next = 37;\n            break;\n\n          case 33:\n            _context5.prev = 33;\n            _context5.t2 = _context5[\"catch\"](12);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context5.t2;\n\n          case 37:\n            _context5.prev = 37;\n            _context5.prev = 38;\n\n            if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {\n              _context5.next = 42;\n              break;\n            }\n\n            _context5.next = 42;\n            return _awaitAsyncGenerator(_iterator3.return());\n\n          case 42:\n            _context5.prev = 42;\n\n            if (!_didIteratorError3) {\n              _context5.next = 45;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 45:\n            return _context5.finish(42);\n\n          case 46:\n            return _context5.finish(37);\n\n          case 47:\n            _context5.t3 = links;\n            _context5.next = 50;\n            return _awaitAsyncGenerator(new DAGLink(labelPrefix, shard.node.size, shard.cid));\n\n          case 50:\n            _context5.t4 = _context5.sent;\n\n            _context5.t3.push.call(_context5.t3, _context5.t4);\n\n            _context5.next = 112;\n            break;\n\n          case 54:\n            if (!(typeof child.value.flush === 'function')) {\n              _context5.next = 96;\n              break;\n            }\n\n            _dir = child.value;\n            flushedDir = void 0;\n            _iteratorNormalCompletion4 = true;\n            _didIteratorError4 = false;\n            _context5.prev = 59;\n            _iterator4 = _asyncIterator(_dir.flush(_dir.path, ipld));\n\n          case 61:\n            _context5.next = 63;\n            return _awaitAsyncGenerator(_iterator4.next());\n\n          case 63:\n            _step4 = _context5.sent;\n            _iteratorNormalCompletion4 = _step4.done;\n            _context5.next = 67;\n            return _awaitAsyncGenerator(_step4.value);\n\n          case 67:\n            _value4 = _context5.sent;\n\n            if (_iteratorNormalCompletion4) {\n              _context5.next = 76;\n              break;\n            }\n\n            entry = _value4;\n            flushedDir = entry;\n            _context5.next = 73;\n            return flushedDir;\n\n          case 73:\n            _iteratorNormalCompletion4 = true;\n            _context5.next = 61;\n            break;\n\n          case 76:\n            _context5.next = 82;\n            break;\n\n          case 78:\n            _context5.prev = 78;\n            _context5.t5 = _context5[\"catch\"](59);\n            _didIteratorError4 = true;\n            _iteratorError4 = _context5.t5;\n\n          case 82:\n            _context5.prev = 82;\n            _context5.prev = 83;\n\n            if (!(!_iteratorNormalCompletion4 && _iterator4.return != null)) {\n              _context5.next = 87;\n              break;\n            }\n\n            _context5.next = 87;\n            return _awaitAsyncGenerator(_iterator4.return());\n\n          case 87:\n            _context5.prev = 87;\n\n            if (!_didIteratorError4) {\n              _context5.next = 90;\n              break;\n            }\n\n            throw _iteratorError4;\n\n          case 90:\n            return _context5.finish(87);\n\n          case 91:\n            return _context5.finish(82);\n\n          case 92:\n            label = labelPrefix + child.key;\n            links.push(new DAGLink(label, flushedDir.node.size, flushedDir.cid));\n            _context5.next = 112;\n            break;\n\n          case 96:\n            value = child.value;\n\n            if (value.node) {\n              _context5.next = 105;\n              break;\n            }\n\n            if (!value.cid) {\n              _context5.next = 104;\n              break;\n            }\n\n            _context5.next = 101;\n            return _awaitAsyncGenerator(ipld.get(value.cid));\n\n          case 101:\n            value.node = _context5.sent;\n            _context5.next = 105;\n            break;\n\n          case 104:\n            return _context5.abrupt(\"continue\", 112);\n\n          case 105:\n            _label = labelPrefix + child.key;\n            size = value.node.length || value.node.size || value.node.Size;\n            _context5.t6 = links;\n            _context5.next = 110;\n            return _awaitAsyncGenerator(new DAGLink(_label, size, value.cid));\n\n          case 110:\n            _context5.t7 = _context5.sent;\n\n            _context5.t6.push.call(_context5.t6, _context5.t7);\n\n          case 112:\n            i++;\n            _context5.next = 3;\n            break;\n\n          case 115:\n            // go-ipfs uses little endian, that's why we have to\n            // reverse the bit field before storing it\n            data = Buffer.from(children.bitField().reverse());\n            dir = new UnixFS('hamt-sharded-directory', data);\n            dir.fanout = bucket.tableSize();\n            dir.hashType = options.hashFn.code;\n            node = DAGNode.create(dir.marshal(), links);\n            _context5.next = 122;\n            return _awaitAsyncGenerator(persist(node, ipld, options));\n\n          case 122:\n            cid = _context5.sent;\n            _context5.next = 125;\n            return {\n              cid: cid,\n              node: node,\n              unixfs: dir,\n              path: path\n            };\n\n          case 125:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[12, 33, 37, 47], [38,, 42, 46], [59, 78, 82, 92], [83,, 87, 91]]);\n  }));\n  return _flush.apply(this, arguments);\n}","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs-unixfs-importer/src/dir-sharded.js"],"names":["require","DAGLink","DAGNode","UnixFS","multihashing","Dir","persist","Bucket","extend","hashFn","value","Buffer","from","hash","justHash","slice","length","result","alloc","i","code","defaultOptions","DirSharded","props","options","_bucket","name","put","get","leafCount","childrenCount","onlyChild","eachLeafSeries","key","child","path","ipld","flush","entry","module","exports","bucket","children","_children","links","labelPrefix","toString","toUpperCase","padStart","isBucket","shard","subShard","node","size","cid","push","dir","flushedDir","label","Size","data","bitField","reverse","fanout","tableSize","hashType","create","marshal","unixfs"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {\n  DAGLink,\n  DAGNode\n} = require('ipld-dag-pb')\nconst UnixFS = require('ipfs-unixfs')\nconst multihashing = require('multihashing-async')\nconst Dir = require('./dir')\nconst persist = require('./utils/persist')\nconst Bucket = require('hamt-sharding')\nconst extend = require('deep-extend')\n\nconst hashFn = async function (value) {\n  const hash = await multihashing(Buffer.from(value, 'utf8'), 'murmur3-128')\n\n  // Multihashing inserts preamble of 2 bytes. Remove it.\n  // Also, murmur3 outputs 128 bit but, accidently, IPFS Go's\n  // implementation only uses the first 64, so we must do the same\n  // for parity..\n  const justHash = hash.slice(2, 10)\n  const length = justHash.length\n  const result = Buffer.alloc(length)\n  // TODO: invert buffer because that's how Go impl does it\n  for (let i = 0; i < length; i++) {\n    result[length - i - 1] = justHash[i]\n  }\n\n  return result\n}\nhashFn.code = 0x22 // TODO: get this from multihashing-async?\n\nconst defaultOptions = {\n  hashFn: hashFn\n}\n\nclass DirSharded extends Dir {\n  constructor (props, options) {\n    options = extend({}, defaultOptions, options)\n\n    super(props, options)\n\n    this._bucket = Bucket(options)\n  }\n\n  async put (name, value) {\n    await this._bucket.put(name, value)\n  }\n\n  get (name) {\n    return this._bucket.get(name)\n  }\n\n  childCount () {\n    return this._bucket.leafCount()\n  }\n\n  directChildrenCount () {\n    return this._bucket.childrenCount()\n  }\n\n  onlyChild () {\n    return this._bucket.onlyChild()\n  }\n\n  async * eachChildSeries () {\n    for await (const { key, value } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      }\n    }\n  }\n\n  async * flush (path, ipld) {\n    for await (const entry of flush(path, this._bucket, ipld, this.options)) {\n      yield entry\n    }\n  }\n}\n\nmodule.exports = DirSharded\n\nmodule.exports.hashFn = hashFn\n\nasync function * flush (path, bucket, ipld, options) {\n  const children = bucket._children\n  const links = []\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (!child) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')\n\n    if (Bucket.isBucket(child)) {\n      let shard\n\n      for await (const subShard of await flush('', child, ipld, options)) {\n        shard = subShard\n      }\n\n      links.push(await new DAGLink(labelPrefix, shard.node.size, shard.cid))\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value\n      let flushedDir\n\n      for await (const entry of dir.flush(dir.path, ipld)) {\n        flushedDir = entry\n\n        yield flushedDir\n      }\n\n      const label = labelPrefix + child.key\n      links.push(new DAGLink(label, flushedDir.node.size, flushedDir.cid))\n    } else {\n      const value = child.value\n\n      if (!value.node) {\n        if (value.cid) {\n          value.node = await ipld.get(value.cid)\n        } else {\n          continue\n        }\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.node.length || value.node.size || value.node.Size\n\n      links.push(await new DAGLink(label, size, value.cid))\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Buffer.from(children.bitField().reverse())\n  const dir = new UnixFS('hamt-sharded-directory', data)\n  dir.fanout = bucket.tableSize()\n  dir.hashType = options.hashFn.code\n\n  const node = DAGNode.create(dir.marshal(), links)\n  const cid = await persist(node, ipld, options)\n\n  yield {\n    cid,\n    node,\n    unixfs: dir,\n    path\n  }\n}\n"]},"metadata":{},"sourceType":"script"}