{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pull = require('pull-stream/pull');\n\nvar assert = require('assert');\n\nvar select = require('../select');\n\nvar selectHandler = require('./select-handler');\n\nvar lsHandler = require('./ls-handler');\n\nvar matchExact = require('./match-exact');\n\nvar util = require('./../util');\n\nvar Connection = require('interface-connection').Connection;\n\nvar PROTOCOL_ID = require('./../constants').PROTOCOL_ID;\n/**\n * Listener\n */\n\n\nvar Listener = /*#__PURE__*/function () {\n  /**\n   * Create a new Listener.\n   */\n  function Listener() {\n    var _this = this;\n\n    _classCallCheck(this, Listener);\n\n    this.handlers = {\n      ls: {\n        handlerFunc: function handlerFunc(protocol, conn) {\n          return lsHandler(_this, conn);\n        },\n        matchFunc: matchExact\n      }\n    };\n    this.log = util.log.listener();\n  }\n  /**\n   * Perform the multistream handshake.\n   *\n   * @param {Connection} rawConn - The connection on which\n   * to perform the handshake.\n   * @param {function(Error)} callback - Called when the handshake completed.\n   * @returns {undefined}\n   */\n\n\n  _createClass(Listener, [{\n    key: \"handle\",\n    value: function handle(rawConn, callback) {\n      var _this2 = this;\n\n      this.log('listener handle conn');\n      var selectStream = select(PROTOCOL_ID, function (err, conn) {\n        if (err) {\n          return callback(err);\n        }\n\n        var shConn = new Connection(conn, rawConn);\n        var sh = selectHandler(shConn, _this2.handlers, _this2.log);\n        pull(shConn, sh, shConn);\n        callback();\n      }, this.log);\n      pull(rawConn, selectStream, rawConn);\n    }\n    /**\n     * Handle a given `protocol`.\n     *\n     * @param {string} protocol - A string identifying the protocol.\n     * @param {function(string, Connection)} handlerFunc - Will be called if there is a handshake performed on `protocol`.\n     * @param {matchHandler} [matchFunc=matchExact]\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"addHandler\",\n    value: function addHandler(protocol, handlerFunc, matchFunc) {\n      this.log('adding handler: ' + protocol);\n      assert(typeof handlerFunc === 'function', 'handler must be a function');\n\n      if (this.handlers[protocol]) {\n        this.log('overwriting handler for ' + protocol);\n      }\n\n      if (!matchFunc) {\n        matchFunc = matchExact;\n      }\n\n      this.handlers[protocol] = {\n        handlerFunc: handlerFunc,\n        matchFunc: matchFunc\n      };\n    }\n    /**\n     * Receives a protocol and a callback and should\n     * call `callback(err, result)` where `err` is if\n     * there was a error on the matching function, and\n     * `result` is a boolean that represents if a\n     * match happened.\n     *\n     * @callback matchHandler\n     * @param {string} myProtocol\n     * @param {string} senderProtocol\n     * @param {function(Error, boolean)} callback\n     * @returns {undefined}\n     */\n\n  }]);\n\n  return Listener;\n}();\n\nmodule.exports = Listener;","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/multistream-select/src/listener/index.js"],"names":["pull","require","assert","select","selectHandler","lsHandler","matchExact","util","Connection","PROTOCOL_ID","Listener","handlers","ls","handlerFunc","protocol","conn","matchFunc","log","listener","rawConn","callback","selectStream","err","shConn","sh","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAMA,IAAI,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAME,MAAM,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAMG,aAAa,GAAGH,OAAO,CAAC,kBAAD,CAA7B;;AACA,IAAMI,SAAS,GAAGJ,OAAO,CAAC,cAAD,CAAzB;;AACA,IAAMK,UAAU,GAAGL,OAAO,CAAC,eAAD,CAA1B;;AAEA,IAAMM,IAAI,GAAGN,OAAO,CAAC,WAAD,CAApB;;AACA,IAAMO,UAAU,GAAGP,OAAO,CAAC,sBAAD,CAAP,CAAgCO,UAAnD;;AAEA,IAAMC,WAAW,GAAGR,OAAO,CAAC,gBAAD,CAAP,CAA0BQ,WAA9C;AAEA;AACA;AACA;;;IACMC,Q;AACJ;AACF;AACA;AACE,sBAAe;AAAA;;AAAA;;AACb,SAAKC,QAAL,GAAgB;AACdC,MAAAA,EAAE,EAAE;AACFC,QAAAA,WAAW,EAAE,qBAACC,QAAD,EAAWC,IAAX;AAAA,iBAAoBV,SAAS,CAAC,KAAD,EAAOU,IAAP,CAA7B;AAAA,SADX;AAEFC,QAAAA,SAAS,EAAEV;AAFT;AADU,KAAhB;AAOA,SAAKW,GAAL,GAAWV,IAAI,CAACU,GAAL,CAASC,QAAT,EAAX;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACE,gBAAQC,OAAR,EAAiBC,QAAjB,EAA2B;AAAA;;AACzB,WAAKH,GAAL,CAAS,sBAAT;AAEA,UAAMI,YAAY,GAAGlB,MAAM,CAACM,WAAD,EAAc,UAACa,GAAD,EAAMP,IAAN,EAAe;AACtD,YAAIO,GAAJ,EAAS;AACP,iBAAOF,QAAQ,CAACE,GAAD,CAAf;AACD;;AAED,YAAMC,MAAM,GAAG,IAAIf,UAAJ,CAAeO,IAAf,EAAqBI,OAArB,CAAf;AAEA,YAAMK,EAAE,GAAGpB,aAAa,CAACmB,MAAD,EAAS,MAAI,CAACZ,QAAd,EAAwB,MAAI,CAACM,GAA7B,CAAxB;AAEAjB,QAAAA,IAAI,CACFuB,MADE,EAEFC,EAFE,EAGFD,MAHE,CAAJ;AAMAH,QAAAA,QAAQ;AACT,OAhB0B,EAgBxB,KAAKH,GAhBmB,CAA3B;AAkBAjB,MAAAA,IAAI,CACFmB,OADE,EAEFE,YAFE,EAGFF,OAHE,CAAJ;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,oBAAYL,QAAZ,EAAsBD,WAAtB,EAAmCG,SAAnC,EAA8C;AAC5C,WAAKC,GAAL,CAAS,qBAAqBH,QAA9B;AACAZ,MAAAA,MAAM,CAAC,OAAOW,WAAP,KAAuB,UAAxB,EAAoC,4BAApC,CAAN;;AAEA,UAAI,KAAKF,QAAL,CAAcG,QAAd,CAAJ,EAA6B;AAC3B,aAAKG,GAAL,CAAS,6BAA6BH,QAAtC;AACD;;AAED,UAAI,CAACE,SAAL,EAAgB;AACdA,QAAAA,SAAS,GAAGV,UAAZ;AACD;;AAED,WAAKK,QAAL,CAAcG,QAAd,IAA0B;AACxBD,QAAAA,WAAW,EAAEA,WADW;AAExBG,QAAAA,SAAS,EAAEA;AAFa,OAA1B;AAID;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAGAS,MAAM,CAACC,OAAP,GAAiBhB,QAAjB","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream/pull')\nconst assert = require('assert')\nconst select = require('../select')\nconst selectHandler = require('./select-handler')\nconst lsHandler = require('./ls-handler')\nconst matchExact = require('./match-exact')\n\nconst util = require('./../util')\nconst Connection = require('interface-connection').Connection\n\nconst PROTOCOL_ID = require('./../constants').PROTOCOL_ID\n\n/**\n * Listener\n */\nclass Listener {\n  /**\n   * Create a new Listener.\n   */\n  constructor () {\n    this.handlers = {\n      ls: {\n        handlerFunc: (protocol, conn) => lsHandler(this, conn),\n        matchFunc: matchExact\n\n      }\n    }\n    this.log = util.log.listener()\n  }\n\n  /**\n   * Perform the multistream handshake.\n   *\n   * @param {Connection} rawConn - The connection on which\n   * to perform the handshake.\n   * @param {function(Error)} callback - Called when the handshake completed.\n   * @returns {undefined}\n   */\n  handle (rawConn, callback) {\n    this.log('listener handle conn')\n\n    const selectStream = select(PROTOCOL_ID, (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const shConn = new Connection(conn, rawConn)\n\n      const sh = selectHandler(shConn, this.handlers, this.log)\n\n      pull(\n        shConn,\n        sh,\n        shConn\n      )\n\n      callback()\n    }, this.log)\n\n    pull(\n      rawConn,\n      selectStream,\n      rawConn\n    )\n  }\n\n  /**\n   * Handle a given `protocol`.\n   *\n   * @param {string} protocol - A string identifying the protocol.\n   * @param {function(string, Connection)} handlerFunc - Will be called if there is a handshake performed on `protocol`.\n   * @param {matchHandler} [matchFunc=matchExact]\n   * @returns {undefined}\n   */\n  addHandler (protocol, handlerFunc, matchFunc) {\n    this.log('adding handler: ' + protocol)\n    assert(typeof handlerFunc === 'function', 'handler must be a function')\n\n    if (this.handlers[protocol]) {\n      this.log('overwriting handler for ' + protocol)\n    }\n\n    if (!matchFunc) {\n      matchFunc = matchExact\n    }\n\n    this.handlers[protocol] = {\n      handlerFunc: handlerFunc,\n      matchFunc: matchFunc\n    }\n  }\n\n  /**\n   * Receives a protocol and a callback and should\n   * call `callback(err, result)` where `err` is if\n   * there was a error on the matching function, and\n   * `result` is a boolean that represents if a\n   * match happened.\n   *\n   * @callback matchHandler\n   * @param {string} myProtocol\n   * @param {string} senderProtocol\n   * @param {function(Error, boolean)} callback\n   * @returns {undefined}\n   */\n}\n\nmodule.exports = Listener\n"]},"metadata":{},"sourceType":"script"}