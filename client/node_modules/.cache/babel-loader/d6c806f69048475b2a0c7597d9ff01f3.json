{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/Poject-main/Poject-main/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar log = require('debug')('ipfs:mfs:stat');\n\nvar errCode = require('err-code');\n\nvar defaultOptions = {\n  withLocal: false\n};\n\nmodule.exports = function (context) {\n  return /*#__PURE__*/function () {\n    var _mfsStat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, options) {\n      var _yield$toMfsPath, type, cid, mfsPath, exportPath, file;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = applyDefaultOptions(options, defaultOptions);\n              log(\"Fetching stats for \".concat(path));\n              _context.next = 4;\n              return toMfsPath(context, path);\n\n            case 4:\n              _yield$toMfsPath = _context.sent;\n              type = _yield$toMfsPath.type;\n              cid = _yield$toMfsPath.cid;\n              mfsPath = _yield$toMfsPath.mfsPath;\n              exportPath = type === 'ipfs' && cid ? cid : mfsPath;\n              _context.prev = 9;\n              _context.next = 12;\n              return exporter(exportPath, context.ipld);\n\n            case 12:\n              file = _context.sent;\n              _context.next = 20;\n              break;\n\n            case 15:\n              _context.prev = 15;\n              _context.t0 = _context[\"catch\"](9);\n\n              if (!(_context.t0.code === 'ERR_NOT_FOUND')) {\n                _context.next = 19;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(path, \" does not exist\")), 'ERR_NOT_FOUND');\n\n            case 19:\n              throw _context.t0;\n\n            case 20:\n              if (statters[file.cid.codec]) {\n                _context.next = 22;\n                break;\n              }\n\n              throw new Error(\"Cannot stat codec \".concat(file.cid.codec));\n\n            case 22:\n              return _context.abrupt(\"return\", statters[file.cid.codec](file, options));\n\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[9, 15]]);\n    }));\n\n    function mfsStat(_x, _x2) {\n      return _mfsStat.apply(this, arguments);\n    }\n\n    return mfsStat;\n  }();\n};\n\nvar statters = {\n  raw: function raw(file) {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n  'dag-pb': function dagPb(file) {\n    var blocks = file.node.Links.length;\n    var size = file.node.size;\n    var cumulativeSize = file.node.size;\n    var nodeType = null;\n\n    if (file.unixfs) {\n      size = file.unixfs.fileSize();\n      nodeType = file.unixfs.type;\n\n      if (nodeType.includes('directory')) {\n        size = 0;\n        cumulativeSize = file.node.size;\n      }\n\n      if (nodeType === 'file') {\n        blocks = file.unixfs.blockSizes.length;\n      }\n    }\n\n    return {\n      cid: file.cid,\n      size: size,\n      cumulativeSize: cumulativeSize,\n      blocks: blocks,\n      type: nodeType,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n  'dag-cbor': function dagCbor(file) {\n    return {\n      cid: file.cid,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  }\n};","map":{"version":3,"sources":["D:/Poject-main/Poject-main/client/node_modules/ipfs-mfs/src/core/stat.js"],"names":["applyDefaultOptions","require","toMfsPath","exporter","log","errCode","defaultOptions","withLocal","module","exports","context","path","options","type","cid","mfsPath","exportPath","ipld","file","code","Error","statters","codec","mfsStat","raw","size","node","length","cumulativeSize","blocks","local","undefined","sizeLocal","withLocality","Links","nodeType","unixfs","fileSize","includes","blockSizes"],"mappings":"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","sourcesContent":["'use strict'\n\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst exporter = require('ipfs-unixfs-exporter')\nconst log = require('debug')('ipfs:mfs:stat')\nconst errCode = require('err-code')\n\nconst defaultOptions = {\n  withLocal: false\n}\n\nmodule.exports = (context) => {\n  return async function mfsStat (path, options) {\n    options = applyDefaultOptions(options, defaultOptions)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      type,\n      cid,\n      mfsPath\n    } = await toMfsPath(context, path)\n\n    let exportPath = type === 'ipfs' && cid ? cid : mfsPath\n    let file\n\n    try {\n      file = await exporter(exportPath, context.ipld)\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')\n      }\n\n      throw err\n    }\n\n    if (!statters[file.cid.codec]) {\n      throw new Error(`Cannot stat codec ${file.cid.codec}`)\n    }\n\n    return statters[file.cid.codec](file, options)\n  }\n}\n\nconst statters = {\n  raw: (file) => {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file', // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  },\n  'dag-pb': (file) => {\n    let blocks = file.node.Links.length\n    let size = file.node.size\n    let cumulativeSize = file.node.size\n    let nodeType = null\n\n    if (file.unixfs) {\n      size = file.unixfs.fileSize()\n      nodeType = file.unixfs.type\n\n      if (nodeType.includes('directory')) {\n        size = 0\n        cumulativeSize = file.node.size\n      }\n\n      if (nodeType === 'file') {\n        blocks = file.unixfs.blockSizes.length\n      }\n    }\n\n    return {\n      cid: file.cid,\n      size: size,\n      cumulativeSize: cumulativeSize,\n      blocks: blocks,\n      type: nodeType,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  },\n  'dag-cbor': (file) => {\n    return {\n      cid: file.cid,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}