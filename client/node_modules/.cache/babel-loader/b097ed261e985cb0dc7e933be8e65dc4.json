{"ast":null,"code":"'use strict';\n\nvar tryEach = require('async/tryEach');\n\nvar parallel = require('async/parallel');\n\nvar errCode = require('err-code');\n\nmodule.exports = function (node) {\n  var routers = node._modules.contentRouting || []; // If we have the dht, make it first\n\n  if (node._dht) {\n    routers.unshift(node._dht);\n  }\n\n  return {\n    /**\n     * Iterates over all content routers in series to find providers of the given key.\n     * Once a content router succeeds, iteration will stop.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @param {object} options\n     * @param {number} options.maxTimeout How long the query should run\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @param {function(Error, Result<Array>)} callback\n     * @returns {void}\n     */\n    findProviders: function findProviders(key, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else if (typeof options === 'number') {\n        // This can be deprecated in a future release\n        options = {\n          maxTimeout: options\n        };\n      }\n\n      if (!routers.length) {\n        return callback(errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE'));\n      }\n\n      var tasks = routers.map(function (router) {\n        return function (cb) {\n          return router.findProviders(key, options, function (err, results) {\n            if (err) {\n              return cb(err);\n            } // If we don't have any results, we need to provide an error to keep trying\n\n\n            if (!results || Object.keys(results).length === 0) {\n              return cb(errCode(new Error('not found'), 'NOT_FOUND'), null);\n            }\n\n            cb(null, results);\n          });\n        };\n      });\n      tryEach(tasks, function (err, results) {\n        if (err && err.code !== 'NOT_FOUND') {\n          return callback(err);\n        }\n\n        results = results || [];\n        callback(null, results);\n      });\n    },\n\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    provide: function provide(key, callback) {\n      if (!routers.length) {\n        return callback(errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE'));\n      }\n\n      parallel(routers.map(function (router) {\n        return function (cb) {\n          return router.provide(key, cb);\n        };\n      }), callback);\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/dd/Desktop/Project SSI/Major Project/client/node_modules/libp2p/src/content-routing.js"],"names":["tryEach","require","parallel","errCode","module","exports","node","routers","_modules","contentRouting","_dht","unshift","findProviders","key","options","callback","maxTimeout","length","Error","tasks","map","router","cb","err","results","Object","keys","code","provide"],"mappings":"AAAA;;AAEA,IAAMA,OAAO,GAAGC,OAAO,CAAC,eAAD,CAAvB;;AACA,IAAMC,QAAQ,GAAGD,OAAO,CAAC,gBAAD,CAAxB;;AACA,IAAME,OAAO,GAAGF,OAAO,CAAC,UAAD,CAAvB;;AAEAG,MAAM,CAACC,OAAP,GAAiB,UAACC,IAAD,EAAU;AACzB,MAAMC,OAAO,GAAGD,IAAI,CAACE,QAAL,CAAcC,cAAd,IAAgC,EAAhD,CADyB,CAGzB;;AACA,MAAIH,IAAI,CAACI,IAAT,EAAe;AACbH,IAAAA,OAAO,CAACI,OAAR,CAAgBL,IAAI,CAACI,IAArB;AACD;;AAED,SAAO;AACL;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIE,IAAAA,aAAa,EAAE,uBAACC,GAAD,EAAMC,OAAN,EAAeC,QAAf,EAA4B;AACzC,UAAI,OAAOD,OAAP,KAAmB,UAAvB,EAAmC;AACjCC,QAAAA,QAAQ,GAAGD,OAAX;AACAA,QAAAA,OAAO,GAAG,EAAV;AACD,OAHD,MAGO,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAAE;AACxCA,QAAAA,OAAO,GAAG;AACRE,UAAAA,UAAU,EAAEF;AADJ,SAAV;AAGD;;AAED,UAAI,CAACP,OAAO,CAACU,MAAb,EAAqB;AACnB,eAAOF,QAAQ,CAACZ,OAAO,CAAC,IAAIe,KAAJ,CAAU,8BAAV,CAAD,EAA4C,sBAA5C,CAAR,CAAf;AACD;;AAED,UAAMC,KAAK,GAAGZ,OAAO,CAACa,GAAR,CAAY,UAACC,MAAD,EAAY;AACpC,eAAO,UAACC,EAAD;AAAA,iBAAQD,MAAM,CAACT,aAAP,CAAqBC,GAArB,EAA0BC,OAA1B,EAAmC,UAACS,GAAD,EAAMC,OAAN,EAAkB;AAClE,gBAAID,GAAJ,EAAS;AACP,qBAAOD,EAAE,CAACC,GAAD,CAAT;AACD,aAHiE,CAKlE;;;AACA,gBAAI,CAACC,OAAD,IAAYC,MAAM,CAACC,IAAP,CAAYF,OAAZ,EAAqBP,MAArB,KAAgC,CAAhD,EAAmD;AACjD,qBAAOK,EAAE,CAACnB,OAAO,CAAC,IAAIe,KAAJ,CAAU,WAAV,CAAD,EAAyB,WAAzB,CAAR,EAA+C,IAA/C,CAAT;AACD;;AAEDI,YAAAA,EAAE,CAAC,IAAD,EAAOE,OAAP,CAAF;AACD,WAXc,CAAR;AAAA,SAAP;AAYD,OAba,CAAd;AAeAxB,MAAAA,OAAO,CAACmB,KAAD,EAAQ,UAACI,GAAD,EAAMC,OAAN,EAAkB;AAC/B,YAAID,GAAG,IAAIA,GAAG,CAACI,IAAJ,KAAa,WAAxB,EAAqC;AACnC,iBAAOZ,QAAQ,CAACQ,GAAD,CAAf;AACD;;AACDC,QAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAT,QAAAA,QAAQ,CAAC,IAAD,EAAOS,OAAP,CAAR;AACD,OANM,CAAP;AAOD,KAhDI;;AAkDL;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACII,IAAAA,OAAO,EAAE,iBAACf,GAAD,EAAME,QAAN,EAAmB;AAC1B,UAAI,CAACR,OAAO,CAACU,MAAb,EAAqB;AACnB,eAAOF,QAAQ,CAACZ,OAAO,CAAC,IAAIe,KAAJ,CAAU,8BAAV,CAAD,EAA4C,sBAA5C,CAAR,CAAf;AACD;;AAEDhB,MAAAA,QAAQ,CAACK,OAAO,CAACa,GAAR,CAAY,UAACC,MAAD,EAAY;AAC/B,eAAO,UAACC,EAAD;AAAA,iBAAQD,MAAM,CAACO,OAAP,CAAef,GAAf,EAAoBS,EAApB,CAAR;AAAA,SAAP;AACD,OAFQ,CAAD,EAEJP,QAFI,CAAR;AAGD;AAlEI,GAAP;AAoED,CA5ED","sourcesContent":["'use strict'\n\nconst tryEach = require('async/tryEach')\nconst parallel = require('async/parallel')\nconst errCode = require('err-code')\n\nmodule.exports = (node) => {\n  const routers = node._modules.contentRouting || []\n\n  // If we have the dht, make it first\n  if (node._dht) {\n    routers.unshift(node._dht)\n  }\n\n  return {\n    /**\n     * Iterates over all content routers in series to find providers of the given key.\n     * Once a content router succeeds, iteration will stop.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @param {object} options\n     * @param {number} options.maxTimeout How long the query should run\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @param {function(Error, Result<Array>)} callback\n     * @returns {void}\n     */\n    findProviders: (key, options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      } else if (typeof options === 'number') { // This can be deprecated in a future release\n        options = {\n          maxTimeout: options\n        }\n      }\n\n      if (!routers.length) {\n        return callback(errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE'))\n      }\n\n      const tasks = routers.map((router) => {\n        return (cb) => router.findProviders(key, options, (err, results) => {\n          if (err) {\n            return cb(err)\n          }\n\n          // If we don't have any results, we need to provide an error to keep trying\n          if (!results || Object.keys(results).length === 0) {\n            return cb(errCode(new Error('not found'), 'NOT_FOUND'), null)\n          }\n\n          cb(null, results)\n        })\n      })\n\n      tryEach(tasks, (err, results) => {\n        if (err && err.code !== 'NOT_FOUND') {\n          return callback(err)\n        }\n        results = results || []\n        callback(null, results)\n      })\n    },\n\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n    provide: (key, callback) => {\n      if (!routers.length) {\n        return callback(errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE'))\n      }\n\n      parallel(routers.map((router) => {\n        return (cb) => router.provide(key, cb)\n      }), callback)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}